<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StarPU Handbook: Offline Performance Tools</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('OfflinePerformanceTools.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Offline Performance Tools </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>To get an idea of what is happening, a lot of performance feedback is available, detailed in this chapter. The various informations should be checked for.</p>
<ul>
<li>
What does the Gantt diagram look like? (see <a class="el" href="OfflinePerformanceTools.html#CreatingAGanttDiagram">Creating a Gantt Diagram</a>) <ul>
<li>
If it's mostly green (tasks running in the initial context) or context specific color prevailing, then the machine is properly utilized, and perhaps the codelets are just slow. Check their performance, see <a class="el" href="OfflinePerformanceTools.html#PerformanceOfCodelets">Performance Of Codelets</a>.  </li>
<li>
If it's mostly purple (FetchingInput), tasks keep waiting for data transfers, do you perhaps have far more communication than computation? Did you properly use CUDA streams to make sure communication can be overlapped? Did you use data-locality aware schedulers to avoid transfers as much as possible?  </li>
<li>
If it's mostly red (Blocked), tasks keep waiting for dependencies, do you have enough parallelism? It might be a good idea to check what the DAG looks like (see <a class="el" href="OfflinePerformanceTools.html#CreatingADAGWithGraphviz">Creating a DAG With Graphviz</a>).  </li>
<li>
If only some workers are completely red (Blocked), for some reason the scheduler didn't assign tasks to them. Perhaps the performance model is bogus, check it (see <a class="el" href="OfflinePerformanceTools.html#PerformanceOfCodelets">Performance Of Codelets</a>). Do all your codelets have a performance model? When some of them don't, the schedulers switches to a greedy algorithm which thus performs badly.  </li>
</ul>
</li>
</ul>
<p>You can also use the Temanejo task debugger (see <a class="el" href="DebuggingTools.html#UsingTheTemanejoTaskDebugger">Using The Temanejo Task Debugger</a>) to visualize the task graph more easily. </p>
<h1><a class="anchor" id="Off-linePerformanceFeedback"></a>
Off-line Performance Feedback</h1>
<h2><a class="anchor" id="GeneratingTracesWithFxT"></a>
Generating Traces With FxT</h2>
<p>StarPU can use the FxT library (see <a href="https://savannah.nongnu.org/projects/fkt/">https://savannah.nongnu.org/projects/fkt/</a>) to generate traces with a limited runtime overhead.</p>
<p>You can get a tarball from <a href="http://download.savannah.gnu.org/releases/fkt/?C=M">http://download.savannah.gnu.org/releases/fkt/?C=M</a></p>
<p>Compiling and installing the FxT library in the <code>$FXTDIR</code> path is done following the standard procedure:</p>
<pre class="fragment">$ ./configure --prefix=$FXTDIR
$ make
$ make install
</pre><p>In order to have StarPU to generate traces, StarPU should be configured with the option <a class="el" href="CompilationConfiguration.html#with-fxt">--with-fxt</a> :</p>
<pre class="fragment">$ ./configure --with-fxt=$FXTDIR
</pre><p>Or you can simply point the <code>PKG_CONFIG_PATH</code> to <code>$FXTDIR/lib/pkgconfig</code> and pass <a class="el" href="CompilationConfiguration.html#with-fxt">--with-fxt</a> to <code>configure</code></p>
<p>When FxT is enabled, a trace is generated when StarPU is terminated by calling <a class="el" href="group__API__Initialization__and__Termination.html#ga48edf5e30e71fbb71923e3867ad16c0a">starpu_shutdown()</a>. The trace is a binary file whose name has the form <code>prof_file_XXX_YYY</code> where <code>XXX</code> is the user name, and <code>YYY</code> is the MPI id of the process that used StarPU (or 0 when running a sequential program). One can change the name of the file by setting the environnement variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_FXT_SUFFIX">STARPU_FXT_SUFFIX</a>, its contents will be used instead of <code>prof_file_XXX</code>. This file is saved in the <code>/tmp/</code> directory by default, or by the directory specified by the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_FXT_PREFIX">STARPU_FXT_PREFIX</a>.</p>
<p>The additional <code>configure</code> option <a class="el" href="CompilationConfiguration.html#enable-fxt-lock">--enable-fxt-lock</a> can be used to generate trace events which describes the locks behaviour during the execution. It is however very heavy and should not be used unless debugging StarPU's internal locking.</p>
<p>The environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_FXT_TRACE">STARPU_FXT_TRACE</a> can be set to 0 to disable the generation of the <code>prof_file_XXX_YYY</code> file.</p>
<p>When the FxT trace file <code>prof_file_something</code> has been generated, it is possible to generate different trace formats by calling:</p>
<pre class="fragment">$ starpu_fxt_tool -i /tmp/prof_file_something
</pre><p>Or alternatively, setting the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_GENERATE_TRACE">STARPU_GENERATE_TRACE</a> to <code>1</code> before application execution will make StarPU do it automatically at application shutdown.</p>
<p>One can also set the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_GENERATE_TRACE_OPTIONS">STARPU_GENERATE_TRACE_OPTIONS</a> to specify options, see <code>starpu_fxt_tool &ndash;help</code>, for example:</p>
<pre class="fragment">$ export STARPU_GENERATE_TRACE=1
$ export STARPU_GENERATE_TRACE_OPTIONS="-no-acquire"
</pre><p>When running a MPI application, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_GENERATE_TRACE">STARPU_GENERATE_TRACE</a> will not work as expected (each node will try to generate trace files, thus mixing outputs...), you have to collect the trace files from the MPI nodes, and specify them all on the command <code>starpu_fxt_tool</code>, for instance:</p>
<pre class="fragment">$ starpu_fxt_tool -i /tmp/prof_file_something*
</pre><p>By default, the generated trace contains all informations. To reduce the trace size, various <code>-no-foo</code> options can be passed to <code>starpu_fxt_tool</code>, see <code>starpu_fxt_tool &ndash;help</code> .</p>
<h3><a class="anchor" id="CreatingAGanttDiagram"></a>
Creating a Gantt Diagram</h3>
<p>One of the generated files is a trace in the Paje format. The file, located in the current directory, is named <code>paje.trace</code>. It can be viewed with ViTE (<a href="http://vite.gforge.inria.fr/">http://vite.gforge.inria.fr/</a>) a trace visualizing open-source tool. To open the file <code>paje.trace</code> with ViTE, use the following command:</p>
<pre class="fragment">$ vite paje.trace
</pre><p>Tasks can be assigned a name (instead of the default <code>unknown</code>) by filling the optional <a class="el" href="group__API__Codelet__And__Tasks.html#adcf01d67d595a98dab791de1325264b6">starpu_codelet::name</a>, or assigning them a performance model. The name can also be set with the field <a class="el" href="group__API__Codelet__And__Tasks.html#a80436666543cf7222446e668ed63ade1">starpu_task::name</a> or by using <a class="el" href="group__API__Insert__Task.html#ga663bee5a319a5c763af85f0b0071f92f">STARPU_NAME</a> when calling <a class="el" href="group__API__Insert__Task.html#gad79a50a21fe717126659b2998209c1c6">starpu_task_insert()</a>.</p>
<p>Tasks are assigned default colors based on the worker which executed them (green for CPUs, yellow/orange/red for CUDAs, blue for OpenCLs, red for MICs, ...). To use a different color for every type of task, one can specify the option <code>-c</code> to <code>starpu_fxt_tool</code> or in <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_GENERATE_TRACE_OPTIONS">STARPU_GENERATE_TRACE_OPTIONS</a>. Tasks can also be given a specific color by setting the field <a class="el" href="group__API__Codelet__And__Tasks.html#ad6dfcbb8bb86ca8ce0678b4b10bf853b">starpu_codelet::color</a> or the <a class="el" href="group__API__Codelet__And__Tasks.html#ab96604deeb87e2924df311c9b5a7d303">starpu_task::color</a>. Colors are expressed with the following format <code>0xRRGGBB</code> (e.g <code>0xFF0000</code> for red). See <code>basic_examples/task_insert_color</code> for examples on how to assign colors.</p>
<p>To get statistics on the time spend in runtime overhead, one can use the statistics plugin of ViTE. In Preferences, select Plugins. In "States Type", select "Worker State". Then click on "Reload" to update the histogram. The red "Idle" percentages are due to lack of parallelism, while the brown "Overhead" and "Scheduling" percentages are due to the overhead of the runtime and of the scheduler.</p>
<p>To identify tasks precisely, the application can also set the field <a class="el" href="group__API__Codelet__And__Tasks.html#a845187be6bfe1c241663913a98eefa65">starpu_task::tag_id</a> or setting <a class="el" href="group__API__Insert__Task.html#ga2a2f1dbde5737ec9cc60773ea5dd124d">STARPU_TAG_ONLY</a> when calling <a class="el" href="group__API__Insert__Task.html#gad79a50a21fe717126659b2998209c1c6">starpu_task_insert()</a>. The value of the tag will then show up in the trace.</p>
<p>One can also introduce user-defined events in the diagram thanks to the <a class="el" href="group__API__FxT__Support.html#gabe14377ea858ed3b40c1b469d7a4a4ea">starpu_fxt_trace_user_event_string()</a> function.</p>
<p>One can also set the iteration number, by just calling <a class="el" href="group__API__Codelet__And__Tasks.html#gad3adbc7185e231bf23c94c76b85c3047">starpu_iteration_push()</a> at the beginning of submission loops and <a class="el" href="group__API__Codelet__And__Tasks.html#ga7f931b9a69bb5dac48a9f8f904cd333e">starpu_iteration_pop()</a> at the end of submission loops. These iteration numbers will show up in traces for all tasks submitted from there.</p>
<p>Coordinates can also be given to data with the <a class="el" href="group__API__Data__Management.html#gab9497db9ea78dafa7ba0a2b99a7fc0f2">starpu_data_set_coordinates()</a> or <a class="el" href="group__API__Data__Management.html#ga9d4db8e3a8a6ea4c6757a455849e1504">starpu_data_set_coordinates_array()</a> function. In the trace, tasks will then be assigned the coordinates of the first data they write to.</p>
<p>Traces can also be inspected by hand by using the tool <code>fxt_print</code>, for instance:</p>
<pre class="fragment">$ fxt_print -o -f /tmp/prof_file_something
</pre><p>Timings are in nanoseconds (while timings as seen in ViTE are in milliseconds).</p>
<h3><a class="anchor" id="CreatingADAGWithGraphviz"></a>
Creating a DAG With Graphviz</h3>
<p>Another generated trace file is a task graph described using the DOT language. The file, created in the current directory, is named <code>dag.dot</code> file in the current directory. It is possible to get a graphical output of the graph by using the <code>graphviz</code> library:</p>
<pre class="fragment">$ dot -Tpdf dag.dot -o output.pdf
</pre><h3><a class="anchor" id="TraceTaskDetails"></a>
Getting Task Details</h3>
<p>Another generated trace file gives details on the executed tasks. The file, created in the current directory, is named <code>tasks.rec</code>. This file is in the recutils format, i.e. <code>Field: value</code> lines, and empty lines to separate each task. This can be used as a convenient input for various ad-hoc analysis tools. By default it only contains information about the actual execution. Performance models can be obtained by running <code>starpu_tasks_rec_complete</code> on it:</p>
<pre class="fragment">$ starpu_tasks_rec_complete tasks.rec tasks2.rec
</pre><p>which will add <code>EstimatedTime</code> lines which contain the performance model-estimated time (in Âµs) for each worker starting from 0. Since it needs the performance models, it needs to be run the same way as the application execution, or at least with <code>STARPU_HOSTNAME</code> set to the hostname of the machine used for execution, to get the performance models of that machine.</p>
<p>Another possibility is to obtain the performance models as an auxiliary <code>perfmodel.rec</code> file, by using the <code>starpu_perfmodel_recdump</code> utility:</p>
<pre class="fragment">$ starpu_perfmodel_recdump tasks.rec -o perfmodel.rec
</pre><h3><a class="anchor" id="MonitoringActivity"></a>
Monitoring Activity</h3>
<p>Another generated trace file is an activity trace. The file, created in the current directory, is named <code>activity.data</code>. A profile of the application showing the activity of StarPU during the execution of the program can be generated:</p>
<pre class="fragment">$ starpu_workers_activity activity.data
</pre><p>This will create a file named <code>activity.eps</code> in the current directory. This picture is composed of two parts. The first part shows the activity of the different workers. The green sections indicate which proportion of the time was spent executed kernels on the processing unit. The red sections indicate the proportion of time spent in StartPU: an important overhead may indicate that the granularity may be too low, and that bigger tasks may be appropriate to use the processing unit more efficiently. The black sections indicate that the processing unit was blocked because there was no task to process: this may indicate a lack of parallelism which may be alleviated by creating more tasks when it is possible.</p>
<p>The second part of the picture <code>activity.eps</code> is a graph showing the evolution of the number of tasks available in the system during the execution. Ready tasks are shown in black, and tasks that are submitted but not schedulable yet are shown in grey.</p>
<h3><a class="anchor" id="Animation"></a>
Getting Modular Schedular Animation</h3>
<p>When using modular schedulers (i.e. schedulers which use a modular architecture, and whose name start with "modular-"), the call to <code>starpu_fxt_tool</code> will also produce a <code>trace.html</code> file which can be viewed in a javascript-enabled web browser. It shows the flow of tasks between the components of the modular scheduler.</p>
<h2><a class="anchor" id="LimitingScopeTrace"></a>
Limiting The Scope Of The Trace</h2>
<p>For computing statistics, it is useful to limit the trace to a given portion of the time of the whole execution. This can be achieved by calling</p>
<div class="fragment"><div class="line"><a class="code" href="group__API__FxT__Support.html#ga6a7af6697ae7a67161d3655c59215c09">starpu_fxt_autostart_profiling</a>(0)</div></div><!-- fragment --><p>before calling <a class="el" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init()</a>, to prevent tracing from starting immediately. Then</p>
<div class="fragment"><div class="line"><a class="code" href="group__API__FxT__Support.html#ga5793bf5c8fc0bedf76d18a5fa38593df">starpu_fxt_start_profiling</a>();</div></div><!-- fragment --><p>and</p>
<div class="fragment"><div class="line"><a class="code" href="group__API__FxT__Support.html#ga52a3e1a95689315f0b789a3325ec2a90">starpu_fxt_stop_profiling</a>();</div></div><!-- fragment --><p>can be used around the portion of code to be traced. This will show up as marks in the trace, and states of workers will only show up for that portion.</p>
<h1><a class="anchor" id="PerformanceOfCodelets"></a>
Performance Of Codelets</h1>
<p>The performance model of codelets (see <a class="el" href="OnlinePerformanceTools.html#PerformanceModelExample">Performance Model Example</a>) can be examined by using the tool <code>starpu_perfmodel_display</code>:</p>
<pre class="fragment">$ starpu_perfmodel_display -l
file: &lt;malloc_pinned.hannibal&gt;
file: &lt;starpu_slu_lu_model_21.hannibal&gt;
file: &lt;starpu_slu_lu_model_11.hannibal&gt;
file: &lt;starpu_slu_lu_model_22.hannibal&gt;
file: &lt;starpu_slu_lu_model_12.hannibal&gt;
</pre><p>Here, the codelets of the example <code>lu</code> are available. We can examine the performance of the kernel <code>22</code> (in micro-seconds), which is history-based:</p>
<pre class="fragment">$ starpu_perfmodel_display -s starpu_slu_lu_model_22
performance model for cpu
# hash      size       mean          dev           n
57618ab0    19660800   2.851069e+05  1.829369e+04  109
performance model for cuda_0
# hash      size       mean          dev           n
57618ab0    19660800   1.164144e+04  1.556094e+01  315
performance model for cuda_1
# hash      size       mean          dev           n
57618ab0    19660800   1.164271e+04  1.330628e+01  360
performance model for cuda_2
# hash      size       mean          dev           n
57618ab0    19660800   1.166730e+04  3.390395e+02  456
</pre><p>We can see that for the given size, over a sample of a few hundreds of execution, the GPUs are about 20 times faster than the CPUs (numbers are in us). The standard deviation is extremely low for the GPUs, and less than 10% for CPUs.</p>
<p>This tool can also be used for regression-based performance models. It will then display the regression formula, and in the case of non-linear regression, the same performance log as for history-based performance models:</p>
<pre class="fragment">$ starpu_perfmodel_display -s non_linear_memset_regression_based
performance model for cpu_impl_0
	Regression : #sample = 1400
	Linear: y = alpha size ^ beta
		alpha = 1.335973e-03
		beta = 8.024020e-01
	Non-Linear: y = a size ^b + c
		a = 5.429195e-04
		b = 8.654899e-01
		c = 9.009313e-01
# hash		size		mean		stddev		n
a3d3725e	4096           	4.763200e+00   	7.650928e-01   	100
870a30aa	8192           	1.827970e+00   	2.037181e-01   	100
48e988e9	16384          	2.652800e+00   	1.876459e-01   	100
961e65d2	32768          	4.255530e+00   	3.518025e-01   	100
...
</pre><p>The same can also be achieved by using StarPU's library API, see <a class="el" href="group__API__Performance__Model.html">Performance Model</a> and notably the function <a class="el" href="group__API__Performance__Model.html#ga5ab7213f5c229c16e783004853fcba4c">starpu_perfmodel_load_symbol()</a>. The source code of the tool <code>starpu_perfmodel_display</code> can be a useful example.</p>
<p>An XML output can also be printed by using the <code>-x</code> option: </p><pre class="fragment">tools/starpu_perfmodel_display -x -s non_linear_memset_regression_based 
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE StarPUPerfmodel SYSTEM "starpu-perfmodel.dtd"&gt;
&lt;!-- symbol non_linear_memset_regression_based --&gt;
&lt;!-- All times in us --&gt;
&lt;perfmodel version="45"&gt;
  &lt;combination&gt;
    &lt;device type="CPU" id="0" ncores="1"/&gt;
    &lt;implementation id="0"&gt;
      &lt;!-- cpu0_impl0 (Comb0) --&gt;
      &lt;!-- time = a size ^b + c --&gt;
      &lt;nl_regression a="5.429195e-04" b="8.654899e-01" c="9.009313e-01"/&gt;
      &lt;entry footprint="a3d3725e" size="4096" flops="0.000000e+00" mean="4.763200e+00" deviation="7.650928e-01" nsample="100"/&gt;
      &lt;entry footprint="870a30aa" size="8192" flops="0.000000e+00" mean="1.827970e+00" deviation="2.037181e-01" nsample="100"/&gt;
      &lt;entry footprint="48e988e9" size="16384" flops="0.000000e+00" mean="2.652800e+00" deviation="1.876459e-01" nsample="100"/&gt;
      &lt;entry footprint="961e65d2" size="32768" flops="0.000000e+00" mean="4.255530e+00" deviation="3.518025e-01" nsample="100"/&gt;
    &lt;/implementation&gt;
  &lt;/combination&gt;
&lt;/perfmodel&gt;
</pre><p>The tool <code>starpu_perfmodel_plot</code> can be used to draw performance models. It writes a <code>.gp</code> file in the current directory, to be run with the tool <code>gnuplot</code>, which shows the corresponding curve.</p>
<div class="image">
<img src="starpu_non_linear_memset_regression_based.png" alt="starpu_non_linear_memset_regression_based.png"/>
</div>
 <p>When the field <a class="el" href="group__API__Codelet__And__Tasks.html#a840563895dbf036b6ffd783a8ea2504d">starpu_task::flops</a> is set (or <a class="el" href="group__API__Insert__Task.html#ga1a0a565f2de522abc9c5f3457397b095">STARPU_FLOPS</a> is passed to <a class="el" href="group__API__Insert__Task.html#gad79a50a21fe717126659b2998209c1c6">starpu_task_insert()</a>), <code>starpu_perfmodel_plot</code> can directly draw a GFlops/s curve, by simply adding the <code>-f</code> option:</p>
<pre class="fragment">$ starpu_perfmodel_plot -f -s chol_model_11
</pre><p>This will however disable displaying the regression model, for which we can not compute GFlops/s.</p>
<div class="image">
<img src="starpu_chol_model_11_type.png" alt="starpu_chol_model_11_type.png"/>
</div>
 <p>When the FxT trace file <code>prof_file_something</code> has been generated, it is possible to get a profiling of each codelet by calling:</p>
<pre class="fragment">$ starpu_fxt_tool -i /tmp/prof_file_something
$ starpu_codelet_profile distrib.data codelet_name
</pre><p>This will create profiling data files, and a <code>distrib.data.gp</code> file in the current directory, which draws the distribution of codelet time over the application execution, according to data input size.</p>
<div class="image">
<img src="distrib_data.png" alt="distrib_data.png"/>
</div>
 <p>This is also available in the tool <code>starpu_perfmodel_plot</code>, by passing it the fxt trace:</p>
<pre class="fragment">$ starpu_perfmodel_plot -s non_linear_memset_regression_based -i /tmp/prof_file_foo_0
</pre><p>It will produce a <code>.gp</code> file which contains both the performance model curves, and the profiling measurements.</p>
<div class="image">
<img src="starpu_non_linear_memset_regression_based_2.png" alt="starpu_non_linear_memset_regression_based_2.png"/>
</div>
 <p>If you have the statistical tool <code>R</code> installed, you can additionally use</p>
<pre class="fragment">$ starpu_codelet_histo_profile distrib.data
</pre><p>Which will create one <code>.pdf</code> file per codelet and per input size, showing a histogram of the codelet execution time distribution.</p>
<div class="image">
<img src="distrib_data_histo.png" alt="distrib_data_histo.png"/>
</div>
 <h1><a class="anchor" id="DataTrace"></a>
Data trace and tasks length</h1>
<p>It is possible to get statistics about tasks length and data size by using : </p><pre class="fragment">$ starpu_fxt_data_trace filename [codelet1 codelet2 ... codeletn]
</pre><p> Where filename is the FxT trace file and codeletX the names of the codelets you want to profile (if no names are specified, <code>starpu_fxt_data_trace</code> will profile them all). This will create a file, <code>data_trace.gp</code> which can be executed to get a <code>.eps</code> image of these results. On the image, each point represents a task, and each color corresponds to a codelet.</p>
<div class="image">
<img src="data_trace.png" alt="data_trace.png"/>
</div>
 <h1><a class="anchor" id="TraceStatistics"></a>
Trace Statistics</h1>
<p>More than just codelet performance, it is interesting to get statistics over all kinds of StarPU states (allocations, data transfers, etc.). This is particularly useful to check what may have gone wrong in the accurracy of the SimGrid simulation.</p>
<p>This requires the <code>R</code> statistical tool, with the <code>plyr</code>, <code>ggplot2</code> and <code>data.table</code> packages. If your system distribution does not have packages for these, one can fetch them from <code>CRAN</code>:</p>
<pre class="fragment">$ R
&gt; install.packages("plyr")
&gt; install.packages("ggplot2")
&gt; install.packages("data.table")
&gt; install.packages("knitr")
</pre><p>The <code>pj_dump</code> tool from <code>pajeng</code> is also needed (see <a href="https://github.com/schnorr/pajeng">https://github.com/schnorr/pajeng</a>)</p>
<p>One can then get textual or <code>.csv</code> statistics over the trace states:</p>
<pre class="fragment">$ starpu_paje_state_stats -v native.trace simgrid.trace
"Value"         "Events_native.csv" "Duration_native.csv" "Events_simgrid.csv" "Duration_simgrid.csv"
"Callback"      220                 0.075978              220                  0
"chol_model_11" 10                  565.176               10                   572.8695
"chol_model_21" 45                  9184.828              45                   9170.719
"chol_model_22" 165                 64712.07              165                  64299.203
$ starpu_paje_state_stats native.trace simgrid.trace
</pre><p>An other way to get statistics of StarPU states (without installing <code>R</code> and <code>pj_dump</code>) is to use the <code>starpu_trace_state_stats.py</code> script which parses the generated <code>trace.rec</code> file instead of the <code>paje.trace</code> file. The output is similar to the previous script but it doesn't need any dependencies.</p>
<p>The different prefixes used in <code>trace.rec</code> are:</p>
<pre class="fragment">E: Event type
N: Event name
C: Event category
W: Worker ID
T: Thread ID
S: Start time
</pre><p>Here's an example on how to use it:</p>
<pre class="fragment">$ starpu_trace_state_stats.py trace.rec | column -t -s ","
"Name"		"Count" "Type"	"Duration"
"Callback"       220	Runtime	0.075978
"chol_model_11"  10	Task	565.176
"chol_model_21"  45	Task	9184.828
"chol_model_22"  165	Task	64712.07
</pre><p><code>starpu_trace_state_stats.py</code> can also be used to compute the different efficiencies. Refer to the usage description to show some examples.</p>
<p>And one can plot histograms of execution times, of several states for instance: </p><pre class="fragment">$ starpu_paje_draw_histogram -n chol_model_11,chol_model_21,chol_model_22 native.trace simgrid.trace
</pre><p>and see the resulting pdf file:</p>
<div class="image">
<img src="paje_draw_histogram.png" alt="paje_draw_histogram.png"/>
</div>
 <p>A quick statistical report can be generated by using:</p>
<pre class="fragment">$ starpu_paje_summary native.trace simgrid.trace
</pre><p>it includes gantt charts, execution summaries, as well as state duration charts and time distribution histograms.</p>
<p>Other external Paje analysis tools can be used on these traces, one just needs to sort the traces by timestamp order (which not guaranteed to make recording more efficient):</p>
<pre class="fragment">$ starpu_paje_sort paje.trace
</pre><h1><a class="anchor" id="TheoreticalLowerBoundOnExecutionTime"></a>
Theoretical Lower Bound On Execution Time</h1>
<p>StarPU can record a trace of what tasks are needed to complete the application, and then, by using a linear system, provide a theoretical lower bound of the execution time (i.e. with an ideal scheduling).</p>
<p>The computed bound is not really correct when not taking into account dependencies, but for an application which have enough parallelism, it is very near to the bound computed with dependencies enabled (which takes a huge lot more time to compute), and thus provides a good-enough estimation of the ideal execution time.</p>
<p><a class="el" href="OfflinePerformanceTools.html#TheoreticalLowerBoundOnExecutionTimeExample">Theoretical Lower Bound On Execution Time Example</a> provides an example on how to use this.</p>
<h1><a class="anchor" id="TheoreticalLowerBoundOnExecutionTimeExample"></a>
Theoretical Lower Bound On Execution Time Example</h1>
<p>For kernels with history-based performance models (and provided that they are completely calibrated), StarPU can very easily provide a theoretical lower bound for the execution time of a whole set of tasks. See for instance <code>examples/lu/lu_example.c</code>: before submitting tasks, call the function <a class="el" href="group__API__Theoretical__Lower__Bound__on__Execution__Time.html#ga284f3571becb60b2354cc1ce121e4778">starpu_bound_start()</a>, and after complete execution, call <a class="el" href="group__API__Theoretical__Lower__Bound__on__Execution__Time.html#ga5f1859599a28105aea4c0f33fd871218">starpu_bound_stop()</a>. <a class="el" href="group__API__Theoretical__Lower__Bound__on__Execution__Time.html#ga066ce2e396d5b676af7a5209b0079610">starpu_bound_print_lp()</a> or <a class="el" href="group__API__Theoretical__Lower__Bound__on__Execution__Time.html#gad0cf05d0bb9b21964fb911cfebf252df">starpu_bound_print_mps()</a> can then be used to output a Linear Programming problem corresponding to the schedule of your tasks. Run it through <code>lp_solve</code> or any other linear programming solver, and that will give you a lower bound for the total execution time of your tasks. If StarPU was compiled with the library <code>glpk</code> installed, <a class="el" href="group__API__Theoretical__Lower__Bound__on__Execution__Time.html#ga99f073d0ad7604366ef3a8f805b5f060">starpu_bound_compute()</a> can be used to solve it immediately and get the optimized minimum, in ms. Its parameter <code>integer</code> allows to decide whether integer resolution should be computed and returned</p>
<p>The <code>deps</code> parameter tells StarPU whether to take tasks, implicit data, and tag dependencies into account. Tags released in a callback or similar are not taken into account, only tags associated with a task are. It must be understood that the linear programming problem size is quadratic with the number of tasks and thus the time to solve it will be very long, it could be minutes for just a few dozen tasks. You should probably use <code>lp_solve -timeout 1 test.pl -wmps test.mps</code> to convert the problem to MPS format and then use a better solver, <code>glpsol</code> might be better than <code>lp_solve</code> for instance (the <code>&ndash;pcost</code> option may be useful), but sometimes doesn't manage to converge. <code>cbc</code> might look slower, but it is parallel. For <code>lp_solve</code>, be sure to try at least all the <code>-B</code> options. For instance, we often just use <code>lp_solve -cc -B1 -Bb -Bg -Bp -Bf -Br -BG -Bd -Bs -BB -Bo -Bc -Bi</code> , and the <code>-gr</code> option can also be quite useful. The resulting schedule can be observed by using the tool <code>starpu_lp2paje</code>, which converts it into the Paje format.</p>
<p>Data transfer time can only be taken into account when <code>deps</code> is set. Only data transfers inferred from implicit data dependencies between tasks are taken into account. Other data transfers are assumed to be completely overlapped.</p>
<p>Setting <code>deps</code> to 0 will only take into account the actual computations on processing units. It however still properly takes into account the varying performances of kernels and processing units, which is quite more accurate than just comparing StarPU performances with the fastest of the kernels being used.</p>
<p>The <code>prio</code> parameter tells StarPU whether to simulate taking into account the priorities as the StarPU scheduler would, i.e. schedule prioritized tasks before less prioritized tasks, to check to which extend this results to a less optimal solution. This increases even more computation time.</p>
<h1><a class="anchor" id="starvz"></a>
Trace visualization with StarVZ</h1>
<p>Creating views with StarVZ (see: <a href="https://github.com/schnorr/starvz">https://github.com/schnorr/starvz</a>) is made up of two steps. The initial stage consists of a pre-processing of the traces generated by the application, while the second one consists of the analysis itself and is carried out with R packages' aid. StarVZ is available at CRAN (<a href="https://cran.r-project.org/package=starvz">https://cran.r-project.org/package=starvz</a>) and depends on pj_dump (from pajeng) and rec2csv (from recutils).</p>
<p>To download and install StarVZ, it is necessary to have R, pajeng, and recutils:</p>
<pre class="fragment"># For pj_dump and rec2csv
apt install -y pajeng recutils

# For R
apt install -y r-base libxml2-dev libssl-dev libcurl4-openssl-dev libgit2-dev libboost-dev
</pre><p>To install the StarVZ, the following command can be used:</p>
<pre class="fragment">echo "install.packages('starvz', repos = 'https://cloud.r-project.org')" | R --vanilla
</pre><p>To generate traces from an application, it is necessary to set <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_GENERATE_TRACE">STARPU_GENERATE_TRACE</a> and build StarPU with FxT. Then, StarVZ can be used on a folder with StarPU FxT traces to produce a default view:</p>
<pre class="fragment">export PATH=$(Rscript -e 'cat(system.file("tools/", package = "starvz"), sep="\n")'):$PATH

starvz /foo/path-to-fxt-files
</pre><p>An example of default view:</p>
<div class="image">
<img src="starvz_visu.png" alt="starvz_visu.png"/>
</div>
 <p>One can also use existing trace files (paje.trace, tasks.rec, data.rec, papi.rec and dag.dot) skipping the StarVZ internal call to starpu_fxt_tool with: </p><pre class="fragment">starvz --use-paje-trace /foo/path-to-trace-files
</pre><p>Alternatively, each StarVZ step can be executed separately. Step 1 can be used on a folder with: </p><pre class="fragment">starvz -1 /foo/path-to-fxt-files
</pre><p>Then the second step can be executed directly in R. StarVZ enables a set of different plots that can be configured on a .yaml file. A default file is provided (<code>default.yaml</code>); also, the options can be changed directly in R.</p>
<pre class="fragment">library(starvz)
library(dplyr)

dtrace &lt;- starvz_read("./", selective = FALSE)

# show idleness ratio
dtrace$config$st$idleness = TRUE

# show ABE bound
dtrace$config$st$abe$active = TRUE

# find the last task with dplyr
dtrace$config$st$tasks$list = dtrace$Application %&gt;% filter(End == max(End)) %&gt;% .$JobId
# show last task dependencies
dtrace$config$st$tasks$active = TRUE
dtrace$config$st$tasks$levels = 50

plot &lt;- starvz_plot(dtrace)
</pre><p>An example of visualization follows:</p>
<div class="image">
<img src="starvz_visu_r.png" alt="starvz_visu_r.png"/>
</div>
 <h1><a class="anchor" id="MemoryFeedback"></a>
Memory Feedback</h1>
<p>It is possible to enable memory statistics. To do so, you need to pass the option <a class="el" href="CompilationConfiguration.html#enable-memory-stats">--enable-memory-stats</a> when running <code>configure</code>. It is then possible to call the function <a class="el" href="group__API__Profiling.html#ga6b93e19cf6ddd63d7eaee6749a7bdcf1">starpu_data_display_memory_stats()</a> to display statistics about the current data handles registered within StarPU.</p>
<p>Moreover, statistics will be displayed at the end of the execution on data handles which have not been cleared out. This can be disabled by setting the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MEMORY_STATS">STARPU_MEMORY_STATS</a> to <code>0</code>.</p>
<p>For example, if you do not unregister data at the end of the complex example, you will get something similar to:</p>
<pre class="fragment">$ STARPU_MEMORY_STATS=0 ./examples/interface/complex
Complex[0] = 45.00 + 12.00 i
Complex[0] = 78.00 + 78.00 i
Complex[0] = 45.00 + 12.00 i
Complex[0] = 45.00 + 12.00 i
</pre><pre class="fragment">$ STARPU_MEMORY_STATS=1 ./examples/interface/complex
Complex[0] = 45.00 + 12.00 i
Complex[0] = 78.00 + 78.00 i
Complex[0] = 45.00 + 12.00 i
Complex[0] = 45.00 + 12.00 i

#---------------------
Memory stats:
#-------
Data on Node #3
#-----
Data : 0x553ff40
Size : 16

#--
Data access stats
/!\ Work Underway
Node #0
	Direct access : 4
	Loaded (Owner) : 0
	Loaded (Shared) : 0
	Invalidated (was Owner) : 0

Node #3
	Direct access : 0
	Loaded (Owner) : 0
	Loaded (Shared) : 1
	Invalidated (was Owner) : 0

#-----
Data : 0x5544710
Size : 16

#--
Data access stats
/!\ Work Underway
Node #0
	Direct access : 2
	Loaded (Owner) : 0
	Loaded (Shared) : 1
	Invalidated (was Owner) : 1

Node #3
	Direct access : 0
	Loaded (Owner) : 1
	Loaded (Shared) : 0
	Invalidated (was Owner) : 0
</pre><h1><a class="anchor" id="DataStatistics"></a>
Data Statistics</h1>
<p>Different data statistics can be displayed at the end of the execution of the application. To enable them, you need to define the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_ENABLE_STATS">STARPU_ENABLE_STATS</a>. When calling <a class="el" href="group__API__Initialization__and__Termination.html#ga48edf5e30e71fbb71923e3867ad16c0a">starpu_shutdown()</a> various statistics will be displayed, execution, MSI cache statistics, allocation cache statistics, and data transfer statistics. The display can be disabled by setting the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_STATS">STARPU_STATS</a> to <code>0</code>.</p>
<pre class="fragment">$ ./examples/cholesky/cholesky_tag
Computation took (in ms)
518.16
Synthetic GFlops : 44.21
#---------------------
MSI cache stats :
TOTAL MSI stats	hit 1622 (66.23 %)	miss 827 (33.77 %)
...
</pre><pre class="fragment">$ STARPU_STATS=0 ./examples/cholesky/cholesky_tag
Computation took (in ms)
518.16
Synthetic GFlop/s : 44.21
</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 22 2021 15:02:16 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
