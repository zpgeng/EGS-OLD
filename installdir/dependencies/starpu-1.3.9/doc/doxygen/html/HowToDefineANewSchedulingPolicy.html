<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StarPU Handbook: How To Define A New Scheduling Policy</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('HowToDefineANewSchedulingPolicy.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">How To Define A New Scheduling Policy </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="NewSchedulingPolicy_Introduction"></a>
Introduction</h1>
<p>StarPU provides two ways of defining a scheduling policy, a basic monolithic way, and a modular way.</p>
<p>The basic monolithic way is directly connected with the core of StarPU, which means that the policy then has to handle all performance details, such as data prefetching, task performance model calibration, worker locking, etc. <code>examples/scheduler/dummy_sched.c</code> is a trivial example which does not handle this, and thus e.g. does not achieve any data prefetching or smart scheduling.</p>
<p>The modular way allows to implement just one component, and reuse existing components to cope with all these details. <code>examples/scheduler/dummy_modular_sched.c</code> is a trivial example very similar to <code>dummy_sched.c</code>, but implemented as a component, which allows to assemble it with other components, and notably get data prefetching support for free, and task performance model calibration is properly performed, which allows to easily extend it into taking task duration into account, etc.</p>
<h1><a class="anchor" id="SchedulingHelpers"></a>
Helper functions for defining a scheduling policy (Basic or modular)</h1>
<p>Make sure to have a look at the <a class="el" href="group__API__Scheduling__Policy.html">Scheduling Policy</a> section, which provides a complete list of the functions available for writing advanced schedulers.</p>
<p>This includes getting an estimation for a task computation completion with <a class="el" href="group__API__Scheduling__Policy.html#ga2dc83adec9e479e967a1d1c2ae40f916">starpu_task_expected_length()</a>, for the required data transfers with <a class="el" href="group__API__Scheduling__Policy.html#ga318f5a51b8f948940c754df6962be263">starpu_task_expected_data_transfer_time_for()</a>, for the required energy with <a class="el" href="group__API__Scheduling__Policy.html#ga3e9efb4ca2cbc1c74757e0a9cb0f26c6">starpu_task_expected_energy()</a>, etc. Other useful functions include <a class="el" href="group__API__Performance__Model.html#ga767f88b087d4b0bf4086ade9bb673826">starpu_transfer_bandwidth()</a>, <a class="el" href="group__API__Performance__Model.html#ga77915973bf2f03bd70fb84ee4c9c51a0">starpu_transfer_latency()</a>, <a class="el" href="group__API__Performance__Model.html#ga9a4af8d1b5a3486a5a21c72dd4a6c4c2">starpu_transfer_predict()</a>, ... One can also directly test the presence of a data handle with <a class="el" href="group__API__Data__Management.html#ga8bcfd56807cf9436eca71c6e3ade2dab">starpu_data_is_on_node()</a>. Prefetches can be triggered by calling either <a class="el" href="group__API__Scheduling__Policy.html#ga8004f14208fd9b29f36440dc11ca765b">starpu_prefetch_task_input_for()</a>, starpu_idle_prefetch_task_input(), <a class="el" href="group__API__Scheduling__Policy.html#gae0af4ea38016734474e4b76c97cca790">starpu_prefetch_task_input_for_prio()</a>, or <a class="el" href="group__API__Scheduling__Policy.html#ga7cfeacbeb8978b05754da35133eeba87">starpu_idle_prefetch_task_input_for_prio()</a>. The <code>_prio</code> versions allow to specify a priority for the transfer (instead of taking the task priority by default). These prefetches are only processed when there are no fetch data requests (i.e. a task is waiting for it) to process. The <code>_idle</code> versions queue the transfers on the idle prefetch queue, which is only processed when there are no non-idle prefetch to process. <a class="el" href="group__API__Scheduling__Policy.html#ga94edfd4a02666d8c1b8c506423586426">starpu_get_prefetch_flag()</a> is a convenient helper for checking the value of the <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_PREFETCH">STARPU_PREFETCH</a> environment variable.</p>
<p>Usual functions can be used on tasks, for instance one can use the following to get the data size for a task.</p>
<div class="fragment"><div class="line">size = 0;</div><div class="line">write = 0;</div><div class="line"><span class="keywordflow">if</span> (task-&gt;cl)</div><div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="group__API__Codelet__And__Tasks.html#ga829d31913f4b0890192d4924bd264f88">STARPU_TASK_GET_NBUFFERS</a>(task); i++)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> data = <a class="code" href="group__API__Codelet__And__Tasks.html#ga260a1f7f8bef6b255dd0e0e45481385e">STARPU_TASK_GET_HANDLE</a>(task, i)</div><div class="line">        <span class="keywordtype">size_t</span> datasize = <a class="code" href="group__API__Data__Interfaces.html#gac14cfc52c450c81dd4789a7aace79d3b">starpu_data_get_size</a>(data);</div><div class="line">        size += datasize;</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__API__Codelet__And__Tasks.html#ga649920660819ed7d9922e896e63acd95">STARPU_TASK_GET_MODE</a>(task, i) &amp; <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba628e5483f4cb6e44779aea39300dafed">STARPU_W</a>)</div><div class="line">            write += datasize;</div><div class="line">    }</div></div><!-- fragment --><p>Task queues can be implemented with the <a class="el" href="group__API__Task__Lists.html#structstarpu__task__list">starpu_task_list</a> functions.</p>
<p>Access to the <code>hwloc</code> topology is available with <a class="el" href="group__API__Workers__Properties.html#ga389142e108345483dc8c0bf07465263c">starpu_worker_get_hwloc_obj()</a>.</p>
<h1><a class="anchor" id="DefiningANewBasicSchedulingPolicy"></a>
Defining A New Basic Scheduling Policy</h1>
<p>A full example showing how to define a new scheduling policy is available in the StarPU sources in <code>examples/scheduler/dummy_sched.c</code>.</p>
<p>The scheduler has to provide methods:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="group__API__Scheduling__Policy.html#structstarpu__sched__policy">starpu_sched_policy</a> dummy_sched_policy =</div><div class="line">{</div><div class="line">    .<a class="code" href="group__API__Scheduling__Policy.html#ace93b3c465e39c7e2ca894406905dc2a">init_sched</a> = init_dummy_sched,</div><div class="line">    .deinit_sched = deinit_dummy_sched,</div><div class="line">    .add_workers = dummy_sched_add_workers,</div><div class="line">    .remove_workers = dummy_sched_remove_workers,</div><div class="line">    .push_task = push_task_dummy,</div><div class="line">    .pop_task = pop_task_dummy,</div><div class="line">    .policy_name = <span class="stringliteral">&quot;dummy&quot;</span>,</div><div class="line">    .policy_description = <span class="stringliteral">&quot;dummy scheduling strategy&quot;</span></div><div class="line">};</div></div><!-- fragment --><p>The idea is that when a task becomes ready for execution, the <a class="el" href="group__API__Scheduling__Policy.html#a73c1677d2c6af4d4aa44f6f92de8bcdd">starpu_sched_policy::push_task</a> method is called to give the ready task to the scheduler. When a worker is idle, the <a class="el" href="group__API__Scheduling__Policy.html#a6968fc3f435de8e2eba01f4fec9a3dba">starpu_sched_policy::pop_task</a> method is called to get a task from the scheduler. It is up to the scheduler to implement what is between. A simple eager scheduler is for instance to make <a class="el" href="group__API__Scheduling__Policy.html#a73c1677d2c6af4d4aa44f6f92de8bcdd">starpu_sched_policy::push_task</a> push the task to a global list, and make <a class="el" href="group__API__Scheduling__Policy.html#a6968fc3f435de8e2eba01f4fec9a3dba">starpu_sched_policy::pop_task</a> pop from this list. A scheduler can also use <a class="el" href="group__API__Scheduling__Policy.html#gae0b8a9bb53822f3d92cb2d19c2520e5e">starpu_push_local_task()</a> to directly push tasks to a per-worker queue, and then starpu does not even need to implement <a class="el" href="group__API__Scheduling__Policy.html#a6968fc3f435de8e2eba01f4fec9a3dba">starpu_sched_policy::pop_task</a>. If there are no ready tasks within the scheduler, it can just return <code>NULL</code>, and the worker will sleep.</p>
<p>The <a class="el" href="group__API__Scheduling__Policy.html#structstarpu__sched__policy">starpu_sched_policy</a> section provides the exact rules that govern the methods of the policy.</p>
<p>One can enumerate the workers with this iterator:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Workers__Properties.html#structstarpu__worker__collection">starpu_worker_collection</a> *workers = <a class="code" href="group__API__Scheduling__Contexts.html#ga981d565cbe680e8acc6d14d6557b6981">starpu_sched_ctx_get_worker_collection</a>(sched_ctx_id);</div><div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Workers__Properties.html#structstarpu__sched__ctx__iterator">starpu_sched_ctx_iterator</a> it;</div><div class="line"></div><div class="line">workers-&gt;<a class="code" href="group__API__Workers__Properties.html#ae260b3aeb9f58a98d7adb70eea8b851c">init_iterator</a>(workers, &amp;it);</div><div class="line"><span class="keywordflow">while</span>(workers-&gt;<a class="code" href="group__API__Workers__Properties.html#a6595f14b6715e60d2444f4cd09b9d73f">has_next</a>(workers, &amp;it))</div><div class="line">{</div><div class="line">        <span class="keywordtype">unsigned</span> worker = workers-&gt;<a class="code" href="group__API__Workers__Properties.html#ab92e3de048f56a4c2f59fa804594c339">get_next</a>(workers, &amp;it);</div><div class="line">        ...</div><div class="line">}</div></div><!-- fragment --><p>To provide synchronization between workers, a per-worker lock exists to protect the data structures of a given worker. It is acquired around scheduler methods, so that the scheduler does not need any additional mutex to protect its per-worker data.</p>
<p>In case the scheduler wants to access another scheduler's data, it should use <a class="el" href="group__API__Workers__Properties.html#ga1056809a8cd464002ed4cad02cec33e4">starpu_worker_lock()</a> and <a class="el" href="group__API__Workers__Properties.html#ga38c0b1858730fec2211991147a964910">starpu_worker_unlock()</a>.</p>
<p>Calling</p><div class="fragment"><div class="line"><a class="code" href="group__API__Workers__Properties.html#ga1056809a8cd464002ed4cad02cec33e4">starpu_worker_lock</a>(B)</div></div><!-- fragment --><p> from a worker <code>A</code> will however thus make worker <code>A</code> wait for worker <code>B</code> to complete its scheduling method. That may be a problem if that method takes a long time, because it is e.g. computing a heuristic or waiting for another mutex, or even cause deadlocks if worker <code>B</code> is calling</p><div class="fragment"><div class="line"><a class="code" href="group__API__Workers__Properties.html#ga1056809a8cd464002ed4cad02cec33e4">starpu_worker_lock</a>(A)</div></div><!-- fragment --><p> at the same time. In such a case, worker <code>B</code> must call <a class="el" href="group__API__Workers__Properties.html#gad3f993a7ab14f16e51406a7da3c634f2">starpu_worker_relax_on()</a> and <a class="el" href="group__API__Workers__Properties.html#gab568e2368c11f9fb362f04264ad4cd04">starpu_worker_relax_off()</a> around the section which potentially blocks (and does not actually need protection). While a worker is in relaxed mode, e.g. between a pair of <a class="el" href="group__API__Workers__Properties.html#gad3f993a7ab14f16e51406a7da3c634f2">starpu_worker_relax_on()</a> and <a class="el" href="group__API__Workers__Properties.html#gab568e2368c11f9fb362f04264ad4cd04">starpu_worker_relax_off()</a> calls, its state can be altered by other threads: for instance, worker <code>A</code> can push tasks for worker <code>B</code>. In consequence, worker <code>B</code> must re-assess its state after</p><div class="fragment"><div class="line"><a class="code" href="group__API__Workers__Properties.html#gab568e2368c11f9fb362f04264ad4cd04">starpu_worker_relax_off</a>(B)</div></div><!-- fragment --><p>, such as taking possible new tasks pushed to its queue into account.</p>
<p>When the <a class="el" href="group__API__Scheduling__Policy.html#a73c1677d2c6af4d4aa44f6f92de8bcdd">starpu_sched_policy::push_task</a> method has pushed a task for another worker, one has to call <a class="el" href="group__API__Scheduling__Policy.html#ga8e58ffd062043cf25b47c081b7f6ba88">starpu_wake_worker_relax_light()</a> so that the worker wakes up and picks it. If the task was pushed on a shared queue, one may want to only wake one idle worker. An example doing this is available in <code>src/sched_policies/eager_central_policy.c</code>.</p>
<p>A pointer to one data structure specific to the scheduler can be set with <a class="el" href="group__API__Scheduling__Contexts.html#ga20077926e6cd8264bcbb831a394c381a">starpu_sched_ctx_set_policy_data()</a> and fetched with <a class="el" href="group__API__Scheduling__Contexts.html#ga56f7bc845b8c8bac788962a7d627ae72">starpu_sched_ctx_get_policy_data()</a>. Per-worker data structures can then be store in it by allocating a <a class="el" href="group__API__Workers__Properties.html#gad7c443d1341e4976d63fb5d77e74bf09">STARPU_NMAXWORKERS</a> -sized array of structures indexed by workers.</p>
<p>A variety of examples of advanced schedulers can be read in <code>src/sched_policies</code>, for instance <code>random_policy.c</code>, <code>eager_central_policy.c</code>, <code>work_stealing_policy.c</code> Code protected by <code>if (_starpu_get_nsched_ctxs() &gt; 1)</code> can be ignored, this is for scheduling contexts, which is an experimental feature.</p>
<h1><a class="anchor" id="DefiningANewModularSchedulingPolicy"></a>
Defining A New Modular Scheduling Policy</h1>
<p>StarPU's Modularized Schedulers are made of individual Scheduling Components Modularizedly assembled as a Scheduling Tree. Each Scheduling Component has an unique purpose, such as prioritizing tasks or mapping tasks over resources. A typical Scheduling Tree is shown below.</p>
<pre>
                                 |
             starpu_push_task    |
                                 |
                                 v
                           Fifo_Component
                                |  ^
                        Push    |  |    Can_Push
                                v  |
                          Eager_Component
                                |  ^
                                |  |
                                v  |
              --------&gt;&lt;-------------------&gt;&lt;---------
              |  ^                                |  ^
      Push    |  |    Can_Push            Push    |  |    Can_Push
              v  |                                v  |
         Fifo_Component                       Fifo_Component
              |  ^                                |  ^
      Pull    |  |    Can_Pull            Pull    |  |    Can_Pull
              v  |                                v  |
        Worker_Component                     Worker_Component
                  |                             |
starpu_pop_task   |                             |
                  v                             v
</pre><p>When a task is pushed by StarPU in a Modularized Scheduler, the task moves from a Scheduling Component to an other, following the hierarchy of the Scheduling Tree, and is stored in one of the Scheduling Components of the strategy. When a worker wants to pop a task from the Modularized Scheduler, the corresponding Worker Component of the Scheduling Tree tries to pull a task from its parents, following the hierarchy, and gives it to the worker if it succeded to get one.</p>
<h2><a class="anchor" id="Interface"></a>
Interface</h2>
<p>Each Scheduling Component must follow the following pre-defined Interface to be able to interact with other Scheduling Components.</p>
<ul>
<li>push_task (child_component, Task) <br />
 The calling Scheduling Component transfers a task to its Child Component. When the Push function returns, the task no longer belongs to the calling Component. The Modularized Schedulers' model relies on this function to perform prefetching. See <a class="el" href="group__API__Modularized__Scheduler.html#aa989aab198005eff62cd799b02ded7cb">starpu_sched_component::push_task</a> for more details</li>
<li>pull_task (parent_component, caller_component) -&gt; Task <br />
 The calling Scheduling Component requests a task from its Parent Component. When the Pull function ends, the returned task belongs to the calling Component. See <a class="el" href="group__API__Modularized__Scheduler.html#a4942440fbea849c93e75867651267201">starpu_sched_component::pull_task</a> for more details</li>
<li>can_push (caller_component, parent_component) <br />
 The calling Scheduling Component notifies its Parent Component that it is ready to accept new tasks. See <a class="el" href="group__API__Modularized__Scheduler.html#abf315d3c1f60fbcab6a001f7925dc4fa">starpu_sched_component::can_push</a> for more details</li>
<li>can_pull (caller_component, child_component) <br />
 The calling Scheduling Component notifies its Child Component that it is ready to give new tasks. See <a class="el" href="group__API__Modularized__Scheduler.html#a4c7d5c03e2acf93fa737540b35eb1001">starpu_sched_component::can_pull</a> for more details</li>
</ul>
<p>The components also provide the following useful methods:</p>
<ul>
<li><a class="el" href="group__API__Modularized__Scheduler.html#a86ea24c3238c3424b622496cbbd0bbd1">starpu_sched_component::estimated_load</a> provides an estimated load of the component</li>
<li><a class="el" href="group__API__Modularized__Scheduler.html#a78d7ba588cf0d03007db07afc3d38bc3">starpu_sched_component::estimated_end</a> provides an estimated date of availability of workers behind the component, after processing tasks in the component and below. This is computed only if the estimated field of the tasks have been set before passing it to the component.</li>
</ul>
<h2><a class="anchor" id="BuildAModularizedScheduler"></a>
Building a Modularized Scheduler</h2>
<h3><a class="anchor" id="PreImplementedComponents"></a>
Pre-implemented Components</h3>
<p>StarPU is currently shipped with the following four Scheduling Components :</p>
<ul>
<li>Storage Components : Fifo, Prio <br />
 Components which store tasks. They can also prioritize them if they have a defined priority. It is possible to define a threshold for those Components following two criterias : the number of tasks stored in the Component, or the sum of the expected length of all tasks stored in the Component. When a push operation tries to queue a task beyond the threshold, the push fails. When some task leaves the queue (and thus possibly more tasks can fit), this component calls can_push from ancestors.</li>
<li>Resource-Mapping Components : Mct, Heft, Eager, Random, Work-Stealing <br />
 "Core" of the Scheduling Strategy, those Components are the ones who make scheduling choices between their children components.</li>
<li>Worker Components : Worker <br />
 Each Worker Component modelizes a concrete worker, and copes with the technical tricks of interacting with the StarPU core. Modular schedulers thus usually have them at the bottom of their component tree.</li>
<li>Special-Purpose Components : Perfmodel_Select, Best_Implementation <br />
 Components dedicated to original purposes. The Perfmodel_Select Component decides which Resource-Mapping Component should be used to schedule a task: a component that assumes tasks with a calibrated performance model; a component for non-yet-calibrated tasks, that will distribute them to get measurements done as quickly as possible; and a component that takes the tasks without performance models.<br />
 The Best_Implementation Component chooses which implementation of a task should be used on the chosen resource.</li>
</ul>
<h3><a class="anchor" id="ProgressionAndValidationRules"></a>
Progression And Validation Rules</h3>
<p>Some rules must be followed to ensure the correctness of a Modularized Scheduler :</p>
<ul>
<li>At least one Storage Component without threshold is needed in a Modularized Scheduler, to store incoming tasks from StarPU. It can for instance be a global component at the top of the tree, or one component per worker at the bottom of the tree, or intermediate assemblies. The important point is that the <a class="el" href="group__API__Modularized__Scheduler.html#aa989aab198005eff62cd799b02ded7cb">starpu_sched_component::push_task</a> call at the top can not fail, so there has to be a storage component without threshold between the top of the tree and the first storage component with threshold, or the workers themselves.</li>
<li>At least one Resource-Mapping Component is needed in a Modularized Scheduler. Resource-Mapping Components are the only ones which can make scheduling choices, and so the only ones which can have several child.</li>
</ul>
<h3><a class="anchor" id="ModularizedSchedulerLocking"></a>
Locking in modularized schedulers</h3>
<p>Most often, components do not need to take locks. This allows e.g. the push operation to be called in parallel when tasks get released in parallel from different workers which have completed different ancestor tasks.</p>
<p>When a component has internal information which needs to be kept coherent, the component can define its own lock at take it as it sees fit, e.g. to protect a task queue. This may however limit scalability of the scheduler. Conversely, since push and pull operations will be called concurrently from different workers, the component might prefer to use a central mutex to serialize all scheduling decisions to avoid pathological cases (all push calls decide to put their task on the same target)</p>
<h3><a class="anchor" id="ImplementAModularizedScheduler"></a>
Implementing a Modularized Scheduler</h3>
<p>The following code shows how to implement a Tree-Eager-Prefetching Scheduler.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> initialize_eager_prefetching_center_policy(<span class="keywordtype">unsigned</span> sched_ctx_id)</div><div class="line">{</div><div class="line">  <span class="comment">/* The eager component will decide for each task which worker will run it,</span></div><div class="line"><span class="comment">   * and we want fifos both above and below the component */</span></div><div class="line">  <a class="code" href="group__API__Modularized__Scheduler.html#ga502c075e94e2988007333d8f0f80b69c">starpu_sched_component_initialize_simple_scheduler</a>(</div><div class="line">    starpu_sched_component_eager_create, NULL,</div><div class="line">    <a class="code" href="group__API__Modularized__Scheduler.html#ga7bacda898bdd7964b21ce611c7db077b">STARPU_SCHED_SIMPLE_DECIDE_WORKERS</a> |</div><div class="line">    <a class="code" href="group__API__Modularized__Scheduler.html#gae1aa931285a2b952473fc7def121c5cd">STARPU_SCHED_SIMPLE_FIFO_ABOVE</a> |</div><div class="line">    <a class="code" href="group__API__Modularized__Scheduler.html#ga966aaa040948551bede3ee46c9f8847e">STARPU_SCHED_SIMPLE_FIFOS_BELOW</a>,</div><div class="line">    sched_ctx_id);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Properly destroy the Scheduling Tree and all its Components */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> deinitialize_eager_prefetching_center_policy(<span class="keywordtype">unsigned</span> sched_ctx_id)</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span><a class="code" href="group__API__Modularized__Scheduler.html#structstarpu__sched__tree">starpu_sched_tree</a> * tree = (<span class="keyword">struct </span><a class="code" href="group__API__Modularized__Scheduler.html#structstarpu__sched__tree">starpu_sched_tree</a>*)<a class="code" href="group__API__Scheduling__Contexts.html#ga56f7bc845b8c8bac788962a7d627ae72">starpu_sched_ctx_get_policy_data</a>(sched_ctx_id);</div><div class="line">  <a class="code" href="group__API__Modularized__Scheduler.html#gab8540c0e69c3af17c424944af9b3c802">starpu_sched_tree_destroy</a>(tree);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Initializing the starpu_sched_policy struct associated to the Modularized</span></div><div class="line"><span class="comment"> * Scheduler : only the init_sched and deinit_sched needs to be defined to</span></div><div class="line"><span class="comment"> * implement a Modularized Scheduler */</span></div><div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Scheduling__Policy.html#structstarpu__sched__policy">starpu_sched_policy</a> _starpu_sched_tree_eager_prefetching_policy =</div><div class="line">{</div><div class="line">  .<a class="code" href="group__API__Scheduling__Policy.html#ace93b3c465e39c7e2ca894406905dc2a">init_sched</a> = initialize_eager_prefetching_center_policy,</div><div class="line">  .deinit_sched = deinitialize_eager_prefetching_center_policy,</div><div class="line">  .add_workers = <a class="code" href="group__API__Modularized__Scheduler.html#ga7ceaaeea8cc10f6d67706c4ee33e93ce">starpu_sched_tree_add_workers</a>,</div><div class="line">  .remove_workers = <a class="code" href="group__API__Modularized__Scheduler.html#ga30b0cd3f3d64be88a163a31148c58f1f">starpu_sched_tree_remove_workers</a>,</div><div class="line">  .push_task = <a class="code" href="group__API__Modularized__Scheduler.html#ga511a8c5bc261cae8153cdfe7670a21a4">starpu_sched_tree_push_task</a>,</div><div class="line">  .pop_task = <a class="code" href="group__API__Modularized__Scheduler.html#ga15ba11364e7a5859cb9b602bcc02df24">starpu_sched_tree_pop_task</a>,</div><div class="line">  .pre_exec_hook = <a class="code" href="group__API__Modularized__Scheduler.html#gafb683e254b5084a1321a21fde5139b01">starpu_sched_component_worker_pre_exec_hook</a>,</div><div class="line">  .post_exec_hook = <a class="code" href="group__API__Modularized__Scheduler.html#gad06fa143512ae761c452bf0adf685bae">starpu_sched_component_worker_post_exec_hook</a>,</div><div class="line">  .pop_every_task = NULL,</div><div class="line">  .policy_name = <span class="stringliteral">&quot;tree-eager-prefetching&quot;</span>,</div><div class="line">  .policy_description = <span class="stringliteral">&quot;eager with prefetching tree policy&quot;</span></div><div class="line">};</div></div><!-- fragment --><p><a class="el" href="group__API__Modularized__Scheduler.html#ga502c075e94e2988007333d8f0f80b69c">starpu_sched_component_initialize_simple_scheduler()</a> is a helper function which makes it very trivial to assemble a modular scheduler around a scheduling decision component as seen above (here, a dumb eager decision component). Most often a modular scheduler can be implemented that way.</p>
<p>A modular scheduler can also be constructed hierarchically with <a class="el" href="group__API__Modularized__Scheduler.html#gaaa01c953acbd0ec34344c789fb01d18b">starpu_sched_component_composed_recipe_create()</a>.</p>
<p>That modular scheduler can also be built by hand in the following way:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define _STARPU_SCHED_NTASKS_THRESHOLD_DEFAULT 2</span></div><div class="line"><span class="preprocessor">#define _STARPU_SCHED_EXP_LEN_THRESHOLD_DEFAULT 1000000000.0</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> initialize_eager_prefetching_center_policy(<span class="keywordtype">unsigned</span> sched_ctx_id)</div><div class="line">{</div><div class="line">  <span class="keywordtype">unsigned</span> ntasks_threshold = _STARPU_SCHED_NTASKS_THRESHOLD_DEFAULT;</div><div class="line">  <span class="keywordtype">double</span> exp_len_threshold = _STARPU_SCHED_EXP_LEN_THRESHOLD_DEFAULT;</div><div class="line"></div><div class="line">  [...]</div><div class="line"></div><div class="line">  <a class="code" href="group__API__Scheduling__Contexts.html#ga2170f8f5376aa2812558321097ab269d">starpu_sched_ctx_create_worker_collection</a></div><div class="line">    (sched_ctx_id, <a class="code" href="group__API__Workers__Properties.html#gga80b06886ee8a4c0e99b09ab638113af3a574a8ee7f0fc8414cd16767c88481d26">STARPU_WORKER_LIST</a>);</div><div class="line"></div><div class="line">  <span class="comment">/* Create the Scheduling Tree */</span></div><div class="line">  <span class="keyword">struct </span><a class="code" href="group__API__Modularized__Scheduler.html#structstarpu__sched__tree">starpu_sched_tree</a> * t = <a class="code" href="group__API__Modularized__Scheduler.html#gaf2c80ef8ccc38d6d2bb69ba3c5299c25">starpu_sched_tree_create</a>(sched_ctx_id);</div><div class="line"></div><div class="line">  <span class="comment">/* The Root Component is a Flow-control Fifo Component */</span></div><div class="line">   t-&gt;<a class="code" href="group__API__Modularized__Scheduler.html#a5b27ab8642148517e8addec4863c2042">root</a> = <a class="code" href="group__API__Modularized__Scheduler.html#ga176f9ece9ff36f0b4f7474c0ee7539a9">starpu_sched_component_fifo_create</a>(NULL);</div><div class="line"></div><div class="line">  <span class="comment">/* The Resource-mapping Component of the strategy is an Eager Component</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">struct </span><a class="code" href="group__API__Modularized__Scheduler.html#structstarpu__sched__component">starpu_sched_component</a> *eager_component = starpu_sched_component_eager_create(NULL);</div><div class="line"></div><div class="line">  <span class="comment">/* Create links between Components : the Eager Component is the child</span></div><div class="line"><span class="comment">   * of the Root Component */</span></div><div class="line">  <a class="code" href="group__API__Modularized__Scheduler.html#ga90dfe435a72d46bd23ddaffa287833c2">starpu_sched_component_connect</a>(t-&gt;<a class="code" href="group__API__Modularized__Scheduler.html#a5b27ab8642148517e8addec4863c2042">root</a>, eager_component);</div><div class="line"></div><div class="line">  <span class="comment">/* A task threshold is set for the Flow-control Components which will</span></div><div class="line"><span class="comment">   * be connected to Worker Components. By doing so, this Modularized</span></div><div class="line"><span class="comment">   * Scheduler will be able to perform some prefetching on the resources</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">struct </span><a class="code" href="group__API__Modularized__Scheduler.html#structstarpu__sched__component__fifo__data">starpu_sched_component_fifo_data</a> fifo_data =</div><div class="line">  {</div><div class="line">    .ntasks_threshold = ntasks_threshold,</div><div class="line">    .exp_len_threshold = exp_len_threshold,</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> i;</div><div class="line">  <span class="keywordflow">for</span>(i = 0; i &lt; <a class="code" href="group__API__Workers__Properties.html#ga6312aa4b12ce7e06fe391bcafda6796a">starpu_worker_get_count</a>() + <a class="code" href="group__API__Parallel__Tasks.html#ga49a6732f413550652450baa64594bc5e">starpu_combined_worker_get_count</a>(); i++)</div><div class="line">  {</div><div class="line">    <span class="comment">/* Each Worker Component has a Flow-control Fifo Component as</span></div><div class="line"><span class="comment">     * father */</span></div><div class="line">    <span class="keyword">struct </span><a class="code" href="group__API__Modularized__Scheduler.html#structstarpu__sched__component">starpu_sched_component</a> * worker_component = starpu_sched_component_worker_new(i);</div><div class="line">    <span class="keyword">struct </span><a class="code" href="group__API__Modularized__Scheduler.html#structstarpu__sched__component">starpu_sched_component</a> * fifo_component = <a class="code" href="group__API__Modularized__Scheduler.html#ga176f9ece9ff36f0b4f7474c0ee7539a9">starpu_sched_component_fifo_create</a>(&amp;fifo_data);</div><div class="line">    <a class="code" href="group__API__Modularized__Scheduler.html#ga90dfe435a72d46bd23ddaffa287833c2">starpu_sched_component_connect</a>(fifo_component, worker_component);</div><div class="line"></div><div class="line">    <span class="comment">/* Each Flow-control Fifo Component associated to a Worker</span></div><div class="line"><span class="comment">     * Component is linked to the Eager Component as one of its</span></div><div class="line"><span class="comment">     * children */</span></div><div class="line">    <a class="code" href="group__API__Modularized__Scheduler.html#ga90dfe435a72d46bd23ddaffa287833c2">starpu_sched_component_connect</a>(eager_component, fifo_component);</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="group__API__Modularized__Scheduler.html#ga61c2f443fb8d5b6a2a1404eae0e7868e">starpu_sched_tree_update_workers</a>(t);</div><div class="line">  <a class="code" href="group__API__Scheduling__Contexts.html#ga20077926e6cd8264bcbb831a394c381a">starpu_sched_ctx_set_policy_data</a>(sched_ctx_id, (<span class="keywordtype">void</span>*)t);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Properly destroy the Scheduling Tree and all its Components */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> deinitialize_eager_prefetching_center_policy(<span class="keywordtype">unsigned</span> sched_ctx_id)</div><div class="line">{</div><div class="line">  <span class="keyword">struct </span><a class="code" href="group__API__Modularized__Scheduler.html#structstarpu__sched__tree">starpu_sched_tree</a> * tree = (<span class="keyword">struct </span><a class="code" href="group__API__Modularized__Scheduler.html#structstarpu__sched__tree">starpu_sched_tree</a>*)<a class="code" href="group__API__Scheduling__Contexts.html#ga56f7bc845b8c8bac788962a7d627ae72">starpu_sched_ctx_get_policy_data</a>(sched_ctx_id);</div><div class="line">  <a class="code" href="group__API__Modularized__Scheduler.html#gab8540c0e69c3af17c424944af9b3c802">starpu_sched_tree_destroy</a>(tree);</div><div class="line">  <a class="code" href="group__API__Scheduling__Contexts.html#ga5de2e1e6295cf1fa5723d1164d0a76e6">starpu_sched_ctx_delete_worker_collection</a>(sched_ctx_id);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Initializing the starpu_sched_policy struct associated to the Modularized</span></div><div class="line"><span class="comment"> * Scheduler : only the init_sched and deinit_sched needs to be defined to</span></div><div class="line"><span class="comment"> * implement a Modularized Scheduler */</span></div><div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Scheduling__Policy.html#structstarpu__sched__policy">starpu_sched_policy</a> _starpu_sched_tree_eager_prefetching_policy =</div><div class="line">{</div><div class="line">  .<a class="code" href="group__API__Scheduling__Policy.html#ace93b3c465e39c7e2ca894406905dc2a">init_sched</a> = initialize_eager_prefetching_center_policy,</div><div class="line">  .deinit_sched = deinitialize_eager_prefetching_center_policy,</div><div class="line">  .add_workers = <a class="code" href="group__API__Modularized__Scheduler.html#ga7ceaaeea8cc10f6d67706c4ee33e93ce">starpu_sched_tree_add_workers</a>,</div><div class="line">  .remove_workers = <a class="code" href="group__API__Modularized__Scheduler.html#ga30b0cd3f3d64be88a163a31148c58f1f">starpu_sched_tree_remove_workers</a>,</div><div class="line">  .push_task = <a class="code" href="group__API__Modularized__Scheduler.html#ga511a8c5bc261cae8153cdfe7670a21a4">starpu_sched_tree_push_task</a>,</div><div class="line">  .pop_task = <a class="code" href="group__API__Modularized__Scheduler.html#ga15ba11364e7a5859cb9b602bcc02df24">starpu_sched_tree_pop_task</a>,</div><div class="line">  .pre_exec_hook = <a class="code" href="group__API__Modularized__Scheduler.html#gafb683e254b5084a1321a21fde5139b01">starpu_sched_component_worker_pre_exec_hook</a>,</div><div class="line">  .post_exec_hook = <a class="code" href="group__API__Modularized__Scheduler.html#gad06fa143512ae761c452bf0adf685bae">starpu_sched_component_worker_post_exec_hook</a>,</div><div class="line">  .pop_every_task = NULL,</div><div class="line">  .policy_name = <span class="stringliteral">&quot;tree-eager-prefetching&quot;</span>,</div><div class="line">  .policy_description = <span class="stringliteral">&quot;eager with prefetching tree policy&quot;</span></div><div class="line">};</div></div><!-- fragment --><p>Other modular scheduler examples can be seen in <code>src/sched_policies/modular_*.c</code></p>
<p>For instance, <code>modular-heft-prio</code> needs performance models, decides memory nodes, uses prioritized fifos above and below, and decides the best implementation.</p>
<p>If unsure on the result of the modular scheduler construction, you can run a simple application with FxT enabled (see <a class="el" href="OfflinePerformanceTools.html#GeneratingTracesWithFxT">Generating Traces With FxT</a>), and open the generated file <code>trace.html</code> in a web-browser.</p>
<h2><a class="anchor" id="ModularizedSchedulersAndParallelTasks"></a>
Management of parallel task</h2>
<p>At the moment, parallel tasks can be managed in modularized schedulers through combined workers: instead of connecting a scheduling component to a worker component, one can connect it to a combined worker component (i.e. a worker component created with a combined worker id). That component will handle creating task aliases for parallel execution and push them to the different workers components.</p>
<h2><a class="anchor" id="WriteASchedulingComponent"></a>
Writing a Scheduling Component</h2>
<h3><a class="anchor" id="GenericSchedulingComponent"></a>
Generic Scheduling Component</h3>
<p>Each Scheduling Component is instantiated from a Generic Scheduling Component, which implements a generic version of the Interface. The generic implementation of Pull, Can_Pull and Can_Push functions are recursive calls to their parents (respectively to their children). However, as a Generic Scheduling Component do not know how much children it will have when it will be instantiated, it does not implement the Push function.</p>
<h3><a class="anchor" id="InstantiationRedefineInterface"></a>
Instantiation : Redefining the Interface</h3>
<p>A Scheduling Component must implement all the functions of the Interface. It is so necessary to implement a Push function to instantiate a Scheduling Component. The implemented Push function is the "fingerprint" of a Scheduling Component. Depending on how functionalities or properties programmers want to give to the Scheduling Component they are implementing, it is possible to reimplement all the functions of the Interface. For example, a Flow-control Component reimplements the Pull and the Can_Push functions of the Interface, allowing to catch the generic recursive calls of these functions. The Pull function of a Flow-control Component can, for example, pop a task from the local storage queue of the Component, and give it to the calling Component which asks for it.</p>
<h3><a class="anchor" id="DetailedProgressionAndValidationRules"></a>
Detailed Progression and Validation Rules</h3>
<ul>
<li>A Reservoir is a Scheduling Component which redefines a Push and a Pull function, in order to store tasks into it. A Reservoir delimit Scheduling Areas in the Scheduling Tree.</li>
<li>A Pump is the engine source of the Scheduler : it pushes/pulls tasks to/from a Scheduling Component to an other. Native Pumps of a Scheduling Tree are located at the root of the Tree (incoming Push calls from StarPU), and at the leafs of the Tree (Pop calls coming from StarPU Workers). Pre-implemented Scheduling Components currently shipped with Pumps are Flow-Control Components and the Resource-Mapping Component Heft, within their defined Can_Push functions.</li>
<li>A correct Scheduling Tree requires a Pump per Scheduling Area and per Execution Flow.</li>
</ul>
<p>The Tree-Eager-Prefetching Scheduler shown in Section <a class="el" href="HowToDefineANewSchedulingPolicy.html#ImplementAModularizedScheduler">Implementing a Modularized Scheduler</a> follows the previous assumptions :</p>
<pre>
                                  starpu_push_task
                                       <b>Pump</b>
                                         |
 Area 1                                  |
                                         |
                                         v
            -----------------------Fifo_Component-----------------------------
                                       <b>Pump</b>
                                        |  ^
                                Push    |  |    Can_Push
                                        v  |
 Area 2                           Eager_Component
                                        |  ^
                                        |  |
                                        v  |
                      --------&gt;&lt;-------------------&gt;&lt;---------
                      |  ^                                |  ^
              Push    |  |    Can_Push            Push    |  |    Can_Push
                      v  |                                v  |
            -----Fifo_Component-----------------------Fifo_Component----------
                      |  ^                                |  ^
              Pull    |  |    Can_Pull            Pull    |  |    Can_Pull
 Area 3               v  |                                v  |
                     <b>Pump</b>                               <b>Pump</b>
                Worker_Component                     Worker_Component
</pre><h1><a class="anchor" id="GraphScheduling"></a>
Graph-based Scheduling</h1>
<p>For performance reasons, most of the schedulers shipped with StarPU use simple list-scheduling heuristics, assuming that the application has already set priorities. This is why they do their scheduling between when tasks become available for execution and when a worker becomes idle, without looking at the task graph.</p>
<p>Other heuristics can however look at the task graph. Recording the task graph is expensive, so it is not available by default, the scheduling heuristic has to set <code>_starpu_graph_record</code> to <code>1</code> from the initialization function, to make it available. Then the <code>_starpu_graph*</code> functions can be used.</p>
<p><code>src/sched_policies/graph_test_policy.c</code> is an example of simple greedy policy which automatically computes priorities by bottom-up rank.</p>
<p>The idea is that while the application submits tasks, they are only pushed to a bag of tasks. When the application is finished with submitting tasks, it calls starpu_do_schedule() (or <a class="el" href="group__API__Codelet__And__Tasks.html#gad0baa8dbfd13e5a7bc3651bcd76022aa">starpu_task_wait_for_all()</a>, which calls starpu_do_schedule()), and the <a class="el" href="group__API__Scheduling__Policy.html#ad720f2cd2155e8baa10f57792b68a5eb">starpu_sched_policy::do_schedule</a> method of the scheduler is called. This method calls <code>_starpu_graph_compute_depths()</code> to compute the bottom-up ranks, and then uses these ranks to set priorities over tasks.</p>
<p>It then has two priority queues, one for CPUs, and one for GPUs, and uses a dumb heuristic based on the duration of the task over CPUs and GPUs to decide between the two queues. CPU workers can then pop from the CPU priority queue, and GPU workers from the GPU priority queue.</p>
<h1><a class="anchor" id="DebuggingScheduling"></a>
Debugging Scheduling</h1>
<p>All the <a class="el" href="OnlinePerformanceTools.html">Online Performance Tools</a> and <a class="el" href="OfflinePerformanceTools.html">Offline Performance Tools</a> can be used to get information about how well the execution proceeded, and thus the overall quality of the execution.</p>
<p>Precise debugging can also be performed by using the <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_TASK_BREAK_ON_PUSH">STARPU_TASK_BREAK_ON_PUSH</a>, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_TASK_BREAK_ON_SCHED">STARPU_TASK_BREAK_ON_SCHED</a>, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_TASK_BREAK_ON_POP">STARPU_TASK_BREAK_ON_POP</a>, and <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_TASK_BREAK_ON_EXEC">STARPU_TASK_BREAK_ON_EXEC</a> environment variables. By setting the job_id of a task in these environment variables, StarPU will raise <code>SIGTRAP</code> when the task is being scheduled, pushed, or popped by the scheduler. This means that when one notices that a task is being scheduled in a seemingly odd way, one can just reexecute the application in a debugger, with some of those variables set, and the execution will stop exactly at the scheduling points of this task, thus allowing to inspect the scheduler state, etc. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 22 2021 15:02:13 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
