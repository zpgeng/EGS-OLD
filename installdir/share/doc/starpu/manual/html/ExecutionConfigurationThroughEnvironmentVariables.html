<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StarPU Handbook: Execution Configuration Through Environment Variables</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ExecutionConfigurationThroughEnvironmentVariables.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Execution Configuration Through Environment Variables </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The behavior of the StarPU library and tools may be tuned thanks to the following environment variables.</p>
<h1><a class="anchor" id="EnvConfiguringWorkers"></a>
Configuring Workers</h1>
<dl>
<dt>STARPU_NCPU </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_NCPU"></a><a name="a__env__STARPU_NCPU"></a> Specify the number of CPU workers (thus not including workers dedicated to control accelerators). Note that by default, StarPU will not allocate more CPU workers than there are physical CPUs, and that some CPUs are used to control the accelerators. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_RESERVE_NCPU </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_RESERVE_NCPU"></a><a name="a__env__STARPU_RESERVE_NCPU"></a> Specify the number of CPU cores that should not be used by StarPU, so the application can use <a class="el" href="group__API__Initialization__and__Termination.html#ga6acf1a3a588fe37d12af360aaf4f59dd">starpu_get_next_bindid()</a> and <a class="el" href="group__API__Initialization__and__Termination.html#gaf73f6097829e10aba1a9c22ee4c4e2e0">starpu_bind_thread_on()</a> to bind its own threads.</p>
<p>This option is ignored if <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_NCPU">STARPU_NCPU</a> or <a class="el" href="group__API__Initialization__and__Termination.html#a68e93f60a9f8e4c82ab2af6a9cd3888a">starpu_conf::ncpus</a> is set. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_NCPUS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_NCPUS"></a><a name="a__env__STARPU_NCPUS"></a> This variable is deprecated. You should use <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_NCPU">STARPU_NCPU</a>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_NCUDA </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_NCUDA"></a><a name="a__env__STARPU_NCUDA"></a> Specify the number of CUDA devices that StarPU can use. If <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_NCUDA">STARPU_NCUDA</a> is lower than the number of physical devices, it is possible to select which CUDA devices should be used by the means of the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WORKERS_CUDAID">STARPU_WORKERS_CUDAID</a>. By default, StarPU will create as many CUDA workers as there are CUDA devices. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_NWORKER_PER_CUDA </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_NWORKER_PER_CUDA"></a><a name="a__env__STARPU_NWORKER_PER_CUDA"></a> Specify the number of workers per CUDA device, and thus the number of kernels which will be concurrently running on the devices, i.e. the number of CUDA streams. The default value is 1. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_CUDA_THREAD_PER_WORKER </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_CUDA_THREAD_PER_WORKER"></a><a name="a__env__STARPU_CUDA_THREAD_PER_WORKER"></a> Specify whether the cuda driver should use one thread per stream (1) or to use a single thread to drive all the streams of the device or all devices (0), and <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_CUDA_THREAD_PER_DEV">STARPU_CUDA_THREAD_PER_DEV</a> determines whether is it one thread per device or one thread for all devices. The default value is 0. Setting it to 1 is contradictory with setting <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_CUDA_THREAD_PER_DEV">STARPU_CUDA_THREAD_PER_DEV</a>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_CUDA_THREAD_PER_DEV </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_CUDA_THREAD_PER_DEV"></a><a name="a__env__STARPU_CUDA_THREAD_PER_DEV"></a> Specify whether the cuda driver should use one thread per device (1) or to use a single thread to drive all the devices (0). The default value is 1. It does not make sense to set this variable if <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_CUDA_THREAD_PER_WORKER">STARPU_CUDA_THREAD_PER_WORKER</a> is set to to 1 (since <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_CUDA_THREAD_PER_DEV">STARPU_CUDA_THREAD_PER_DEV</a> is then meaningless). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_CUDA_PIPELINE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_CUDA_PIPELINE"></a><a name="a__env__STARPU_CUDA_PIPELINE"></a> Specify how many asynchronous tasks are submitted in advance on CUDA devices. This for instance permits to overlap task management with the execution of previous tasks, but it also allows concurrent execution on Fermi cards, which otherwise bring spurious synchronizations. The default is 2. Setting the value to 0 forces a synchronous execution of all tasks. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_NOPENCL </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_NOPENCL"></a><a name="a__env__STARPU_NOPENCL"></a> OpenCL equivalent of the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_NCUDA">STARPU_NCUDA</a>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_OPENCL_PIPELINE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_OPENCL_PIPELINE"></a><a name="a__env__STARPU_OPENCL_PIPELINE"></a> Specify how many asynchronous tasks are submitted in advance on OpenCL devices. This for instance permits to overlap task management with the execution of previous tasks, but it also allows concurrent execution on Fermi cards, which otherwise bring spurious synchronizations. The default is 2. Setting the value to 0 forces a synchronous execution of all tasks. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_OPENCL_ON_CPUS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_OPENCL_ON_CPUS"></a><a name="a__env__STARPU_OPENCL_ON_CPUS"></a> By default, the OpenCL driver only enables GPU and accelerator devices. By setting the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_OPENCL_ON_CPUS">STARPU_OPENCL_ON_CPUS</a> to 1, the OpenCL driver will also enable CPU devices. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_OPENCL_ONLY_ON_CPUS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_OPENCL_ONLY_ON_CPUS"></a><a name="a__env__STARPU_OPENCL_ONLY_ON_CPUS"></a> By default, the OpenCL driver enables GPU and accelerator devices. By setting the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_OPENCL_ONLY_ON_CPUS">STARPU_OPENCL_ONLY_ON_CPUS</a> to 1, the OpenCL driver will ONLY enable CPU devices. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_NMIC </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_NMIC"></a><a name="a__env__STARPU_NMIC"></a> MIC equivalent of the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_NCUDA">STARPU_NCUDA</a>, i.e. the number of MIC devices to use. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_NMICTHREADS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_NMICTHREADS"></a><a name="a__env__STARPU_NMICTHREADS"></a> Number of threads to use on the MIC devices. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_NMPI_MS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_NMPI_MS"></a><a name="a__env__STARPU_NMPI_MS"></a> MPI Master Slave equivalent of the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_NCUDA">STARPU_NCUDA</a>, i.e. the number of MPI Master Slave devices to use. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_NMPIMSTHREADS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_NMPIMSTHREADS"></a><a name="a__env__STARPU_NMPIMSTHREADS"></a> Number of threads to use on the MPI Slave devices. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_MASTER_NODE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_MASTER_NODE"></a><a name="a__env__STARPU_MPI_MASTER_NODE"></a> This variable allows to chose which MPI node (with the MPI ID) will be the master. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_WORKERS_NOBIND </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_WORKERS_NOBIND"></a><a name="a__env__STARPU_WORKERS_NOBIND"></a> Setting it to non-zero will prevent StarPU from binding its threads to CPUs. This is for instance useful when running the testsuite in parallel. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_WORKERS_GETBIND </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_WORKERS_GETBIND"></a><a name="a__env__STARPU_WORKERS_GETBIND"></a> Setting it to non-zero makes StarPU use the OS-provided CPU binding to determine how many and which CPU cores it should use. This is notably useful when running several StarPU-MPI processes on the same host, to let the MPI launcher set the CPUs to be used. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_WORKERS_CPUID </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_WORKERS_CPUID"></a><a name="a__env__STARPU_WORKERS_CPUID"></a> Passing an array of integers in <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WORKERS_CPUID">STARPU_WORKERS_CPUID</a> specifies on which logical CPU the different workers should be bound. For instance, if <code>STARPU_WORKERS_CPUID = "0 1 4 5"</code>, the first worker will be bound to logical CPU #0, the second CPU worker will be bound to logical CPU #1 and so on. Note that the logical ordering of the CPUs is either determined by the OS, or provided by the library <code>hwloc</code> in case it is available. Ranges can be provided: for instance, <code>STARPU_WORKERS_CPUID = "1-3
5"</code> will bind the first three workers on logical CPUs #1, #2, and #3, and the fourth worker on logical CPU #5. Unbound ranges can also be provided: <code>STARPU_WORKERS_CPUID = "1-"</code> will bind the workers starting from logical CPU #1 up to last CPU.</p>
<p>Note that the first workers correspond to the CUDA workers, then come the OpenCL workers, and finally the CPU workers. For example if we have <code>STARPU_NCUDA=1</code>, <code>STARPU_NOPENCL=1</code>, <code>STARPU_NCPU=2</code> and <code>STARPU_WORKERS_CPUID = "0 2 1 3"</code>, the CUDA device will be controlled by logical CPU #0, the OpenCL device will be controlled by logical CPU #2, and the logical CPUs #1 and #3 will be used by the CPU workers.</p>
<p>If the number of workers is larger than the array given in <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WORKERS_CPUID">STARPU_WORKERS_CPUID</a>, the workers are bound to the logical CPUs in a round-robin fashion: if <code>STARPU_WORKERS_CPUID = "0 1"</code>, the first and the third (resp. second and fourth) workers will be put on CPU #0 (resp. CPU #1).</p>
<p>This variable is ignored if the field <a class="el" href="group__API__Initialization__and__Termination.html#affd5b335a988c417ecb679d5ecf7c489">starpu_conf::use_explicit_workers_bindid</a> passed to <a class="el" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init()</a> is set. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_WORKERS_COREID </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_WORKERS_COREID"></a><a name="a__env__STARPU_WORKERS_COREID"></a> Same as <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WORKERS_CPUID">STARPU_WORKERS_CPUID</a>, but bind the workers to cores instead of PUs (hyperthreads). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MAIN_THREAD_BIND </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MAIN_THREAD_BIND"></a><a name="a__env__STARPU_MAIN_THREAD_BIND"></a> When defined, this make StarPU bind the thread that calls <a class="el" href="group__API__Initialization__and__Termination.html#gab2948c26e01bbc6b29f11bfc7268e7d9">starpu_initialize()</a> to a reserved CPU, subtracted from the CPU workers. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MAIN_THREAD_CPUID </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MAIN_THREAD_CPUID"></a><a name="a__env__STARPU_MAIN_THREAD_CPUID"></a> When defined, this make StarPU bind the thread that calls <a class="el" href="group__API__Initialization__and__Termination.html#gab2948c26e01bbc6b29f11bfc7268e7d9">starpu_initialize()</a> to the given CPU ID. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MAIN_THREAD_COREID </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MAIN_THREAD_COREID"></a><a name="a__env__STARPU_MAIN_THREAD_COREID"></a> Same as <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MAIN_THREAD_CPUID">STARPU_MAIN_THREAD_CPUID</a>, but bind the thread that calls <a class="el" href="group__API__Initialization__and__Termination.html#gab2948c26e01bbc6b29f11bfc7268e7d9">starpu_initialize()</a> to the given core, instead of the PU (hyperthread). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_THREAD_CPUID </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_THREAD_CPUID"></a><a name="a__env__STARPU_MPI_THREAD_CPUID"></a> When defined, this make StarPU bind its MPI thread to the given CPU ID. Setting it to -1 (the default value) will use a reserved CPU, subtracted from the CPU workers. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_THREAD_COREID </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_THREAD_COREID"></a><a name="a__env__STARPU_MPI_THREAD_COREID"></a> Same as <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_THREAD_CPUID">STARPU_MPI_THREAD_CPUID</a>, but bind the MPI thread to the given core ID, instead of the PU (hyperthread). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_NOBIND </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_NOBIND"></a><a name="a__env__STARPU_MPI_NOBIND"></a> Setting it to non-zero will prevent StarPU from binding the MPI to a separate core. This is for instance useful when running the testsuite on a single system. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_WORKERS_CUDAID </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_WORKERS_CUDAID"></a><a name="a__env__STARPU_WORKERS_CUDAID"></a> Similarly to the <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WORKERS_CPUID">STARPU_WORKERS_CPUID</a> environment variable, it is possible to select which CUDA devices should be used by StarPU. On a machine equipped with 4 GPUs, setting <code>STARPU_WORKERS_CUDAID = "1 3"</code> and <code>STARPU_NCUDA=2</code> specifies that 2 CUDA workers should be created, and that they should use CUDA devices #1 and #3 (the logical ordering of the devices is the one reported by CUDA).</p>
<p>This variable is ignored if the field <a class="el" href="group__API__Initialization__and__Termination.html#a27718585874f9012e9955ba308e2cd8f">starpu_conf::use_explicit_workers_cuda_gpuid</a> passed to <a class="el" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init()</a> is set. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_WORKERS_OPENCLID </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_WORKERS_OPENCLID"></a><a name="a__env__STARPU_WORKERS_OPENCLID"></a> OpenCL equivalent of the <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WORKERS_CUDAID">STARPU_WORKERS_CUDAID</a> environment variable.</p>
<p>This variable is ignored if the field <a class="el" href="group__API__Initialization__and__Termination.html#a30cab554913e27a02512badaf204a266">starpu_conf::use_explicit_workers_opencl_gpuid</a> passed to <a class="el" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init()</a> is set. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_WORKERS_MICID </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_WORKERS_MICID"></a><a name="a__env__STARPU_WORKERS_MICID"></a> MIC equivalent of the <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WORKERS_CUDAID">STARPU_WORKERS_CUDAID</a> environment variable.</p>
<p>This variable is ignored if the field <a class="el" href="group__API__Initialization__and__Termination.html#a052f3cac0ebec9932c66d8f08cd9b6d4">starpu_conf::use_explicit_workers_mic_deviceid</a> passed to <a class="el" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init()</a> is set. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_WORKER_TREE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_WORKER_TREE"></a><a name="a__env__STARPU_WORKER_TREE"></a> Define to 1 to enable the tree iterator in schedulers. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SINGLE_COMBINED_WORKER </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SINGLE_COMBINED_WORKER"></a><a name="a__env__STARPU_SINGLE_COMBINED_WORKER"></a> If set, StarPU will create several workers which won't be able to work concurrently. It will by default create combined workers which size goes from 1 to the total number of CPU workers in the system. <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MIN_WORKERSIZE">STARPU_MIN_WORKERSIZE</a> and <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MAX_WORKERSIZE">STARPU_MAX_WORKERSIZE</a> can be used to change this default. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MIN_WORKERSIZE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MIN_WORKERSIZE"></a><a name="a__env__STARPU_MIN_WORKERSIZE"></a> <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MIN_WORKERSIZE">STARPU_MIN_WORKERSIZE</a> permits to specify the minimum size of the combined workers (instead of the default 2) </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MAX_WORKERSIZE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MAX_WORKERSIZE"></a><a name="a__env__STARPU_MAX_WORKERSIZE"></a> <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MAX_WORKERSIZE">STARPU_MAX_WORKERSIZE</a> permits to specify the minimum size of the combined workers (instead of the number of CPU workers in the system) </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SYNTHESIZE_ARITY_COMBINED_WORKER </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SYNTHESIZE_ARITY_COMBINED_WORKER"></a><a name="a__env__STARPU_SYNTHESIZE_ARITY_COMBINED_WORKER"></a> Let the user decide how many elements are allowed between combined workers created from hwloc information. For instance, in the case of sockets with 6 cores without shared L2 caches, if <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SYNTHESIZE_ARITY_COMBINED_WORKER">STARPU_SYNTHESIZE_ARITY_COMBINED_WORKER</a> is set to 6, no combined worker will be synthesized beyond one for the socket and one per core. If it is set to 3, 3 intermediate combined workers will be synthesized, to divide the socket cores into 3 chunks of 2 cores. If it set to 2, 2 intermediate combined workers will be synthesized, to divide the the socket cores into 2 chunks of 3 cores, and then 3 additional combined workers will be synthesized, to divide the former synthesized workers into a bunch of 2 cores, and the remaining core (for which no combined worker is synthesized since there is already a normal worker for it).</p>
<p>The default, 2, thus makes StarPU tend to building a binary trees of combined workers. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_DISABLE_ASYNCHRONOUS_COPY </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_DISABLE_ASYNCHRONOUS_COPY"></a><a name="a__env__STARPU_DISABLE_ASYNCHRONOUS_COPY"></a> Disable asynchronous copies between CPU and GPU devices. The AMD implementation of OpenCL is known to fail when copying data asynchronously. When using this implementation, it is therefore necessary to disable asynchronous data transfers. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_DISABLE_ASYNCHRONOUS_CUDA_COPY </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_DISABLE_ASYNCHRONOUS_CUDA_COPY"></a><a name="a__env__STARPU_DISABLE_ASYNCHRONOUS_CUDA_COPY"></a> Disable asynchronous copies between CPU and CUDA devices. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_DISABLE_ASYNCHRONOUS_OPENCL_COPY </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_DISABLE_ASYNCHRONOUS_OPENCL_COPY"></a><a name="a__env__STARPU_DISABLE_ASYNCHRONOUS_OPENCL_COPY"></a> Disable asynchronous copies between CPU and OpenCL devices. The AMD implementation of OpenCL is known to fail when copying data asynchronously. When using this implementation, it is therefore necessary to disable asynchronous data transfers. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_DISABLE_ASYNCHRONOUS_MIC_COPY </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_DISABLE_ASYNCHRONOUS_MIC_COPY"></a><a name="a__env__STARPU_DISABLE_ASYNCHRONOUS_MIC_COPY"></a> Disable asynchronous copies between CPU and MIC devices. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_DISABLE_ASYNCHRONOUS_MPI_MS_COPY </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_DISABLE_ASYNCHRONOUS_MPI_MS_COPY"></a><a name="a__env__STARPU_DISABLE_ASYNCHRONOUS_MPI_MS_COPY"></a> Disable asynchronous copies between CPU and MPI Slave devices. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_ENABLE_CUDA_GPU_GPU_DIRECT </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_ENABLE_CUDA_GPU_GPU_DIRECT"></a><a name="a__env__STARPU_ENABLE_CUDA_GPU_GPU_DIRECT"></a> Enable (1) or Disable (0) direct CUDA transfers from GPU to GPU, without copying through RAM. The default is Enabled. This permits to test the performance effect of GPU-Direct. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_DISABLE_PINNING </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_DISABLE_PINNING"></a><a name="a__env__STARPU_DISABLE_PINNING"></a> Disable (1) or Enable (0) pinning host memory allocated through starpu_malloc, starpu_memory_pin and friends. The default is Enabled. This permits to test the performance effect of memory pinning. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_BACKOFF_MIN </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_BACKOFF_MIN"></a><a name="a__env__STARPU_BACKOFF_MIN"></a> Set minimum exponential backoff of number of cycles to pause when spinning. Default value is 1. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_BACKOFF_MAX </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_BACKOFF_MAX"></a><a name="a__env__STARPU_BACKOFF_MAX"></a> Set maximum exponential backoff of number of cycles to pause when spinning. Default value is 32. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MIC_SINK_PROGRAM_NAME </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MIC_SINK_PROGRAM_NAME"></a><a name="a__env__STARPU_MIC_SINK_PROGRAM_NAME"></a> todo </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MIC_SINK_PROGRAM_PATH </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MIC_SINK_PROGRAM_PATH"></a><a name="a__env__STARPU_MIC_SINK_PROGRAM_PATH"></a> todo </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MIC_PROGRAM_PATH </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MIC_PROGRAM_PATH"></a><a name="a__env__STARPU_MIC_PROGRAM_PATH"></a> todo </p>
<p class="enddd"></p>
</dd>
</dl>
<h1><a class="anchor" id="ConfiguringTheSchedulingEngine"></a>
Configuring The Scheduling Engine</h1>
<dl>
<dt>STARPU_SCHED </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SCHED"></a><a name="a__env__STARPU_SCHED"></a> Choose between the different scheduling policies proposed by StarPU: work random, stealing, greedy, with performance models, etc.</p>
<p>Use <code>STARPU_SCHED=help</code> to get the list of available schedulers. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MIN_PRIO </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MIN_PRIO_env"></a><a name="a__env__STARPU_MIN_PRIO"></a> Set the mininum priority used by priorities-aware schedulers. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MAX_PRIO </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MAX_PRIO_env"></a><a name="a__env__STARPU_MAX_PRIO"></a> Set the maximum priority used by priorities-aware schedulers. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_CALIBRATE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_CALIBRATE"></a><a name="a__env__STARPU_CALIBRATE"></a> If this variable is set to 1, the performance models are calibrated during the execution. If it is set to 2, the previous values are dropped to restart calibration from scratch. Setting this variable to 0 disable calibration, this is the default behaviour.</p>
<p>Note: this currently only applies to <code>dm</code> and <code>dmda</code> scheduling policies. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_CALIBRATE_MINIMUM </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_CALIBRATE_MINIMUM"></a><a name="a__env__STARPU_CALIBRATE_MINIMUM"></a> Define the minimum number of calibration measurements that will be made before considering that the performance model is calibrated. The default value is 10. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_BUS_CALIBRATE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_BUS_CALIBRATE"></a><a name="a__env__STARPU_BUS_CALIBRATE"></a> If this variable is set to 1, the bus is recalibrated during intialization. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_PREFETCH </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_PREFETCH"></a><a name="a__env__STARPU_PREFETCH"></a> Indicate whether data prefetching should be enabled (0 means that it is disabled). If prefetching is enabled, when a task is scheduled to be executed e.g. on a GPU, StarPU will request an asynchronous transfer in advance, so that data is already present on the GPU when the task starts. As a result, computation and data transfers are overlapped. Note that prefetching is enabled by default in StarPU. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SCHED_ALPHA </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SCHED_ALPHA"></a><a name="a__env__STARPU_SCHED_ALPHA"></a> To estimate the cost of a task StarPU takes into account the estimated computation time (obtained thanks to performance models). The alpha factor is the coefficient to be applied to it before adding it to the communication part. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SCHED_BETA </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SCHED_BETA"></a><a name="a__env__STARPU_SCHED_BETA"></a> To estimate the cost of a task StarPU takes into account the estimated data transfer time (obtained thanks to performance models). The beta factor is the coefficient to be applied to it before adding it to the computation part. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SCHED_GAMMA </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SCHED_GAMMA"></a><a name="a__env__STARPU_SCHED_GAMMA"></a> Define the execution time penalty of a joule (<a class="el" href="Scheduling.html#Energy-basedScheduling">Energy-based Scheduling</a>). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SCHED_READY </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SCHED_READY"></a><a name="a__env__STARPU_SCHED_READY"></a> For a modular scheduler with sorted queues below the decision component, workers pick up a task which has most of its data already available. Setting this to 0 disables this. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SCHED_SORTED_ABOVE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SCHED_SORTED_ABOVE"></a><a name="a__env__STARPU_SCHED_SORTED_ABOVE"></a> For a modular scheduler with queues above the decision component, it is usually sorted by priority. Setting this to 0 disables this. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SCHED_SORTED_BELOW </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SCHED_SORTED_BELOW"></a><a name="a__env__STARPU_SCHED_SORTED_BELOW"></a> For a modular scheduler with queues below the decision component, they are usually sorted by priority. Setting this to 0 disables this. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_IDLE_POWER </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_IDLE_POWER"></a><a name="a__env__STARPU_IDLE_POWER"></a> Define the idle power of the machine (<a class="el" href="Scheduling.html#Energy-basedScheduling">Energy-based Scheduling</a>). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_PROFILING </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_PROFILING"></a><a name="a__env__STARPU_PROFILING"></a> Enable on-line performance monitoring (<a class="el" href="OnlinePerformanceTools.html#EnablingOn-linePerformanceMonitoring">Enabling On-line Performance Monitoring</a>). </p>
<p class="enddd"></p>
</dd>
</dl>
<h1><a class="anchor" id="Extensions"></a>
Extensions</h1>
<dl>
<dt>SOCL_OCL_LIB_OPENCL </dt>
<dd><p class="startdd"><a class="anchor" id="SOCL_OCL_LIB_OPENCL"></a><a name="a__env__SOCL_OCL_LIB_OPENCL"></a> THE SOCL test suite is only run when the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#SOCL_OCL_LIB_OPENCL">SOCL_OCL_LIB_OPENCL</a> is defined. It should contain the location of the file <code>libOpenCL.so</code> of the OCL ICD implementation. </p>
<p class="enddd"></p>
</dd>
<dt>OCL_ICD_VENDORS </dt>
<dd><p class="startdd"><a class="anchor" id="OCL_ICD_VENDORS"></a><a name="a__env__OCL_ICD_VENDORS"></a> When using SOCL with OpenCL ICD (<a href="https://forge.imag.fr/projects/ocl-icd/">https://forge.imag.fr/projects/ocl-icd/</a>), this variable may be used to point to the directory where ICD files are installed. The default directory is <code>/etc/OpenCL/vendors</code>. StarPU installs ICD files in the directory <code>$prefix/share/starpu/opencl/vendors</code>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_COMM_STATS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_COMM_STATS"></a><a name="a__env__STARPU_COMM_STATS"></a> Communication statistics for starpumpi (<a class="el" href="MPISupport.html#MPIDebug">Debugging MPI</a>) will be enabled when the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_COMM_STATS">STARPU_COMM_STATS</a> is defined to an value other than 0. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_CACHE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_CACHE"></a><a name="a__env__STARPU_MPI_CACHE"></a> Communication cache for starpumpi (<a class="el" href="MPISupport.html">MPI Support</a>) will be disabled when the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_CACHE">STARPU_MPI_CACHE</a> is set to 0. It is enabled by default or for any other values of the variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_CACHE">STARPU_MPI_CACHE</a>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_COMM </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_COMM"></a><a name="a__env__STARPU_MPI_COMM"></a> Communication trace for starpumpi (<a class="el" href="MPISupport.html">MPI Support</a>) will be enabled when the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_COMM">STARPU_MPI_COMM</a> is set to 1, and StarPU has been configured with the option <a class="el" href="CompilationConfiguration.html#enable-verbose">--enable-verbose</a>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_CACHE_STATS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_CACHE_STATS"></a><a name="a__env__STARPU_MPI_CACHE_STATS"></a> When set to 1, statistics are enabled for the communication cache (<a class="el" href="MPISupport.html">MPI Support</a>). For now, it prints messages on the standard output when data are added or removed from the received communication cache. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_PRIORITIES </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_PRIORITIES"></a><a name="a__env__STARPU_MPI_PRIORITIES"></a> When set to 0, the use of priorities to order MPI communications is disabled (<a class="el" href="MPISupport.html">MPI Support</a>). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_NDETACHED_SEND </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_NDETACHED_SEND"></a><a name="a__env__STARPU_MPI_NDETACHED_SEND"></a> This sets the number of send requests that StarPU-MPI will emit concurrently. The default is 10. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_NREADY_PROCESS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_NREADY_PROCESS"></a><a name="a__env__STARPU_MPI_NREADY_PROCESS"></a> This sets the number of requests that StarPU-MPI will submit to MPI before polling for termination of existing requests. The default is 10. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_FAKE_SIZE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_FAKE_SIZE"></a><a name="a__env__STARPU_MPI_FAKE_SIZE"></a> Setting to a number makes StarPU believe that there are as many MPI nodes, even if it was run on only one MPI node. This allows e.g. to simulate the execution of one of the nodes of a big cluster without actually running the rest. It of course does not provide computation results and timing. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_FAKE_RANK </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_FAKE_RANK"></a><a name="a__env__STARPU_MPI_FAKE_RANK"></a> Setting to a number makes StarPU believe that it runs the given MPI node, even if it was run on only one MPI node. This allows e.g. to simulate the execution of one of the nodes of a big cluster without actually running the rest. It of course does not provide computation results and timing. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_DRIVER_CALL_FREQUENCY </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_DRIVER_CALL_FREQUENCY"></a><a name="a__env__STARPU_MPI_DRIVER_CALL_FREQUENCY"></a> When set to a positive value, activates the interleaving of the execution of tasks with the progression of MPI communications (<a class="el" href="MPISupport.html">MPI Support</a>). The <a class="el" href="group__API__MPI__Support.html#gaec408170d2c815fdfdafa24873bc02da">starpu_mpi_init_conf()</a> function must have been called by the application for that environment variable to be used. When set to 0, the MPI progression thread does not use at all the driver given by the user, and only focuses on making MPI communications progress. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_DRIVER_TASK_FREQUENCY </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_DRIVER_TASK_FREQUENCY"></a><a name="a__env__STARPU_MPI_DRIVER_TASK_FREQUENCY"></a> When set to a positive value, the interleaving of the execution of tasks with the progression of MPI communications mechanism to execute several tasks before checking communication requests again (<a class="el" href="MPISupport.html">MPI Support</a>). The <a class="el" href="group__API__MPI__Support.html#gaec408170d2c815fdfdafa24873bc02da">starpu_mpi_init_conf()</a> function must have been called by the application for that environment variable to be used, and the STARPU_MPI_DRIVER_CALL_FREQUENCY environment variable set to a positive value. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SIMGRID </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SIMGRID"></a><a name="a__env__STARPU_SIMGRID"></a> When set to 1 (the default is 0), this makes StarPU check that it was really build with simulation support. This is convenient in scripts to avoid using a native version, that would try to update performance models... </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SIMGRID_TRANSFER_COST </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SIMGRID_TRANSFER_COST"></a><a name="a__env__STARPU_SIMGRID_TRANSFER_COST"></a> When set to 1 (which is the default), data transfers (over PCI bus, typically) are taken into account in SimGrid mode. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SIMGRID_CUDA_MALLOC_COST </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SIMGRID_CUDA_MALLOC_COST"></a><a name="a__env__STARPU_SIMGRID_CUDA_MALLOC_COST"></a> When set to 1 (which is the default), CUDA malloc costs are taken into account in SimGrid mode. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SIMGRID_CUDA_QUEUE_COST </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SIMGRID_CUDA_QUEUE_COST"></a><a name="a__env__STARPU_SIMGRID_CUDA_QUEUE_COST"></a> When set to 1 (which is the default), CUDA task and transfer queueing costs are taken into account in SimGrid mode. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_PCI_FLAT </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_PCI_FLAT"></a><a name="a__env__STARPU_PCI_FLAT"></a> When unset or set to 0, the platform file created for SimGrid will contain PCI bandwidths and routes. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SIMGRID_QUEUE_MALLOC_COST </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SIMGRID_QUEUE_MALLOC_COST"></a><a name="a__env__STARPU_SIMGRID_QUEUE_MALLOC_COST"></a> When unset or set to 1, simulate within SimGrid the GPU transfer queueing. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MALLOC_SIMULATION_FOLD </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MALLOC_SIMULATION_FOLD"></a><a name="a__env__STARPU_MALLOC_SIMULATION_FOLD"></a> Define the size of the file used for folding virtual allocation, in MiB. The default is 1, thus allowing 64GiB virtual memory when Linux's <code>sysctl vm.max_map_count</code> value is the default 65535. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SIMGRID_TASK_SUBMIT_COST </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SIMGRID_TASK_SUBMIT_COST"></a><a name="a__env__STARPU_SIMGRID_TASK_SUBMIT_COST"></a> When set to 1 (which is the default), task submission costs are taken into account in SimGrid mode. This provides more accurate SimGrid predictions, especially for the beginning of the execution. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SIMGRID_FETCHING_INPUT_COST </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SIMGRID_FETCHING_INPUT_COST"></a><a name="a__env__STARPU_SIMGRID_FETCHING_INPUT_COST"></a> When set to 1 (which is the default), fetching input costs are taken into account in SimGrid mode. This provides more accurate SimGrid predictions, especially regarding data transfers. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SIMGRID_SCHED_COST </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SIMGRID_SCHED_COST"></a><a name="a__env__STARPU_SIMGRID_SCHED_COST"></a> When set to 1 (0 is the default), scheduling costs are taken into account in SimGrid mode. This provides more accurate SimGrid predictions, and allows studying scheduling overhead of the runtime system. However, it also makes simulation non-deterministic. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SINK </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SINK"></a><a name="a__env__STARPU_SINK"></a> Variable defined by StarPU when running MPI Xeon PHI on the sink. </p>
<p class="enddd"></p>
</dd>
</dl>
<h1><a class="anchor" id="MiscellaneousAndDebug"></a>
Miscellaneous And Debug</h1>
<dl>
<dt>STARPU_HOME </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_HOME"></a><a name="a__env__STARPU_HOME"></a> Specify the main directory in which StarPU stores its configuration files. The default is <code>$HOME</code> on Unix environments, and <code>$USERPROFILE</code> on Windows environments. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_PATH </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_PATH"></a><a name="a__env__STARPU_PATH"></a> Only used on Windows environments. Specify the main directory in which StarPU is installed (<a class="el" href="BuildingAndInstallingStarPU.html#RunningABasicStarPUApplicationOnMicrosoft">Running a Basic StarPU Application on Microsoft Visual C</a>) </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_PERF_MODEL_DIR </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_PERF_MODEL_DIR"></a><a name="a__env__STARPU_PERF_MODEL_DIR"></a> Specify the main directory in which StarPU stores its performance model files. The default is <code>$STARPU_HOME/.starpu/sampling</code>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_PERF_MODEL_HOMOGENEOUS_CPU </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_PERF_MODEL_HOMOGENEOUS_CPU"></a><a name="a__env__STARPU_PERF_MODEL_HOMOGENEOUS_CPU"></a> When this is set to 0, StarPU will assume that CPU devices do not have the same performance, and thus use different performance models for them, thus making kernel calibration much longer, since measurements have to be made for each CPU core. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_PERF_MODEL_HOMOGENEOUS_CUDA </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_PERF_MODEL_HOMOGENEOUS_CUDA"></a><a name="a__env__STARPU_PERF_MODEL_HOMOGENEOUS_CUDA"></a> When this is set to 1, StarPU will assume that all CUDA devices have the same performance, and thus share performance models for them, thus allowing kernel calibration to be much faster, since measurements only have to be once for all CUDA GPUs. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_PERF_MODEL_HOMOGENEOUS_OPENCL </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_PERF_MODEL_HOMOGENEOUS_OPENCL"></a><a name="a__env__STARPU_PERF_MODEL_HOMOGENEOUS_OPENCL"></a> When this is set to 1, StarPU will assume that all OPENCL devices have the same performance, and thus share performance models for them, thus allowing kernel calibration to be much faster, since measurements only have to be once for all OPENCL GPUs. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_PERF_MODEL_HOMOGENEOUS_MIC </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_PERF_MODEL_HOMOGENEOUS_MIC"></a><a name="a__env__STARPU_PERF_MODEL_HOMOGENEOUS_MIC"></a> When this is set to 1, StarPU will assume that all MIC devices have the same performance, and thus share performance models for them, thus allowing kernel calibration to be much faster, since measurements only have to be once for all MIC GPUs. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_PERF_MODEL_HOMOGENEOUS_MPI_MS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_PERF_MODEL_HOMOGENEOUS_MPI_MS"></a><a name="a__env__STARPU_PERF_MODEL_HOMOGENEOUS_MPI_MS"></a> When this is set to 1, StarPU will assume that all MPI Slave devices have the same performance, and thus share performance models for them, thus allowing kernel calibration to be much faster, since measurements only have to be once for all MPI Slaves. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_HOSTNAME </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_HOSTNAME"></a><a name="a__env__STARPU_HOSTNAME"></a> When set, force the hostname to be used when dealing performance model files. Models are indexed by machine name. When running for example on a homogenenous cluster, it is possible to share the models between machines by setting <code>export STARPU_HOSTNAME=some_global_name</code>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_OPENCL_PROGRAM_DIR </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_OPENCL_PROGRAM_DIR"></a><a name="a__env__STARPU_OPENCL_PROGRAM_DIR"></a> Specify the directory where the OpenCL codelet source files are located. The function <a class="el" href="group__API__OpenCL__Extensions.html#ga7dd3784262c0be223394bc8c2fe81935">starpu_opencl_load_program_source()</a> looks for the codelet in the current directory, in the directory specified by the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_OPENCL_PROGRAM_DIR">STARPU_OPENCL_PROGRAM_DIR</a>, in the directory <code>share/starpu/opencl</code> of the installation directory of StarPU, and finally in the source directory of StarPU. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_SILENT </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_SILENT"></a><a name="a__env__STARPU_SILENT"></a> Allow to disable verbose mode at runtime when StarPU has been configured with the option <a class="el" href="CompilationConfiguration.html#enable-verbose">--enable-verbose</a>. Also disable the display of StarPU information and warning messages. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_DEBUG_LEVEL_MIN </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_DEBUG_LEVEL_MIN"></a><a name="a__env__STARPU_MPI_DEBUG_LEVEL_MIN"></a> Set the minimum level of debug when StarPU has been configured with the option <a class="el" href="CompilationConfiguration.html#enable-mpi-verbose">--enable-mpi-verbose</a>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MPI_DEBUG_LEVEL_MAX </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MPI_DEBUG_LEVEL_MAX"></a><a name="a__env__STARPU_MPI_DEBUG_LEVEL_MAX"></a> Set the maximum level of debug when StarPU has been configured with the option <a class="el" href="CompilationConfiguration.html#enable-mpi-verbose">--enable-mpi-verbose</a>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_LOGFILENAME </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_LOGFILENAME"></a><a name="a__env__STARPU_LOGFILENAME"></a> Specify in which file the debugging output should be saved to. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_FXT_PREFIX </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_FXT_PREFIX"></a><a name="a__env__STARPU_FXT_PREFIX"></a> Specify in which directory to save the generated trace if FxT is enabled. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_FXT_SUFFIX </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_FXT_SUFFIX"></a><a name="a__env__STARPU_FXT_SUFFIX"></a> Specify in which file to save the generated trace if FxT is enabled. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_FXT_TRACE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_FXT_TRACE"></a><a name="a__env__STARPU_FXT_TRACE"></a> Specify whether to generate (1) or not (0) the FxT trace in /tmp/prof_file_XXX_YYY (the directory and file name can be changed with <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_FXT_PREFIX">STARPU_FXT_PREFIX</a> and <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_FXT_SUFFIX">STARPU_FXT_SUFFIX</a>). The default is 1 (generate it) </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_LIMIT_CUDA_devid_MEM </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_LIMIT_CUDA_devid_MEM"></a><a name="a__env__STARPU_LIMIT_CUDA_devid_MEM"></a> Specify the maximum number of megabytes that should be available to the application on the CUDA device with the identifier <code>devid</code>. This variable is intended to be used for experimental purposes as it emulates devices that have a limited amount of memory. When defined, the variable overwrites the value of the variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_CUDA_MEM">STARPU_LIMIT_CUDA_MEM</a>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_LIMIT_CUDA_MEM </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_LIMIT_CUDA_MEM"></a><a name="a__env__STARPU_LIMIT_CUDA_MEM"></a> Specify the maximum number of megabytes that should be available to the application on each CUDA devices. This variable is intended to be used for experimental purposes as it emulates devices that have a limited amount of memory. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_LIMIT_OPENCL_devid_MEM </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_LIMIT_OPENCL_devid_MEM"></a><a name="a__env__STARPU_LIMIT_OPENCL_devid_MEM"></a> Specify the maximum number of megabytes that should be available to the application on the OpenCL device with the identifier <code>devid</code>. This variable is intended to be used for experimental purposes as it emulates devices that have a limited amount of memory. When defined, the variable overwrites the value of the variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_OPENCL_MEM">STARPU_LIMIT_OPENCL_MEM</a>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_LIMIT_OPENCL_MEM </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_LIMIT_OPENCL_MEM"></a><a name="a__env__STARPU_LIMIT_OPENCL_MEM"></a> Specify the maximum number of megabytes that should be available to the application on each OpenCL devices. This variable is intended to be used for experimental purposes as it emulates devices that have a limited amount of memory. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_LIMIT_CPU_MEM </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_LIMIT_CPU_MEM"></a><a name="a__env__STARPU_LIMIT_CPU_MEM"></a> Specify the maximum number of megabytes that should be available to the application in the main CPU memory. Setting it enables allocation cache in main memory. Setting it to zero lets StarPU overflow memory. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_LIMIT_CPU_NUMA_devid_MEM </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_LIMIT_CPU_NUMA_devid_MEM"></a><a name="a__env__STARPU_LIMIT_CPU_NUMA_devid_MEM"></a> Specify the maximum number of megabytes that should be available to the application on the NUMA node with the OS identifier <code>devid</code>. Setting it overrides the value of STARPU_LIMIT_CPU_MEM. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_LIMIT_CPU_NUMA_MEM </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_LIMIT_CPU_NUMA_MEM"></a><a name="a__env__STARPU_LIMIT_CPU_NUMA_MEM"></a> Specify the maximum number of megabytes that should be available to the application on each NUMA node. This is the same as specifying that same amount with <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_CPU_NUMA_devid_MEM">STARPU_LIMIT_CPU_NUMA_devid_MEM</a> for each NUMA node number. The total memory available to StarPU will thus be this amount multiplied by the number of NUMA nodes used by StarPU. Any <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_CPU_NUMA_devid_MEM">STARPU_LIMIT_CPU_NUMA_devid_MEM</a> additionally specified will take over STARPU_LIMIT_CPU_NUMA_MEM. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_LIMIT_BANDWIDTH </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_LIMIT_BANDWIDTH"></a><a name="a__env__STARPU_LIMIT_BANDWIDTH"></a> Specify the maximum available PCI bandwidth of the system in MB/s. This can only be effective with simgrid simulation. This allows to easily override the bandwidths stored in the platform file generated from measurements on the native system. This can be used e.g. for convenient</p>
<p>Specify the maximum number of megabytes that should be available to the application on each NUMA node. This is the same as specifying that same amount with <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_CPU_NUMA_devid_MEM">STARPU_LIMIT_CPU_NUMA_devid_MEM</a> for each NUMA node number. The total memory available to StarPU will thus be this amount multiplied by the number of NUMA nodes used by StarPU. Any <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_CPU_NUMA_devid_MEM">STARPU_LIMIT_CPU_NUMA_devid_MEM</a> additionally specified will take over STARPU_LIMIT_BANDWIDTH. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MINIMUM_AVAILABLE_MEM </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MINIMUM_AVAILABLE_MEM"></a><a name="a__env__STARPU_MINIMUM_AVAILABLE_MEM"></a> Specify the minimum percentage of memory that should be available in GPUs (or in main memory, when using out of core), below which a reclaiming pass is performed. The default is 0%. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_TARGET_AVAILABLE_MEM </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_TARGET_AVAILABLE_MEM"></a><a name="a__env__STARPU_TARGET_AVAILABLE_MEM"></a> Specify the target percentage of memory that should be reached in GPUs (or in main memory, when using out of core), when performing a periodic reclaiming pass. The default is 0%. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MINIMUM_CLEAN_BUFFERS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MINIMUM_CLEAN_BUFFERS"></a><a name="a__env__STARPU_MINIMUM_CLEAN_BUFFERS"></a> Specify the minimum percentage of number of buffers that should be clean in GPUs (or in main memory, when using out of core), below which asynchronous writebacks will be issued. The default is 5%. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_TARGET_CLEAN_BUFFERS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_TARGET_CLEAN_BUFFERS"></a><a name="a__env__STARPU_TARGET_CLEAN_BUFFERS"></a> Specify the target percentage of number of buffers that should be reached in GPUs (or in main memory, when using out of core), when performing an asynchronous writeback pass. The default is 10%. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_DIDUSE_BARRIER </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_DIDUSE_BARRIER"></a><a name="a__env__STARPU_DIDUSE_BARRIER"></a> When set to 1, StarPU will never evict a piece of data if it has not been used by at least one task. This avoids odd behaviors under high memory pressure, but can lead to deadlocks, so is to be considered experimental only. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_DISK_SWAP </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_DISK_SWAP"></a><a name="a__env__STARPU_DISK_SWAP"></a> Specify a path where StarPU can push data when the main memory is getting full. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_DISK_SWAP_BACKEND </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_DISK_SWAP_BACKEND"></a><a name="a__env__STARPU_DISK_SWAP_BACKEND"></a> Specify the backend to be used by StarPU to push data when the main memory is getting full. The default is unistd (i.e. using read/write functions), other values are stdio (i.e. using fread/fwrite), unistd_o_direct (i.e. using read/write with O_DIRECT), leveldb (i.e. using a leveldb database), and hdf5 (i.e. using HDF5 library). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_DISK_SWAP_SIZE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_DISK_SWAP_SIZE"></a><a name="a__env__STARPU_DISK_SWAP_SIZE"></a> Specify the maximum size in MiB to be used by StarPU to push data when the main memory is getting full. The default is unlimited. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_LIMIT_MAX_SUBMITTED_TASKS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_LIMIT_MAX_SUBMITTED_TASKS"></a><a name="a__env__STARPU_LIMIT_MAX_SUBMITTED_TASKS"></a> Allow users to control the task submission flow by specifying to StarPU a maximum number of submitted tasks allowed at a given time, i.e. when this limit is reached task submission becomes blocking until enough tasks have completed, specified by <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_MIN_SUBMITTED_TASKS">STARPU_LIMIT_MIN_SUBMITTED_TASKS</a>. Setting it enables allocation cache buffer reuse in main memory. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_LIMIT_MIN_SUBMITTED_TASKS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_LIMIT_MIN_SUBMITTED_TASKS"></a><a name="a__env__STARPU_LIMIT_MIN_SUBMITTED_TASKS"></a> Allow users to control the task submission flow by specifying to StarPU a submitted task threshold to wait before unblocking task submission. This variable has to be used in conjunction with <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_MAX_SUBMITTED_TASKS">STARPU_LIMIT_MAX_SUBMITTED_TASKS</a> which puts the task submission thread to sleep. Setting it enables allocation cache buffer reuse in main memory. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_TRACE_BUFFER_SIZE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_TRACE_BUFFER_SIZE"></a><a name="a__env__STARPU_TRACE_BUFFER_SIZE"></a> Set the buffer size for recording trace events in MiB. Setting it to a big size allows to avoid pauses in the trace while it is recorded on the disk. This however also consumes memory, of course. The default value is 64. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_GENERATE_TRACE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_GENERATE_TRACE"></a><a name="a__env__STARPU_GENERATE_TRACE"></a> When set to <code>1</code>, indicate that StarPU should automatically generate a Paje trace when <a class="el" href="group__API__Initialization__and__Termination.html#ga48edf5e30e71fbb71923e3867ad16c0a">starpu_shutdown()</a> is called. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_GENERATE_TRACE_OPTIONS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_GENERATE_TRACE_OPTIONS"></a><a name="a__env__STARPU_GENERATE_TRACE_OPTIONS"></a> When the variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_GENERATE_TRACE">STARPU_GENERATE_TRACE</a> is set to <code>1</code> to generate a Paje trace, this variable can be set to specify options (see <code>starpu_fxt_tool &ndash;help</code>). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_ENABLE_STATS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_ENABLE_STATS"></a><a name="a__env__STARPU_ENABLE_STATS"></a> When defined, enable gathering various data statistics (<a class="el" href="OfflinePerformanceTools.html#DataStatistics">Data Statistics</a>). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MEMORY_STATS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MEMORY_STATS"></a><a name="a__env__STARPU_MEMORY_STATS"></a> When set to 0, disable the display of memory statistics on data which have not been unregistered at the end of the execution (<a class="el" href="OfflinePerformanceTools.html#MemoryFeedback">Memory Feedback</a>). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_MAX_MEMORY_USE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_MAX_MEMORY_USE"></a><a name="a__env__STARPU_MAX_MEMORY_USE"></a> When set to 1, display at the end of the execution the maximum memory used by StarPU for internal data structures during execution. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_BUS_STATS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_BUS_STATS"></a><a name="a__env__STARPU_BUS_STATS"></a> When defined, statistics about data transfers will be displayed when calling <a class="el" href="group__API__Initialization__and__Termination.html#ga48edf5e30e71fbb71923e3867ad16c0a">starpu_shutdown()</a> (<a class="el" href="CheckListWhenPerformanceAreNotThere.html#Profiling">Profiling</a>). By default, statistics are printed on the standard error stream, use the environement variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_BUS_STATS_FILE">STARPU_BUS_STATS_FILE</a> to define another filename. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_BUS_STATS_FILE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_BUS_STATS_FILE"></a><a name="a__env__STARPU_BUS_STATS_FILE"></a> Define the name of the file where to display data transfers statistics, see <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_BUS_STATS">STARPU_BUS_STATS</a>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_WORKER_STATS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_WORKER_STATS"></a><a name="a__env__STARPU_WORKER_STATS"></a> When defined, statistics about the workers will be displayed when calling <a class="el" href="group__API__Initialization__and__Termination.html#ga48edf5e30e71fbb71923e3867ad16c0a">starpu_shutdown()</a> (<a class="el" href="CheckListWhenPerformanceAreNotThere.html#Profiling">Profiling</a>). When combined with the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_PROFILING">STARPU_PROFILING</a>, it displays the energy consumption (<a class="el" href="Scheduling.html#Energy-basedScheduling">Energy-based Scheduling</a>). By default, statistics are printed on the standard error stream, use the environement variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WORKER_STATS_FILE">STARPU_WORKER_STATS_FILE</a> to define another filename. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_WORKER_STATS_FILE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_WORKER_STATS_FILE"></a><a name="a__env__STARPU_WORKER_STATS_FILE"></a> Define the name of the file where to display workers statistics, see <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WORKER_STATS">STARPU_WORKER_STATS</a>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_STATS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_STATS"></a><a name="a__env__STARPU_STATS"></a> When set to 0, data statistics will not be displayed at the end of the execution of an application (<a class="el" href="OfflinePerformanceTools.html#DataStatistics">Data Statistics</a>). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_WATCHDOG_TIMEOUT </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_WATCHDOG_TIMEOUT"></a><a name="a__env__STARPU_WATCHDOG_TIMEOUT"></a> When set to a value other than 0, allows to make StarPU print an error message whenever StarPU does not terminate any task for the given time (in µs), but lets the application continue normally. Should be used in combination with <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WATCHDOG_CRASH">STARPU_WATCHDOG_CRASH</a> (see <a class="el" href="CheckListWhenPerformanceAreNotThere.html#DetectionStuckConditions">Detecting Stuck Conditions</a>). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_WATCHDOG_CRASH </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_WATCHDOG_CRASH"></a><a name="a__env__STARPU_WATCHDOG_CRASH"></a> When set to a value other than 0, trigger a crash when the watch dog is reached, thus allowing to catch the situation in gdb, etc (see <a class="el" href="CheckListWhenPerformanceAreNotThere.html#DetectionStuckConditions">Detecting Stuck Conditions</a>) </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_WATCHDOG_DELAY </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_WATCHDOG_DELAY"></a><a name="a__env__STARPU_WATCHDOG_DELAY"></a> Delay the activation of the watchdog by the given time (in µs). This can be convenient for letting the application initialize data etc. before starting to look for idle time. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_TASK_PROGRESS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_TASK_PROGRESS"></a><a name="a__env__STARPU_TASK_PROGRESS"></a> Print the progression of tasks. This is convenient to determine whether a program is making progress in task execution, or is just stuck. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_TASK_BREAK_ON_PUSH </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_TASK_BREAK_ON_PUSH"></a><a name="a__env__STARPU_TASK_BREAK_ON_PUSH"></a> When this variable contains a job id, StarPU will raise SIGTRAP when the task with that job id is being pushed to the scheduler, which will be nicely catched by debuggers (see <a class="el" href="HowToDefineANewSchedulingPolicy.html#DebuggingScheduling">Debugging Scheduling</a>) </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_TASK_BREAK_ON_SCHED </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_TASK_BREAK_ON_SCHED"></a><a name="a__env__STARPU_TASK_BREAK_ON_SCHED"></a> When this variable contains a job id, StarPU will raise SIGTRAP when the task with that job id is being scheduled by the scheduler (at a scheduler-specific point), which will be nicely catched by debuggers. This only works for schedulers which have such a scheduling point defined (see <a class="el" href="HowToDefineANewSchedulingPolicy.html#DebuggingScheduling">Debugging Scheduling</a>) </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_TASK_BREAK_ON_POP </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_TASK_BREAK_ON_POP"></a><a name="a__env__STARPU_TASK_BREAK_ON_POP"></a> When this variable contains a job id, StarPU will raise SIGTRAP when the task with that job id is being popped from the scheduler, which will be nicely catched by debuggers (see <a class="el" href="HowToDefineANewSchedulingPolicy.html#DebuggingScheduling">Debugging Scheduling</a>) </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_TASK_BREAK_ON_EXEC </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_TASK_BREAK_ON_EXEC"></a><a name="a__env__STARPU_TASK_BREAK_ON_EXEC"></a> When this variable contains a job id, StarPU will raise SIGTRAP when the task with that job id is being executed, which will be nicely catched by debuggers (see <a class="el" href="HowToDefineANewSchedulingPolicy.html#DebuggingScheduling">Debugging Scheduling</a>) </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_DISABLE_KERNELS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_DISABLE_KERNELS"></a><a name="a__env__STARPU_DISABLE_KERNELS"></a> When set to a value other than 1, it disables actually calling the kernel functions, thus allowing to quickly check that the task scheme is working properly, without performing the actual application-provided computation. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_HISTORY_MAX_ERROR </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_HISTORY_MAX_ERROR"></a><a name="a__env__STARPU_HISTORY_MAX_ERROR"></a> History-based performance models will drop measurements which are really far froom the measured average. This specifies the allowed variation. The default is 50 (%), i.e. the measurement is allowed to be x1.5 faster or /1.5 slower than the average. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_RAND_SEED </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_RAND_SEED"></a><a name="a__env__STARPU_RAND_SEED"></a> The random scheduler and some examples use random numbers for their own working. Depending on the examples, the seed is by default juste always 0 or the current time() (unless SimGrid mode is enabled, in which case it is always 0). <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_RAND_SEED">STARPU_RAND_SEED</a> allows to set the seed to a specific value. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_IDLE_TIME </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_IDLE_TIME"></a><a name="a__env__STARPU_IDLE_TIME"></a> When set to a value being a valid filename, a corresponding file will be created when shutting down StarPU. The file will contain the sum of all the workers' idle time. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_GLOBAL_ARBITER </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_GLOBAL_ARBITER"></a><a name="a__env__STARPU_GLOBAL_ARBITER"></a> When set to a positive value, StarPU will create a arbiter, which implements an advanced but centralized management of concurrent data accesses (see <a class="el" href="DataManagement.html#ConcurrentDataAccess">Concurrent Data Accesses</a>). </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_USE_NUMA </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_USE_NUMA"></a><a name="a__env__STARPU_USE_NUMA"></a> When defined, NUMA nodes are taking into account by StarPU. Otherwise, memory is considered as only one node. This is experimental for now.</p>
<p>When enabled, STARPU_MAIN_MEMORY is a pointer to the NUMA node associated to the first CPU worker if it exists, the NUMA node associated to the first GPU discovered otherwise. If StarPU doesn't find any NUMA node after these step, STARPU_MAIN_MEMORY is the first NUMA node discovered by StarPU. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_IDLE_FILE </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_IDLE_FILE"></a><a name="a__env__STARPU_IDLE_FILE"></a> If the environment variable STARPU_IDLE_FILE is defined, a file named after its contents will be created at the end of the execution. The file will contain the sum of the idle times of all the workers. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_HWLOC_INPUT </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_HWLOC_INPUT"></a><a name="a__env__STARPU_HWLOC_INPUT"></a> If the environment variable STARPU_HWLOC_INPUT is defined to the path of an XML file, hwloc will be made to use it as input instead of detecting the current platform topology, which can save significant initialization time.</p>
<p>To produce this XML file, use <code>lstopo file.xml</code> </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_CATCH_SIGNALS </dt>
<dd><p class="startdd"><a class="anchor" id="STARPU_CATCH_SIGNALS"></a><a name="a__env__STARPU_CATCH_SIGNALS"></a> By default, StarPU catch signals SIGINT, SIGSEGV and SIGTRAP to perform final actions such as dumping FxT trace files even though the application has crashed. Setting this variable to a value other than 1 will disable this behaviour. This should be done on JVM systems which may use these signals for their own needs. The flag can also be set through the field <a class="el" href="group__API__Initialization__and__Termination.html#ae11cad1ceafab919d348de1f00b044d1">starpu_conf::catch_signals</a>. </p>
<p class="enddd"></p>
</dd>
<dt>STARPU_DISPLAY_BINDINGS </dt>
<dd><a class="anchor" id="STARPU_DISPLAY_BINDINGS"></a><a name="a__env__STARPU_DISPLAY_BINDINGS"></a> Display the binding of all processes and threads running on the machine. If MPI is enabled, display the binding of each node.<br />
 Users can manually display the binding by calling <a class="el" href="group__API__Miscellaneous__Helpers.html#ga30a209003955a8e4d528a3efa224a7d8">starpu_display_bindings()</a>.  </dd>
</dl>
<h1><a class="anchor" id="ConfiguringTheHypervisor"></a>
Configuring The Hypervisor</h1>
<dl>
<dt>SC_HYPERVISOR_POLICY </dt>
<dd><p class="startdd"><a class="anchor" id="SC_HYPERVISOR_POLICY"></a><a name="a__env__SC_HYPERVISOR_POLICY"></a> Choose between the different resizing policies proposed by StarPU for the hypervisor: idle, app_driven, feft_lp, teft_lp; ispeed_lp, throughput_lp etc.</p>
<p>Use <code>SC_HYPERVISOR_POLICY=help</code> to get the list of available policies for the hypervisor </p>
<p class="enddd"></p>
</dd>
<dt>SC_HYPERVISOR_TRIGGER_RESIZE </dt>
<dd><p class="startdd"><a class="anchor" id="SC_HYPERVISOR_TRIGGER_RESIZE"></a><a name="a__env__SC_HYPERVISOR_TRIGGER_RESIZE"></a> Choose how should the hypervisor be triggered: <code>speed</code> if the resizing algorithm should be called whenever the speed of the context does not correspond to an optimal precomputed value, <code>idle</code> it the resizing algorithm should be called whenever the workers are idle for a period longer than the value indicated when configuring the hypervisor. </p>
<p class="enddd"></p>
</dd>
<dt>SC_HYPERVISOR_START_RESIZE </dt>
<dd><p class="startdd"><a class="anchor" id="SC_HYPERVISOR_START_RESIZE"></a><a name="a__env__SC_HYPERVISOR_START_RESIZE"></a> Indicate the moment when the resizing should be available. The value correspond to the percentage of the total time of execution of the application. The default value is the resizing frame. </p>
<p class="enddd"></p>
</dd>
<dt>SC_HYPERVISOR_MAX_SPEED_GAP </dt>
<dd><p class="startdd"><a class="anchor" id="SC_HYPERVISOR_MAX_SPEED_GAP"></a><a name="a__env__SC_HYPERVISOR_MAX_SPEED_GAP"></a> Indicate the ratio of speed difference between contexts that should trigger the hypervisor. This situation may occur only when a theoretical speed could not be computed and the hypervisor has no value to compare the speed to. Otherwise the resizing of a context is not influenced by the the speed of the other contexts, but only by the the value that a context should have. </p>
<p class="enddd"></p>
</dd>
<dt>SC_HYPERVISOR_STOP_PRINT </dt>
<dd><p class="startdd"><a class="anchor" id="SC_HYPERVISOR_STOP_PRINT"></a><a name="a__env__SC_HYPERVISOR_STOP_PRINT"></a> By default the values of the speed of the workers is printed during the execution of the application. If the value 1 is given to this environment variable this printing is not done. </p>
<p class="enddd"></p>
</dd>
<dt>SC_HYPERVISOR_LAZY_RESIZE </dt>
<dd><p class="startdd"><a class="anchor" id="SC_HYPERVISOR_LAZY_RESIZE"></a><a name="a__env__SC_HYPERVISOR_LAZY_RESIZE"></a> By default the hypervisor resizes the contexts in a lazy way, that is workers are firstly added to a new context before removing them from the previous one. Once this workers are clearly taken into account into the new context (a task was poped there) we remove them from the previous one. However if the application would like that the change in the distribution of workers should change right away this variable should be set to 0 </p>
<p class="enddd"></p>
</dd>
<dt>SC_HYPERVISOR_SAMPLE_CRITERIA </dt>
<dd><p class="startdd"><a class="anchor" id="SC_HYPERVISOR_SAMPLE_CRITERIA"></a><a name="a__env__SC_HYPERVISOR_SAMPLE_CRITERIA"></a> By default the hypervisor uses a sample of flops when computing the speed of the contexts and of the workers. If this variable is set to <code>time</code> the hypervisor uses a sample of time (10% of an aproximation of the total execution time of the application) </p>
<p class="enddd"></p>
</dd>
</dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 22 2021 15:02:17 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
