<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StarPU Handbook: MPI Support</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('MPISupport.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">MPI Support </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The integration of MPI transfers within task parallelism is done in a very natural way by the means of asynchronous interactions between the application and StarPU. This is implemented in a separate <code>libstarpumpi</code> library which basically provides "StarPU" equivalents of <code>MPI_*</code> functions, where <code>void *</code> buffers are replaced with <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>, and all GPU-RAM-NIC transfers are handled efficiently by StarPU-MPI. The user has to use the usual <code>mpirun</code> command of the MPI implementation to start StarPU on the different MPI nodes.</p>
<p>In case the user wants to run several MPI processes by machine (e.g. one per NUMA node), <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WORKERS_GETBIND">STARPU_WORKERS_GETBIND</a> should be used to make StarPU take into account the binding set by the MPI launcher (otherwise each StarPU instance would try to bind on all cores of the machine...)</p>
<p>An MPI Insert Task function provides an even more seamless transition to a distributed application, by automatically issuing all required data transfers according to the task graph and an application-provided distribution.</p>
<h1><a class="anchor" id="MPIBuild"></a>
Building with MPI support</h1>
<p>If a <code>mpicc</code> compiler is already in your PATH, StarPU will automatically enable MPI support in the build. If <code>mpicc</code> is not in PATH, you can specify its location by passing <code>&ndash;with-mpicc=/where/there/is/mpicc</code> to <code>./configure</code></p>
<p>It can be useful to enable MPI tests during <code>make check</code> by passing <code>&ndash;enable-mpi-check</code> to <code>./configure</code>. And similarly to <code>mpicc</code>, if <code>mpiexec</code> in not in PATH, you can specify its location by passing <code>&ndash;with-mpiexec=/where/there/is/mpiexec</code> to <code>./configure</code>, but this is not needed if it is next to <code>mpicc</code>, configure will look there in addition to PATH.</p>
<p>Similarly, Fortran examples use <code>mpif90</code>, which can be specified manually with <code>&ndash;with-mpifort</code> if it can't be found automatically.</p>
<h1><a class="anchor" id="ExampleDocumentation"></a>
Example Used In This Documentation</h1>
<p>The example below will be used as the base for this documentation. It initializes a token on node 0, and the token is passed from node to node, incremented by one on each step. The code is not using StarPU yet.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (loop = 0; loop &lt; nloops; loop++)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> tag = loop*size + rank;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (loop == 0 &amp;&amp; rank == 0)</div><div class="line">    {</div><div class="line">        token = 0;</div><div class="line">        fprintf(stdout, <span class="stringliteral">&quot;Start with token value %d\n&quot;</span>, token);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        MPI_Recv(&amp;token, 1, MPI_INT, (rank+size-1)%size, tag, MPI_COMM_WORLD);</div><div class="line">    }</div><div class="line"></div><div class="line">    token++;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (loop == last_loop &amp;&amp; rank == last_rank)</div><div class="line">    {</div><div class="line">        fprintf(stdout, <span class="stringliteral">&quot;Finished: token value %d\n&quot;</span>, token);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        MPI_Send(&amp;token, 1, MPI_INT, (rank+1)%size, tag+1, MPI_COMM_WORLD);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="NotUsingMPISupport"></a>
About Not Using The MPI Support</h1>
<p>Although StarPU provides MPI support, the application programmer may want to keep his MPI communications as they are for a start, and only delegate task execution to StarPU. This is possible by just using <a class="el" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire()</a>, for instance:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (loop = 0; loop &lt; nloops; loop++)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> tag = loop*size + rank;</div><div class="line"></div><div class="line">    <span class="comment">/* Acquire the data to be able to write to it */</span></div><div class="line">    <a class="code" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire</a>(token_handle, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba628e5483f4cb6e44779aea39300dafed">STARPU_W</a>);</div><div class="line">    <span class="keywordflow">if</span> (loop == 0 &amp;&amp; rank == 0)</div><div class="line">    {</div><div class="line">        token = 0;</div><div class="line">        fprintf(stdout, <span class="stringliteral">&quot;Start with token value %d\n&quot;</span>, token);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        MPI_Recv(&amp;token, 1, MPI_INT, (rank+size-1)%size, tag, MPI_COMM_WORLD);</div><div class="line">    }</div><div class="line">        <a class="code" href="group__API__Data__Management.html#gadc145017bafa2948109c624715de77a2">starpu_data_release</a>(token_handle);</div><div class="line"></div><div class="line">    <span class="comment">/* Task delegation to StarPU to increment the token. The execution might</span></div><div class="line"><span class="comment">     * be performed on a CPU, a GPU, etc. */</span></div><div class="line">    increment_token();</div><div class="line"></div><div class="line">    <span class="comment">/* Acquire the update data to be able to read from it */</span></div><div class="line">    <a class="code" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire</a>(token_handle, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>);</div><div class="line">    <span class="keywordflow">if</span> (loop == last_loop &amp;&amp; rank == last_rank)</div><div class="line">    {</div><div class="line">        fprintf(stdout, <span class="stringliteral">&quot;Finished: token value %d\n&quot;</span>, token);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        MPI_Send(&amp;token, 1, MPI_INT, (rank+1)%size, tag+1, MPI_COMM_WORLD);</div><div class="line">    }</div><div class="line">        <a class="code" href="group__API__Data__Management.html#gadc145017bafa2948109c624715de77a2">starpu_data_release</a>(token_handle);</div><div class="line">}</div></div><!-- fragment --><p>In that case, <code>libstarpumpi</code> is not needed. One can also use <code>MPI_Isend()</code> and <code>MPI_Irecv()</code>, by calling <a class="el" href="group__API__Data__Management.html#gadc145017bafa2948109c624715de77a2">starpu_data_release()</a> after <code>MPI_Wait()</code> or <code>MPI_Test()</code> have notified completion.</p>
<p>It is however better to use <code>libstarpumpi</code>, to save the application from having to synchronize with <a class="el" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire()</a>, and instead just submit all tasks and communications asynchronously, and wait for the overall completion.</p>
<h1><a class="anchor" id="SimpleExample"></a>
Simple Example</h1>
<p>The flags required to compile or link against the MPI layer are accessible with the following commands:</p>
<pre class="fragment">$ pkg-config --cflags starpumpi-1.3  # options for the compiler
$ pkg-config --libs starpumpi-1.3    # options for the linker
</pre><div class="fragment"><div class="line"><span class="keywordtype">void</span> increment_token(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__task">starpu_task</a> *task = <a class="code" href="group__API__Codelet__And__Tasks.html#ga042d3b1b8083e49f2977f5032fda938c">starpu_task_create</a>();</div><div class="line"></div><div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#ac0e8ab897e436b244f13ec17b1191062">cl</a> = &amp;increment_cl;</div><div class="line">    task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#af3ce0252f1ac2238325033386a726df3">handles</a>[0] = token_handle;</div><div class="line"></div><div class="line">    <a class="code" href="group__API__Codelet__And__Tasks.html#gaa32228bf7f452f7d664986668ea46590">starpu_task_submit</a>(task);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> rank, size;</div><div class="line"></div><div class="line">    <a class="code" href="group__API__MPI__Support.html#gaec408170d2c815fdfdafa24873bc02da">starpu_mpi_init_conf</a>(&amp;argc, &amp;argv, 1, MPI_COMM_WORLD, NULL);</div><div class="line">    <a class="code" href="group__API__MPI__Support.html#ga67d1e5f67d39674590a2adc7c53ae185">starpu_mpi_comm_rank</a>(MPI_COMM_WORLD, &amp;rank);</div><div class="line">    <a class="code" href="group__API__MPI__Support.html#ga86e87daa9bce1f5f70cf6f61fdc709fd">starpu_mpi_comm_size</a>(MPI_COMM_WORLD, &amp;size);</div><div class="line"></div><div class="line">    <a class="code" href="group__API__Data__Interfaces.html#ga4248716bc322e1628b86365d7b9a8822">starpu_vector_data_register</a>(&amp;token_handle, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, (uintptr_t)&amp;token, 1, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> nloops = NITER;</div><div class="line">    <span class="keywordtype">unsigned</span> loop;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> last_loop = nloops - 1;</div><div class="line">    <span class="keywordtype">unsigned</span> last_rank = size - 1;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (loop = 0; loop &lt; nloops; loop++)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">int</span> tag = loop*size + rank;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (loop == 0 &amp;&amp; rank == 0)</div><div class="line">        {</div><div class="line">            <a class="code" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire</a>(token_handle, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba628e5483f4cb6e44779aea39300dafed">STARPU_W</a>);</div><div class="line">            token = 0;</div><div class="line">            fprintf(stdout, <span class="stringliteral">&quot;Start with token value %d\n&quot;</span>, token);</div><div class="line">            <a class="code" href="group__API__Data__Management.html#gadc145017bafa2948109c624715de77a2">starpu_data_release</a>(token_handle);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <a class="code" href="group__API__MPI__Support.html#ga360583f25937e671e88602f95dc2b6be">starpu_mpi_irecv_detached</a>(token_handle, (rank+size-1)%size, tag, MPI_COMM_WORLD, NULL, NULL);</div><div class="line">        }</div><div class="line"></div><div class="line">        increment_token();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (loop == last_loop &amp;&amp; rank == last_rank)</div><div class="line">        {</div><div class="line">            <a class="code" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire</a>(token_handle, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>);</div><div class="line">            fprintf(stdout, <span class="stringliteral">&quot;Finished: token value %d\n&quot;</span>, token);</div><div class="line">            <a class="code" href="group__API__Data__Management.html#gadc145017bafa2948109c624715de77a2">starpu_data_release</a>(token_handle);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <a class="code" href="group__API__MPI__Support.html#ga633d2e3fef4861042eb42e214efa2e43">starpu_mpi_isend_detached</a>(token_handle, (rank+1)%size, tag+1, MPI_COMM_WORLD, NULL, NULL);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="group__API__Codelet__And__Tasks.html#gad0baa8dbfd13e5a7bc3651bcd76022aa">starpu_task_wait_for_all</a>();</div><div class="line"></div><div class="line">    <a class="code" href="group__API__MPI__Support.html#ga87b22900dc132a958a0f7bce68d32153">starpu_mpi_shutdown</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (rank == last_rank)</div><div class="line">    {</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;[%d] token = %d == %d * %d ?\n&quot;</span>, rank, token, nloops, size);</div><div class="line">        <a class="code" href="group__API__Toolbox.html#ga05ac0dda104331f57d85823a4f9318ce">STARPU_ASSERT</a>(token == nloops*size);</div><div class="line">    }</div></div><!-- fragment --><p>We have here replaced <code>MPI_Recv()</code> and <code>MPI_Send()</code> with <a class="el" href="group__API__MPI__Support.html#ga360583f25937e671e88602f95dc2b6be">starpu_mpi_irecv_detached()</a> and <a class="el" href="group__API__MPI__Support.html#ga633d2e3fef4861042eb42e214efa2e43">starpu_mpi_isend_detached()</a>, which just submit the communication to be performed. The implicit sequential consistency dependencies provide synchronization between mpi reception and emission and the corresponding tasks. The only remaining synchronization with <a class="el" href="group__API__Data__Management.html#gae6eb535cf9bf46a7ef9ad2d845c675a2">starpu_data_acquire()</a> is at the beginning and the end.</p>
<h1><a class="anchor" id="MPIInitialization"></a>
How to Initialize StarPU-MPI</h1>
<p>As seen in the previous example, one has to call <a class="el" href="group__API__MPI__Support.html#gaec408170d2c815fdfdafa24873bc02da">starpu_mpi_init_conf()</a> to initialize StarPU-MPI. The third parameter of the function indicates if MPI should be initialized by StarPU or if the application did it itself. If the application initializes MPI itself, it must call <code>MPI_Init_thread()</code> with <code>MPI_THREAD_SERIALIZED</code> or <code>MPI_THREAD_MULTIPLE</code>, since StarPU-MPI uses a separate thread to perform the communications. <code>MPI_THREAD_MULTIPLE</code> is necessary if the application also performs some MPI communications.</p>
<h1><a class="anchor" id="PointToPointCommunication"></a>
Point To Point Communication</h1>
<p>The standard point to point communications of MPI have been implemented. The semantic is similar to the MPI one, but adapted to the DSM provided by StarPU. A MPI request will only be submitted when the data is available in the main memory of the node submitting the request.</p>
<p>There are two types of asynchronous communications: the classic asynchronous communications and the detached communications. The classic asynchronous communications (<a class="el" href="group__API__MPI__Support.html#ga8a87234302be78c7d77ce465b0e424e6">starpu_mpi_isend()</a> and <a class="el" href="group__API__MPI__Support.html#gab1cdef357b93d4f9f332199da819b792">starpu_mpi_irecv()</a>) need to be followed by a call to <a class="el" href="group__API__MPI__Support.html#gaad03f0a288bad79078045130b9a83188">starpu_mpi_wait()</a> or to <a class="el" href="group__API__MPI__Support.html#gae8e8389eb3e916131946028e9ebee670">starpu_mpi_test()</a> to wait for or to test the completion of the communication. Waiting for or testing the completion of detached communications is not possible, this is done internally by StarPU-MPI, on completion, the resources are automatically released. This mechanism is similar to the pthread detach state attribute which determines whether a thread will be created in a joinable or a detached state.</p>
<p>For send communications, data is acquired with the mode <a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>. When using the <code>configure</code> option <a class="el" href="CompilationConfiguration.html#enable-mpi-pedantic-isend">--enable-mpi-pedantic-isend</a>, the mode <a class="el" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba9fb7d314ccc154aead02dab90f8db52b">STARPU_RW</a> is used to make sure there is no more than 1 concurrent <code>MPI_Isend()</code> call accessing a data and StarPU does not read from it from tasks during the communication.</p>
<p>Internally, all communication are divided in 2 communications, a first message is used to exchange an envelope describing the data (i.e its tag and its size), the data itself is sent in a second message. All MPI communications submitted by StarPU uses a unique tag which has a default value, and can be accessed with the functions starpu_mpi_get_communication_tag() and starpu_mpi_set_communication_tag(). The matching of tags with corresponding requests is done within StarPU-MPI.</p>
<p>For any userland communication, the call of the corresponding function (e.g <a class="el" href="group__API__MPI__Support.html#ga8a87234302be78c7d77ce465b0e424e6">starpu_mpi_isend()</a>) will result in the creation of a StarPU-MPI request, the function <a class="el" href="group__API__Data__Management.html#ga358aba7459b7f99a6dbaa189ce57b925">starpu_data_acquire_cb()</a> is then called to asynchronously request StarPU to fetch the data in main memory; when the data is ready and the corresponding buffer has already been received by MPI, it will be copied in the memory of the data, otherwise the request is stored in the <em>early requests list</em>. Sending requests are stored in the <em>ready requests list</em>.</p>
<p>While requests need to be processed, the StarPU-MPI progression thread does the following:</p>
<ol>
<li>
it polls the <em>ready requests list</em>. For all the ready requests, the appropriate function is called to post the corresponding MPI call. For example, an initial call to <a class="el" href="group__API__MPI__Support.html#ga8a87234302be78c7d77ce465b0e424e6">starpu_mpi_isend()</a> will result in a call to <code>MPI_Isend()</code>. If the request is marked as detached, the request will then be added in the <em>detached requests list</em>.  </li>
<li>
it posts a <code>MPI_Irecv()</code> to retrieve a data envelope.  </li>
<li>
it polls the <em>detached requests list</em>. For all the detached requests, it tests its completion of the MPI request by calling <code>MPI_Test()</code>. On completion, the data handle is released, and if a callback was defined, it is called.  </li>
<li>
<p class="startli">finally, it checks if a data envelope has been received. If so, if the data envelope matches a request in the <em>early requests list</em> (i.e the request has already been posted by the application), the corresponding MPI call is posted (similarly to the first step above).</p>
<p class="endli">If the data envelope does not match any application request, a temporary handle is created to receive the data, a StarPU-MPI request is created and added into the <em>ready requests list</em>, and thus will be processed in the first step of the next loop.  </p>
</li>
</ol>
<p><a class="el" href="group__API__MPI__Support.html#MPIPtpCommunication">MPIPtpCommunication</a> gives the list of all the point to point communications defined in StarPU-MPI.</p>
<h1><a class="anchor" id="ExchangingUserDefinedDataInterface"></a>
Exchanging User Defined Data Interface</h1>
<p>New data interfaces defined as explained in <a class="el" href="DataManagement.html#DefiningANewDataInterface">Defining A New Data Interface</a> can also be used within StarPU-MPI and exchanged between nodes. Two functions needs to be defined through the type <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a>. The function <a class="el" href="group__API__Data__Interfaces.html#a5fed1490798c49a6f26c91f1bc4da360">starpu_data_interface_ops::pack_data</a> takes a handle and returns a contiguous memory buffer allocated with</p>
<div class="fragment"><div class="line"><a class="code" href="group__API__Standard__Memory__Library.html#gaebaa5a1503be11ba7da92f72a8e601b2">starpu_malloc_flags</a>(ptr, size, 0)</div></div><!-- fragment --><p>along with its size where data to be conveyed to another node should be copied.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> complex_pack_data(<a class="code" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> handle, <span class="keywordtype">unsigned</span> node, <span class="keywordtype">void</span> **ptr, ssize_t *count)</div><div class="line">{</div><div class="line">    <a class="code" href="group__API__Toolbox.html#ga05ac0dda104331f57d85823a4f9318ce">STARPU_ASSERT</a>(starpu_data_test_if_allocated_on_node(handle, node));</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>starpu_complex_interface *complex_interface = (<span class="keyword">struct </span>starpu_complex_interface *) <a class="code" href="group__API__Data__Interfaces.html#ga357281162710186412327c17f4a63535">starpu_data_get_interface_on_node</a>(handle, node);</div><div class="line"></div><div class="line">    *count = complex_get_size(handle);</div><div class="line">    *ptr = <a class="code" href="group__API__Data__Interfaces.html#gab2bf7713cad5570775bdf4efec79502d">starpu_malloc_on_node_flags</a>(node, *count, 0);</div><div class="line">    memcpy(*ptr, complex_interface-&gt;real, complex_interface-&gt;nx*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div><div class="line">    memcpy(*ptr+complex_interface-&gt;nx*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>), complex_interface-&gt;imaginary, complex_interface-&gt;nx*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The inverse operation is implemented in the function <a class="el" href="group__API__Data__Interfaces.html#ab997f2654cd769dbd3413f5a90090a69">starpu_data_interface_ops::unpack_data</a> which takes a contiguous memory buffer and recreates the data handle.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> complex_unpack_data(<a class="code" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> handle, <span class="keywordtype">unsigned</span> node, <span class="keywordtype">void</span> *ptr, <span class="keywordtype">size_t</span> count)</div><div class="line">{</div><div class="line">    <a class="code" href="group__API__Toolbox.html#ga05ac0dda104331f57d85823a4f9318ce">STARPU_ASSERT</a>(starpu_data_test_if_allocated_on_node(handle, node));</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>starpu_complex_interface *complex_interface = (<span class="keyword">struct </span>starpu_complex_interface *) <a class="code" href="group__API__Data__Interfaces.html#ga357281162710186412327c17f4a63535">starpu_data_get_interface_on_node</a>(handle, node);</div><div class="line"></div><div class="line">    memcpy(complex_interface-&gt;real, ptr, complex_interface-&gt;nx*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div><div class="line">    memcpy(complex_interface-&gt;imaginary, ptr+complex_interface-&gt;nx*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>), complex_interface-&gt;nx*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> interface_complex_ops =</div><div class="line">{</div><div class="line">    ...</div><div class="line">    .<a class="code" href="group__API__Data__Interfaces.html#a5fed1490798c49a6f26c91f1bc4da360">pack_data</a> = complex_pack_data,</div><div class="line">    .unpack_data = complex_unpack_data</div><div class="line">};</div></div><!-- fragment --><p>Instead of defining pack and unpack operations, users may want to attach a MPI type to their user-defined data interface. The function <a class="el" href="group__API__MPI__Support.html#ga417db8086f6f19b750e7829ba725c3d3">starpu_mpi_interface_datatype_register()</a> allows to do so. This function takes 3 parameters: the interface ID for which the MPI datatype is going to be defined, a function's pointer that will create the MPI datatype, and a function's pointer that will free the MPI datatype. If for some data an MPI datatype can not be built (e.g. complex data structure), the creation function can return -1, StarPU-MPI will then fallback to using pack/unpack.</p>
<p>The functions to create and free the MPI datatype are defined and registered as follows.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> starpu_complex_interface_datatype_allocate(<a class="code" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> handle, MPI_Datatype *mpi_datatype)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> ret;</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> blocklengths[2];</div><div class="line">    MPI_Aint displacements[2];</div><div class="line">    MPI_Datatype types[2] = {MPI_DOUBLE, MPI_DOUBLE};</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>starpu_complex_interface *complex_interface = (<span class="keyword">struct </span>starpu_complex_interface *) <a class="code" href="group__API__Data__Interfaces.html#ga357281162710186412327c17f4a63535">starpu_data_get_interface_on_node</a>(handle, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>);</div><div class="line"></div><div class="line">    MPI_Get_address(complex_interface, displacements);</div><div class="line">    MPI_Get_address(&amp;complex_interface-&gt;imaginary, displacements+1);</div><div class="line">    displacements[1] -= displacements[0];</div><div class="line">    displacements[0] = 0;</div><div class="line"></div><div class="line">    blocklengths[0] = complex_interface-&gt;nx;</div><div class="line">    blocklengths[1] = complex_interface-&gt;nx;</div><div class="line"></div><div class="line">    ret = MPI_Type_create_struct(2, blocklengths, displacements, types, mpi_datatype);</div><div class="line">    <a class="code" href="group__API__Toolbox.html#gabb6941113e19ee4045a014943cd62aae">STARPU_ASSERT_MSG</a>(ret == MPI_SUCCESS, <span class="stringliteral">&quot;MPI_Type_contiguous failed&quot;</span>);</div><div class="line"></div><div class="line">    ret = MPI_Type_commit(mpi_datatype);</div><div class="line">    <a class="code" href="group__API__Toolbox.html#gabb6941113e19ee4045a014943cd62aae">STARPU_ASSERT_MSG</a>(ret == MPI_SUCCESS, <span class="stringliteral">&quot;MPI_Type_commit failed&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> starpu_complex_interface_datatype_free(MPI_Datatype *mpi_datatype)</div><div class="line">{</div><div class="line">    MPI_Type_free(mpi_datatype);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> interface_complex_ops =</div><div class="line">{</div><div class="line">    ...</div><div class="line">};</div><div class="line"></div><div class="line">interface_complex_ops.<a class="code" href="group__API__Data__Interfaces.html#a755b7d337f0ac2bdf8752bba1039e1b4">interfaceid</a> = <a class="code" href="group__API__Data__Interfaces.html#gaf5ea640f2c977e3ae95a6be9b3be3bee">starpu_data_interface_get_next_id</a>();</div><div class="line"></div><div class="line"><a class="code" href="group__API__MPI__Support.html#ga417db8086f6f19b750e7829ba725c3d3">starpu_mpi_interface_datatype_register</a>(interface_complex_ops.<a class="code" href="group__API__Data__Interfaces.html#a755b7d337f0ac2bdf8752bba1039e1b4">interfaceid</a>, starpu_complex_interface_datatype_allocate, starpu_complex_interface_datatype_free);</div><div class="line"></div><div class="line">starpu_data_interface handle;</div><div class="line">starpu_complex_data_register(&amp;handle, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, real, imaginary, 2);</div><div class="line">...</div></div><!-- fragment --><p>It is also possible to use <a class="el" href="group__API__MPI__Support.html#gaf9345fd74fd060cc6712457e711b29c1">starpu_mpi_datatype_register()</a> to register the functions through a handle rather than the interface ID, but note that in that case it is important to make sure no communication is going to occur before the function <a class="el" href="group__API__MPI__Support.html#gaf9345fd74fd060cc6712457e711b29c1">starpu_mpi_datatype_register()</a> is called. This would otherwise produce an undefined result as the data may be received before the function is called, and so the MPI datatype would not be known by the StarPU-MPI communication engine, and the data would be processed with the pack and unpack operations. One would thus need to synchronize all nodes:</p>
<div class="fragment"><div class="line">starpu_data_interface handle;</div><div class="line">starpu_complex_data_register(&amp;handle, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, real, imaginary, 2);</div><div class="line"><a class="code" href="group__API__MPI__Support.html#gaf9345fd74fd060cc6712457e711b29c1">starpu_mpi_datatype_register</a>(handle, starpu_complex_interface_datatype_allocate, starpu_complex_interface_datatype_free);</div><div class="line"></div><div class="line"><a class="code" href="group__API__MPI__Support.html#ga77aa675b91da2a069caeebdb11a3edc9">starpu_mpi_barrier</a>(MPI_COMM_WORLD);</div></div><!-- fragment --><h1><a class="anchor" id="MPIInsertTaskUtility"></a>
MPI Insert Task Utility</h1>
<p>To save the programmer from having to explicit all communications, StarPU provides an "MPI Insert Task Utility". The principe is that the application decides a distribution of the data over the MPI nodes by allocating it and notifying StarPU of this decision, i.e. tell StarPU which MPI node "owns" which data. It also decides, for each handle, an MPI tag which will be used to exchange the content of the handle. All MPI nodes then process the whole task graph, and StarPU automatically determines which node actually execute which task, and trigger the required MPI transfers.</p>
<p>The list of functions is described in <a class="el" href="group__API__MPI__Support.html#MPIInsertTask">MPIInsertTask</a>.</p>
<p>Here an stencil example showing how to use <a class="el" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert()</a>. One first needs to define a distribution function which specifies the locality of the data. Note that the data needs to be registered to MPI by calling <a class="el" href="group__API__MPI__Support.html#ga747d8cbed76750c03031062f62824e3e">starpu_mpi_data_register()</a>. This function allows to set the distribution information and the MPI tag which should be used when communicating the data. It also allows to automatically clear the MPI communication cache when unregistering the data.</p>
<div class="fragment"><div class="line"><span class="comment">/* Returns the MPI node number where data is */</span></div><div class="line"><span class="keywordtype">int</span> my_distrib(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> nb_nodes)</div><div class="line">{</div><div class="line">  <span class="comment">/* Block distrib */</span></div><div class="line">  <span class="keywordflow">return</span> ((<span class="keywordtype">int</span>)(x / sqrt(nb_nodes) + (y / sqrt(nb_nodes)) * sqrt(nb_nodes))) % nb_nodes;</div><div class="line"></div><div class="line">  <span class="comment">// /* Other examples useful for other kinds of computations */</span></div><div class="line">  <span class="comment">// /* / distrib */</span></div><div class="line">  <span class="comment">// return (x+y) % nb_nodes;</span></div><div class="line"></div><div class="line">  <span class="comment">// /* Block cyclic distrib */</span></div><div class="line">  <span class="comment">// unsigned side = sqrt(nb_nodes);</span></div><div class="line">  <span class="comment">// return x % side + (y % side) * size;</span></div><div class="line">}</div></div><!-- fragment --><p>Now the data can be registered within StarPU. Data which are not owned but will be needed for computations can be registered through the lazy allocation mechanism, i.e. with a <code>home_node</code> set to <code>-1</code>. StarPU will automatically allocate the memory when it is used for the first time.</p>
<p>One can note an optimization here (the <code>else if</code> test): we only register data which will be needed by the tasks that we will execute.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> matrix[X][Y];</div><div class="line"><a class="code" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> data_handles[X][Y];</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(x = 0; x &lt; X; x++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (y = 0; y &lt; Y; y++)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">int</span> mpi_rank = my_distrib(x, y, size);</div><div class="line">        <span class="keywordflow">if</span> (mpi_rank == my_rank)</div><div class="line">            <span class="comment">/* Owning data */</span></div><div class="line">            <a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data_handles[x][y], <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, (uintptr_t)&amp;(matrix[x][y]), <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (my_rank == my_distrib(x+1, y, size) || my_rank == my_distrib(x-1, y, size)</div><div class="line">              || my_rank == my_distrib(x, y+1, size) || my_rank == my_distrib(x, y-1, size))</div><div class="line">            <span class="comment">/* I don&#39;t own this index, but will need it for my computations */</span></div><div class="line">            <a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data_handles[x][y], -1, (uintptr_t)NULL, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            <span class="comment">/* I know it&#39;s useless to allocate anything for this */</span></div><div class="line">            data_handles[x][y] = NULL;</div><div class="line">        <span class="keywordflow">if</span> (data_handles[x][y])</div><div class="line">        {</div><div class="line">            <a class="code" href="group__API__MPI__Support.html#ga747d8cbed76750c03031062f62824e3e">starpu_mpi_data_register</a>(data_handles[x][y], x*X+y, mpi_rank);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Now <a class="el" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert()</a> can be called for the different steps of the application.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(loop=0 ; loop&lt;niter; loop++)</div><div class="line">    <span class="keywordflow">for</span> (x = 1; x &lt; X-1; x++)</div><div class="line">        <span class="keywordflow">for</span> (y = 1; y &lt; Y-1; y++)</div><div class="line">            <a class="code" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert</a>(MPI_COMM_WORLD, &amp;stencil5_cl,</div><div class="line">                                   STARPU_RW, data_handles[x][y],</div><div class="line">                                   <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, data_handles[x-1][y],</div><div class="line">                                   <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, data_handles[x+1][y],</div><div class="line">                                   <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, data_handles[x][y-1],</div><div class="line">                                   <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, data_handles[x][y+1],</div><div class="line">                                   0);</div><div class="line"><a class="code" href="group__API__Codelet__And__Tasks.html#gad0baa8dbfd13e5a7bc3651bcd76022aa">starpu_task_wait_for_all</a>();</div></div><!-- fragment --><p>I.e. all MPI nodes process the whole task graph, but as mentioned above, for each task, only the MPI node which owns the data being written to (here, <code>data_handles[x][y]</code>) will actually run the task. The other MPI nodes will automatically send the required data.</p>
<p>To tune the placement of tasks among MPI nodes, one can use <a class="el" href="group__API__MPI__Support.html#ga750b87a6ea137c903f02c53029d1131d">STARPU_EXECUTE_ON_NODE</a> or <a class="el" href="group__API__MPI__Support.html#gadc9112873f348b1f6daa0da4b93b061f">STARPU_EXECUTE_ON_DATA</a> to specify an explicit node, or the node of a given data (e.g. one of the parameters), or use <a class="el" href="group__API__MPI__Support.html#gab69b1f823043d16b7d0d799d1ad88a04">starpu_mpi_node_selection_register_policy()</a> and <a class="el" href="group__API__MPI__Support.html#gadd2fd077198e6938baf63ae788f6941a">STARPU_NODE_SELECTION_POLICY</a> to provide a dynamic policy.</p>
<p>A function <a class="el" href="group__API__MPI__Support.html#ga997b3816848ab61e8b90c6fcca8a33b3">starpu_mpi_task_build()</a> is also provided with the aim to only construct the task structure. All MPI nodes need to call the function, which posts the required send/recv on the various nodes which have to. Only the node which is to execute the task will then return a valid task structure, others will return <code>NULL</code>. This node must submit the task. All nodes then need to call the function <a class="el" href="group__API__MPI__Support.html#ga9c609f3cc579af484808b3e1b8b787d9">starpu_mpi_task_post_build()</a> &ndash; with the same list of arguments as <a class="el" href="group__API__MPI__Support.html#ga997b3816848ab61e8b90c6fcca8a33b3">starpu_mpi_task_build()</a> &ndash; to post all the necessary data communications meant to happen after the task execution.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__task">starpu_task</a> *task;</div><div class="line">task = <a class="code" href="group__API__MPI__Support.html#ga997b3816848ab61e8b90c6fcca8a33b3">starpu_mpi_task_build</a>(MPI_COMM_WORLD, &amp;cl,</div><div class="line">                             STARPU_RW, data_handles[0],</div><div class="line">                             <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, data_handles[1],</div><div class="line">                             0);</div><div class="line"><span class="keywordflow">if</span> (task) <a class="code" href="group__API__Codelet__And__Tasks.html#gaa32228bf7f452f7d664986668ea46590">starpu_task_submit</a>(task);</div><div class="line"><a class="code" href="group__API__MPI__Support.html#ga9c609f3cc579af484808b3e1b8b787d9">starpu_mpi_task_post_build</a>(MPI_COMM_WORLD, &amp;cl,</div><div class="line">                           STARPU_RW, data_handles[0],</div><div class="line">                           <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, data_handles[1],</div><div class="line">                           0);</div></div><!-- fragment --><h1><a class="anchor" id="MPIInsertPruning"></a>
Pruning MPI Task Insertion</h1>
<p>Making all MPI nodes process the whole graph can be a concern with a growing number of nodes. To avoid this, the application can prune the task for loops according to the data distribution, so as to only submit tasks on nodes which have to care about them (either to execute them, or to send the required data).</p>
<p>A way to do some of this quite easily can be to just add an <code>if</code> like this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(loop=0 ; loop&lt;niter; loop++)</div><div class="line">    <span class="keywordflow">for</span> (x = 1; x &lt; X-1; x++)</div><div class="line">        <span class="keywordflow">for</span> (y = 1; y &lt; Y-1; y++)</div><div class="line">            <span class="keywordflow">if</span> (my_distrib(x,y,size) == my_rank</div><div class="line">             || my_distrib(x-1,y,size) == my_rank</div><div class="line">             || my_distrib(x+1,y,size) == my_rank</div><div class="line">             || my_distrib(x,y-1,size) == my_rank</div><div class="line">             || my_distrib(x,y+1,size) == my_rank)</div><div class="line">                <a class="code" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert</a>(MPI_COMM_WORLD, &amp;stencil5_cl,</div><div class="line">                                       STARPU_RW, data_handles[x][y],</div><div class="line">                                       <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, data_handles[x-1][y],</div><div class="line">                                       <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, data_handles[x+1][y],</div><div class="line">                                       <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, data_handles[x][y-1],</div><div class="line">                                       <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, data_handles[x][y+1],</div><div class="line">                                       0);</div><div class="line"><a class="code" href="group__API__Codelet__And__Tasks.html#gad0baa8dbfd13e5a7bc3651bcd76022aa">starpu_task_wait_for_all</a>();</div></div><!-- fragment --><p>This permits to drop the cost of function call argument passing and parsing.</p>
<p>If the <code>my_distrib</code> function can be inlined by the compiler, the latter can improve the test.</p>
<p>If the <code>size</code> can be made a compile-time constant, the compiler can considerably improve the test further.</p>
<p>If the distribution function is not too complex and the compiler is very good, the latter can even optimize the <code>for</code> loops, thus dramatically reducing the cost of task submission.</p>
<p>To estimate quickly how long task submission takes, and notably how much pruning saves, a quick and easy way is to measure the submission time of just one of the MPI nodes. This can be achieved by running the application on just one MPI node with the following environment variables:</p>
<div class="fragment"><div class="line">export STARPU_DISABLE_KERNELS=1</div><div class="line">export STARPU_MPI_FAKE_RANK=2</div><div class="line">export STARPU_MPI_FAKE_SIZE=1024</div></div><!-- fragment --><p>Here we have disabled the kernel function call to skip the actual computation time and only keep submission time, and we have asked StarPU to fake running on MPI node 2 out of 1024 nodes.</p>
<h1><a class="anchor" id="MPITemporaryData"></a>
Temporary Data</h1>
<p>To be able to use <a class="el" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert()</a>, one has to call <a class="el" href="group__API__MPI__Support.html#ga747d8cbed76750c03031062f62824e3e">starpu_mpi_data_register()</a>, so that StarPU-MPI can know what it needs to do for each data. Parameters of <a class="el" href="group__API__MPI__Support.html#ga747d8cbed76750c03031062f62824e3e">starpu_mpi_data_register()</a> are normally the same on all nodes for a given data, so that all nodes agree on which node owns the data, and which tag is used to transfer its value.</p>
<p>It can however be useful to register e.g. some temporary data on just one node, without having to register a dumb handle on all nodes, while only one node will actually need to know about it. In this case, nodes which will not need the data can just pass <code>NULL</code> to <a class="el" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert()</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> data0 = NULL;</div><div class="line"><span class="keywordflow">if</span> (rank == 0)</div><div class="line">{</div><div class="line">        <a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data0, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, (uintptr_t) &amp;val0, <span class="keyword">sizeof</span>(val0));</div><div class="line">        <a class="code" href="group__API__MPI__Support.html#ga747d8cbed76750c03031062f62824e3e">starpu_mpi_data_register</a>(data0, 0, rank);</div><div class="line">}</div><div class="line"><a class="code" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert</a>(MPI_COMM_WORLD, &amp;cl, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba628e5483f4cb6e44779aea39300dafed">STARPU_W</a>, data0, 0); <span class="comment">/* Executes on node 0 */</span></div></div><!-- fragment --><p>Here, nodes whose rank is not <code>0</code> will simply not take care of the data, and consider it to be on another node.</p>
<p>This can be mixed various way, for instance here node <code>1</code> determines that it does not have to care about <code>data0</code>, but knows that it should send the value of its <code>data1</code> to node <code>0</code>, which owns data and thus will need the value of <code>data1</code> to execute the task:</p>
<div class="fragment"><div class="line"><a class="code" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> data0 = NULL, data1, data;</div><div class="line"><span class="keywordflow">if</span> (rank == 0)</div><div class="line">{</div><div class="line">        <a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data0, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, (uintptr_t) &amp;val0, <span class="keyword">sizeof</span>(val0));</div><div class="line">        <a class="code" href="group__API__MPI__Support.html#ga747d8cbed76750c03031062f62824e3e">starpu_mpi_data_register</a>(data0, -1, rank);</div><div class="line">        <a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data1, -1, 0, <span class="keyword">sizeof</span>(val1));</div><div class="line">        <a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, (uintptr_t) &amp;val, <span class="keyword">sizeof</span>(val));</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (rank == 1)</div><div class="line">{</div><div class="line">        <a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data1, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, (uintptr_t) &amp;val1, <span class="keyword">sizeof</span>(val1));</div><div class="line">        <a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data, -1, 0, <span class="keyword">sizeof</span>(val));</div><div class="line">}</div><div class="line"><a class="code" href="group__API__MPI__Support.html#ga747d8cbed76750c03031062f62824e3e">starpu_mpi_data_register</a>(data, 42, 0);</div><div class="line"><a class="code" href="group__API__MPI__Support.html#ga747d8cbed76750c03031062f62824e3e">starpu_mpi_data_register</a>(data1, 43, 1);</div><div class="line"><a class="code" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert</a>(MPI_COMM_WORLD, &amp;cl, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba628e5483f4cb6e44779aea39300dafed">STARPU_W</a>, data, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, data0, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, data1, 0); <span class="comment">/* Executes on node 0 */</span></div></div><!-- fragment --><h1><a class="anchor" id="MPIPerNodeData"></a>
Per-node Data</h1>
<p>Further than temporary data on just one node, one may want per-node data, to e.g. replicate some computation because that is less expensive than communicating the value over MPI:</p>
<div class="fragment"><div class="line">starpu_data_handle pernode, data0, data1;</div><div class="line"><a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;pernode, -1, 0, <span class="keyword">sizeof</span>(val));</div><div class="line"><a class="code" href="group__API__MPI__Support.html#ga747d8cbed76750c03031062f62824e3e">starpu_mpi_data_register</a>(pernode, -1, <a class="code" href="group__API__MPI__Support.html#ga04576f1478a0416cd838c01269ba31a5">STARPU_MPI_PER_NODE</a>);</div><div class="line"></div><div class="line"><span class="comment">/* Normal data: one on node0, one on node1 */</span></div><div class="line"><span class="keywordflow">if</span> (rank == 0)</div><div class="line">{</div><div class="line">        <a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data0, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, (uintptr_t) &amp;val0, <span class="keyword">sizeof</span>(val0));</div><div class="line">        <a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data1, -1, 0, <span class="keyword">sizeof</span>(val1));</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (rank == 1)</div><div class="line">{</div><div class="line">        <a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data0, -1, 0, <span class="keyword">sizeof</span>(val1));</div><div class="line">        <a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data1, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, (uintptr_t) &amp;val1, <span class="keyword">sizeof</span>(val1));</div><div class="line">}</div><div class="line"><a class="code" href="group__API__MPI__Support.html#ga747d8cbed76750c03031062f62824e3e">starpu_mpi_data_register</a>(data0, 42, 0);</div><div class="line"><a class="code" href="group__API__MPI__Support.html#ga747d8cbed76750c03031062f62824e3e">starpu_mpi_data_register</a>(data1, 43, 1);</div><div class="line"></div><div class="line"><a class="code" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert</a>(MPI_COMM_WORLD, &amp;cl, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba628e5483f4cb6e44779aea39300dafed">STARPU_W</a>, pernode, 0); <span class="comment">/* Will be replicated on all nodes */</span></div><div class="line"></div><div class="line"><a class="code" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert</a>(MPI_COMM_WORLD, &amp;cl2, STARPU_RW, data0, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, pernode); <span class="comment">/* Will execute on node 0, using its own pernode*/</span></div><div class="line"><a class="code" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert</a>(MPI_COMM_WORLD, &amp;cl2, STARPU_RW, data1, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dbaab55b4cef9cfedeacae7012cd52e5389">STARPU_R</a>, pernode); <span class="comment">/* Will execute on node 1, using its own pernode*/</span></div></div><!-- fragment --><p>One can turn a normal data into pernode data, by first broadcasting it to all nodes:</p>
<div class="fragment"><div class="line">starpu_data_handle data;</div><div class="line"><a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data, -1, 0, <span class="keyword">sizeof</span>(val));</div><div class="line"><a class="code" href="group__API__MPI__Support.html#ga747d8cbed76750c03031062f62824e3e">starpu_mpi_data_register</a>(data, 42, 0);</div><div class="line"></div><div class="line"><span class="comment">/* Compute some value */</span></div><div class="line"><a class="code" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert</a>(MPI_COMM_WORLD, &amp;cl, <a class="code" href="group__API__Data__Management.html#gga1fb3a1ff8622747d653d1b5f41bc41dba628e5483f4cb6e44779aea39300dafed">STARPU_W</a>, data, 0); <span class="comment">/* Node 0 computes it */</span></div><div class="line"></div><div class="line"><span class="comment">/* Get it on all nodes */</span></div><div class="line"><a class="code" href="group__API__MPI__Support.html#gaebb931d03782a5b77a5bf3f6df3bf3f7">starpu_mpi_get_data_on_all_nodes_detached</a>(MPI_COMM_WORLD, data);</div><div class="line"><span class="comment">/* And turn it per-node */</span></div><div class="line"><a class="code" href="group__API__MPI__Support.html#ga79ca5db23d267ee7c199864993e434a9">starpu_mpi_data_set_rank</a>(data, <a class="code" href="group__API__MPI__Support.html#ga04576f1478a0416cd838c01269ba31a5">STARPU_MPI_PER_NODE</a>);</div></div><!-- fragment --><p>The data can then be used just like pernode above.</p>
<h1><a class="anchor" id="MPIPriorities"></a>
Priorities</h1>
<p>All send functions have a <code>_prio</code> variant which takes an additional priority parameter, which allows to make StarPU-MPI change the order of MPI requests before submitting them to MPI. The default priority is <code>0</code>.</p>
<p>When using the <a class="el" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert()</a> helper, <a class="el" href="group__API__Insert__Task.html#gab9d32b41f7fbae16e9ed2331f6dde8ac">STARPU_PRIORITY</a> defines both the task priority and the MPI requests priority.</p>
<p>To test how much MPI priorities have a good effect on performance, you can set the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_PRIORITIES">STARPU_MPI_PRIORITIES</a> to <code>0</code> to disable the use of priorities in StarPU-MPI.</p>
<h1><a class="anchor" id="MPICache"></a>
MPI Cache Support</h1>
<p>StarPU-MPI automatically optimizes duplicate data transmissions: if an MPI node <code>B</code> needs a piece of data <code>D</code> from MPI node <code>A</code> for several tasks, only one transmission of <code>D</code> will take place from <code>A</code> to <code>B</code>, and the value of <code>D</code> will be kept on <code>B</code> as long as no task modifies <code>D</code>.</p>
<p>If a task modifies <code>D</code>, <code>B</code> will wait for all tasks which need the previous value of <code>D</code>, before invalidating the value of <code>D</code>. As a consequence, it releases the memory occupied by <code>D</code>. Whenever a task running on <code>B</code> needs the new value of <code>D</code>, allocation will take place again to receive it.</p>
<p>Since tasks can be submitted dynamically, StarPU-MPI can not know whether the current value of data <code>D</code> will again be used by a newly-submitted task before being modified by another newly-submitted task, so until a task is submitted to modify the current value, it can not decide by itself whether to flush the cache or not. The application can however explicitly tell StarPU-MPI to flush the cache by calling <a class="el" href="group__API__MPI__Support.html#gacb05635d95f946f099a1772c8bd59c8b">starpu_mpi_cache_flush()</a> or <a class="el" href="group__API__MPI__Support.html#gadf1f289d1cf35bd31df930bc347fb9ce">starpu_mpi_cache_flush_all_data()</a>, for instance in case the data will not be used at all any more (see for instance the cholesky example in <code>mpi/examples/matrix_decomposition</code>), or at least not in the close future. If a newly-submitted task actually needs the value again, another transmission of <code>D</code> will be initiated from <code>A</code> to <code>B</code>. A mere <a class="el" href="group__API__MPI__Support.html#gadf1f289d1cf35bd31df930bc347fb9ce">starpu_mpi_cache_flush_all_data()</a> can for instance be added at the end of the whole algorithm, to express that no data will be reused after this (or at least that it is not interesting to keep them in cache). It may however be interesting to add fine-graph <a class="el" href="group__API__MPI__Support.html#gacb05635d95f946f099a1772c8bd59c8b">starpu_mpi_cache_flush()</a> calls during the algorithm; the effect for the data deallocation will be the same, but it will additionally release some pressure from the StarPU-MPI cache hash table during task submission.</p>
<p>One can determine whether a piece of data is cached with <a class="el" href="group__API__MPI__Support.html#ga3607196b2c55521e1dae06905dc0d761">starpu_mpi_cached_receive()</a> and <a class="el" href="group__API__MPI__Support.html#ga92cfdb836f55af9d449baa5e93035963">starpu_mpi_cached_send()</a>.</p>
<p>Functions <a class="el" href="group__API__MPI__Support.html#gaee6045677d02bc11f83cf00c723562b3">starpu_mpi_cached_receive_set()</a> and <a class="el" href="group__API__MPI__Support.html#gaf420b44479ae98b774be21a52c0ab931">starpu_mpi_cached_send_set()</a> are automatically called by <a class="el" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert()</a> but can also be called directly by the application. Functions <a class="el" href="group__API__MPI__Support.html#ga9fd0b3f164f98dd59fe52d91868c9709">starpu_mpi_cached_send_clear()</a> and <a class="el" href="group__API__MPI__Support.html#ga8feb9c0731bffe27cd7b55b11085d21c">starpu_mpi_cached_receive_clear()</a> must be called to clear data from the cache. They are also automatically called when using <a class="el" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert()</a>.</p>
<p>The whole caching behavior can be disabled thanks to the <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_CACHE">STARPU_MPI_CACHE</a> environment variable. The variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_CACHE_STATS">STARPU_MPI_CACHE_STATS</a> can be set to <code>1</code> to enable the runtime to display messages when data are added or removed from the cache holding the received data.</p>
<h1><a class="anchor" id="MPIMigration"></a>
MPI Data Migration</h1>
<p>The application can dynamically change its mind about the data distribution, to balance the load over MPI nodes for instance. This can be done very simply by requesting an explicit move and then change the registered rank. For instance, we here switch to a new distribution function <code>my_distrib2</code>: we first register any data which wasn't registered already and will be needed, then migrate the data, and register the new location.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(x = 0; x &lt; X; x++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (y = 0; y &lt; Y; y++)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">int</span> mpi_rank = my_distrib2(x, y, size);</div><div class="line">        <span class="keywordflow">if</span> (!data_handles[x][y] &amp;&amp; (mpi_rank == my_rank</div><div class="line">              || my_rank == my_distrib(x+1, y, size) || my_rank == my_distrib(x-1, y, size)</div><div class="line">              || my_rank == my_distrib(x, y+1, size) || my_rank == my_distrib(x, y-1, size)))</div><div class="line">            <span class="comment">/* Register newly-needed data */</span></div><div class="line">            <a class="code" href="group__API__Data__Interfaces.html#gafb92c2538dc629d823221c5dc16bd767">starpu_variable_data_register</a>(&amp;data_handles[x][y], -1, (uintptr_t)NULL, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>));</div><div class="line">        <span class="keywordflow">if</span> (data_handles[x][y])</div><div class="line">        {</div><div class="line">            <span class="comment">/* Migrate the data */</span></div><div class="line">            <a class="code" href="group__API__MPI__Support.html#ga6ebb836a816647d2f00977ea749e53bc">starpu_mpi_data_migrate</a>(MPI_COMM_WORLD, data_handles[x][y], mpi_rank);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>From then on, further tasks submissions will use the new data distribution, which will thus change both MPI communications and task assignments.</p>
<p>Very importantly, since all nodes have to agree on which node owns which data so as to determine MPI communications and task assignments the same way, all nodes have to perform the same data migration, and at the same point among task submissions. It thus does not require a strict synchronization, just a clear separation of task submissions before and after the data redistribution.</p>
<p>Before data unregistration, it has to be migrated back to its original home node (the value, at least), since that is where the user-provided buffer resides. Otherwise the unregistration will complain that it does not have the latest value on the original home node.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(x = 0; x &lt; X; x++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (y = 0; y &lt; Y; y++)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (data_handles[x][y])</div><div class="line">        {</div><div class="line">            <span class="keywordtype">int</span> mpi_rank = my_distrib(x, y, size);</div><div class="line">            <span class="comment">/* Get back data to original place where the user-provided buffer is.  */</span></div><div class="line">            <a class="code" href="group__API__MPI__Support.html#ga6c581f7133773a98b583e0c51970ecb7">starpu_mpi_get_data_on_node_detached</a>(MPI_COMM_WORLD, data_handles[x][y], mpi_rank, NULL, NULL);</div><div class="line">            <span class="comment">/* And unregister it */</span></div><div class="line">            <a class="code" href="group__API__Data__Management.html#ga586146498466b60d6b81145dfaeb8948">starpu_data_unregister</a>(data_handles[x][y]);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="MPICollective"></a>
MPI Collective Operations</h1>
<p>The functions are described in <a class="el" href="group__API__MPI__Support.html#MPICollectiveOperations">MPICollectiveOperations</a>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (rank == root)</div><div class="line">{</div><div class="line">    <span class="comment">/* Allocate the vector */</span></div><div class="line">    vector = malloc(nblocks * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span> *));</div><div class="line">    <span class="keywordflow">for</span>(x=0 ; x&lt;nblocks ; x++)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__API__Standard__Memory__Library.html#ga49603eaea3b05e8ced9ba1bd873070c3">starpu_malloc</a>((<span class="keywordtype">void</span> **)&amp;vector[x], block_size*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Allocate data handles and register data to StarPU */</span></div><div class="line">data_handles = malloc(nblocks*<span class="keyword">sizeof</span>(<a class="code" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *));</div><div class="line"><span class="keywordflow">for</span>(x = 0; x &lt; nblocks ;  x++)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> mpi_rank = my_distrib(x, nodes);</div><div class="line">    <span class="keywordflow">if</span> (rank == root)</div><div class="line">    {</div><div class="line">        <a class="code" href="group__API__Data__Interfaces.html#ga4248716bc322e1628b86365d7b9a8822">starpu_vector_data_register</a>(&amp;data_handles[x], <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>, (uintptr_t)vector[x], blocks_size, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((mpi_rank == rank) || ((rank == mpi_rank+1 || rank == mpi_rank-1)))</div><div class="line">    {</div><div class="line">        <span class="comment">/* I own this index, or i will need it for my computations */</span></div><div class="line">        <a class="code" href="group__API__Data__Interfaces.html#ga4248716bc322e1628b86365d7b9a8822">starpu_vector_data_register</a>(&amp;data_handles[x], -1, (uintptr_t)NULL, block_size, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* I know it&#39;s useless to allocate anything for this */</span></div><div class="line">        data_handles[x] = NULL;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (data_handles[x])</div><div class="line">    {</div><div class="line">        <a class="code" href="group__API__MPI__Support.html#ga747d8cbed76750c03031062f62824e3e">starpu_mpi_data_register</a>(data_handles[x], x*nblocks+y, mpi_rank);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Scatter the matrix among the nodes */</span></div><div class="line"><a class="code" href="group__API__MPI__Support.html#ga39ae075749aef08653ade368b9a95ee0">starpu_mpi_scatter_detached</a>(data_handles, nblocks, root, MPI_COMM_WORLD, NULL, NULL, NULL, NULL);</div><div class="line"></div><div class="line"><span class="comment">/* Calculation */</span></div><div class="line"><span class="keywordflow">for</span>(x = 0; x &lt; nblocks ;  x++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (data_handles[x])</div><div class="line">    {</div><div class="line">        <span class="keywordtype">int</span> owner = <a class="code" href="group__API__MPI__Support.html#ga5281ad23b39e64ca254347e89cbb54e2">starpu_data_get_rank</a>(data_handles[x]);</div><div class="line">        <span class="keywordflow">if</span> (owner == rank)</div><div class="line">        {</div><div class="line">            <a class="code" href="group__API__Insert__Task.html#gad79a50a21fe717126659b2998209c1c6">starpu_task_insert</a>(&amp;cl, STARPU_RW, data_handles[x], 0);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* Gather the matrix on main node */</span></div><div class="line"><a class="code" href="group__API__MPI__Support.html#gaf83405a3154137f00ccf554c5e5684b5">starpu_mpi_gather_detached</a>(data_handles, nblocks, 0, MPI_COMM_WORLD, NULL, NULL, NULL, NULL);</div></div><!-- fragment --><p>Other collective operations would be easy to define, just ask starpu-devel for them!</p>
<h1><a class="anchor" id="MPIDriver"></a>
Make StarPU-MPI Progression Thread Execute Tasks</h1>
<p>The default behaviour of StarPU-MPI is to spawn an MPI thread to take care only of MPI communications in an active fashion (i.e the StarPU-MPI thread sleeps only when there is no active request submitted by the application), with the goal of being as reactive as possible to communications. Knowing that, users usually leave one free core for the MPI thread when starting a distributed execution with StarPU-MPI. However, this could result in a loss of performance for applications that does not require an extreme reactivity to MPI communications.</p>
<p>The <a class="el" href="group__API__MPI__Support.html#gaec408170d2c815fdfdafa24873bc02da">starpu_mpi_init_conf()</a> routine allows the user to give the <a class="el" href="group__API__Initialization__and__Termination.html#structstarpu__conf">starpu_conf</a> configuration structure of StarPU (usually given to the <a class="el" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init()</a> routine) to StarPU-MPI, so that StarPU-MPI reserves for its own use one of the CPU drivers of the current computing node, or one of the CPU cores, and then calls <a class="el" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init()</a> internally.</p>
<p>This allows the MPI communication thread to call a StarPU CPU driver to run tasks when there is no active requests to take care of, and thus recover the computational power of the "lost" core. Since there is a trade-off between executing tasks and polling MPI requests, which is how much the application wants to lose in reactivity to MPI communications to get back the computing power of the core dedicated to the StarPU-MPI thread, there are two environment variables to pilot the behaviour of the MPI thread so that users can tune this trade-off depending of the behaviour of the application.</p>
<p>The <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_DRIVER_CALL_FREQUENCY">STARPU_MPI_DRIVER_CALL_FREQUENCY</a> environment variable sets how many times the MPI progression thread goes through the MPI_Test() loop on each active communication request (and thus try to make communications progress by going into the MPI layer) before executing tasks. The default value for this environment variable is 0, which means that the support for interleaving task execution and communication polling is deactivated, thus returning the MPI progression thread to its original behaviour.</p>
<p>The <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_DRIVER_TASK_FREQUENCY">STARPU_MPI_DRIVER_TASK_FREQUENCY</a> environment variable sets how many tasks are executed by the MPI communication thread before checking all active requests again. While this environment variable allows a better use of the core dedicated to StarPU-MPI for computations, it also decreases the reactivity of the MPI communication thread as much.</p>
<h1><a class="anchor" id="MPIDebug"></a>
Debugging MPI</h1>
<p>Communication trace will be enabled when the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_COMM">STARPU_MPI_COMM</a> is set to <code>1</code>, and StarPU has been configured with the option <a class="el" href="CompilationConfiguration.html#enable-verbose">--enable-verbose</a>.</p>
<p>Statistics will be enabled for the communication cache when the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_CACHE_STATS">STARPU_MPI_CACHE_STATS</a> is set to <code>1</code>. It prints messages on the standard output when data are added or removed from the received communication cache.</p>
<p>When the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_COMM_STATS">STARPU_COMM_STATS</a> is set to <code>1</code>, StarPU will display at the end of the execution for each node the volume and the bandwidth of data sent to all the other nodes.</p>
<p>Here an example of such a trace.</p>
<pre class="fragment">[starpu_comm_stats][3] TOTAL:	476.000000 B	0.000454 MB	 0.000098 B/s	 0.000000 MB/s
[starpu_comm_stats][3:0]	248.000000 B	0.000237 MB	 0.000051 B/s	 0.000000 MB/s
[starpu_comm_stats][3:2]	50.000000 B	0.000217 MB	 0.000047 B/s	 0.000000 MB/s

[starpu_comm_stats][2] TOTAL:	288.000000 B	0.000275 MB	 0.000059 B/s	 0.000000 MB/s
[starpu_comm_stats][2:1]	70.000000 B	0.000103 MB	 0.000022 B/s	 0.000000 MB/s
[starpu_comm_stats][2:3]	288.000000 B	0.000172 MB	 0.000037 B/s	 0.000000 MB/s

[starpu_comm_stats][1] TOTAL:	188.000000 B	0.000179 MB	 0.000038 B/s	 0.000000 MB/s
[starpu_comm_stats][1:0]	80.000000 B	0.000114 MB	 0.000025 B/s	 0.000000 MB/s
[starpu_comm_stats][1:2]	188.000000 B	0.000065 MB	 0.000014 B/s	 0.000000 MB/s

[starpu_comm_stats][0] TOTAL:	376.000000 B	0.000359 MB	 0.000077 B/s	 0.000000 MB/s
[starpu_comm_stats][0:1]	376.000000 B	0.000141 MB	 0.000030 B/s	 0.000000 MB/s
[starpu_comm_stats][0:3]	10.000000 B	0.000217 MB	 0.000047 B/s	 0.000000 MB/s
</pre><p>These statistics can be plotted as heatmaps using StarPU tool <code>starpu_mpi_comm_matrix.py</code>, this will produce 2 PDF files, one plot for the bandwidth, and one plot for the data volume.</p>
 <div class="image">
<img src="trace_bw_heatmap.png" alt="trace_bw_heatmap.png"/>
<div class="caption">
Bandwidth Heatmap</div></div>
  <div class="image">
<img src="trace_volume_heatmap.png" alt="trace_volume_heatmap.png"/>
<div class="caption">
Data Bandwidth Heatmap</div></div>
 <h1><a class="anchor" id="MPIExamples"></a>
More MPI examples</h1>
<p>MPI examples are available in the StarPU source code in mpi/examples:</p>
<ul>
<li>
<code>comm</code> shows how to use communicators with StarPU-MPI  </li>
<li>
<code>complex</code> is a simple example using a user-define data interface over MPI (complex numbers),  </li>
<li>
<code>stencil5</code> is a simple stencil example using <a class="el" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert()</a>,  </li>
<li>
<code>matrix_decomposition</code> is a cholesky decomposition example using <a class="el" href="group__API__MPI__Support.html#gaa823d6398e61516bba887b90ad048914">starpu_mpi_task_insert()</a>. The non-distributed version can check for &lt;algorithm correctness in 1-node configuration, the distributed version uses exactly the same source code, to be used over MPI,  </li>
<li>
<code>mpi_lu</code> is an LU decomposition example, provided in three versions: <code>plu_example</code> uses explicit MPI data transfers, <code>plu_implicit_example</code> uses implicit MPI data transfers, <code>plu_outofcore_example</code> uses implicit MPI data transfers and supports data matrices which do not fit in memory (out-of-core).  </li>
</ul>
<h1><a class="anchor" id="Nmad"></a>
Using the NewMadeleine communication library</h1>
<p>NewMadeleine (see <a href="http://pm2.gforge.inria.fr/newmadeleine/,">http://pm2.gforge.inria.fr/newmadeleine/,</a> part of the PM2 project) is an optimizing communication library for high-performance networks. NewMadeleine provides its own interface, but also an MPI interface (called MadMPI). Thus there are two possibilities to use NewMadeleine with StarPU:</p>
<ul>
<li>
using the NewMadeleine's native interface. StarPU supports this interface from its release 1.3.0, by enabling the <code>configure</code> option <a class="el" href="CompilationConfiguration.html#enable-nmad">--enable-nmad</a>. In this case, StarPU relies directly on NewMadeleine to make communications progress and NewMadeleine has to be built with the profile <code>pukabi+madmpi.conf</code>.  </li>
<li>
using the NewMadeleine's MPI interface (MadMPI). StarPU will use the standard MPI API and NewMadeleine will handle the calls to the MPI API. In this case, StarPU makes communications progress and thus communication progress has to be disabled in NewMadeleine by compiling it with the profile <code>pukabi+madmpi-mini.conf</code>.  </li>
</ul>
<p>To build NewMadeleine, download the latest version from the website (or, better, use the Git version to use the most recent version), then: </p><div class="fragment"><div class="line">cd pm2/scripts</div><div class="line">./pm2-build-packages ./&lt;the profile you chose&gt; --prefix=&lt;installation prefix&gt;</div></div><!-- fragment --><p>With Guix, the NewMadeleine's native interface can be used by setting the parameter <code>--with-input=openmpi=nmad</code> and MadMPI can be used with <code>--with-input=openmpi=nmad-mini</code>.</p>
<p>Whatever implementation (NewMadeleine or MadMPI) is used by StarPU, the public MPI interface of StarPU (described in <a class="el" href="group__API__MPI__Support.html">MPI Support</a>) is the same.</p>
<h1><a class="anchor" id="MPIMasterSlave"></a>
MPI Master Slave Support</h1>
<p>StarPU provides an other way to execute applications across many nodes. The Master Slave support permits to use remote cores without thinking about data distribution. This support can be activated with the <code>configure</code> option <a class="el" href="CompilationConfiguration.html#enable-mpi-master-slave">--enable-mpi-master-slave</a>. However, you should not activate both MPI support and MPI Master-Slave support.</p>
<p>The existing kernels for CPU devices can be used as such. They only have to be exposed through the name of the function in the <a class="el" href="group__API__Codelet__And__Tasks.html#abfc0aa8247673ad1c629d5ddd30082a3">starpu_codelet::cpu_funcs_name</a> field. Functions have to be globally-visible (i.e. not static) for StarPU to be able to look them up, and <code>-rdynamic</code> must be passed to gcc (or <code>-export-dynamic</code> to ld) so that symbols of the main program are visible. Optionally, you can choose the use of another function on slaves thanks to the field <a class="el" href="group__API__Codelet__And__Tasks.html#a0147c090855cf378f2786a9c39e0a608">starpu_codelet::mpi_ms_funcs</a>.</p>
<p>By default, one core is dedicated on the master node to manage the entire set of slaves. If the implementation of MPI you are using has a good multiple threads support, you can use the <code>configure</code> option <a class="el" href="CompilationConfiguration.html#with-mpi-master-slave-multiple-thread">--with-mpi-master-slave-multiple-thread</a> to dedicate one core per slave.</p>
<p>Choosing the number of cores on each slave device is done by setting the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_NMPIMSTHREADS">STARPU_NMPIMSTHREADS=&lt;number&gt;</a> with <code>&lt;number&gt;</code> being the requested number of cores. By default all the slave's cores are used.</p>
<p>Setting the number of slaves nodes is done by changing the <code>-n</code> parameter when executing the application with mpirun or mpiexec.</p>
<p>The master node is by default the node with the MPI rank equal to 0. To select another node, use the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MPI_MASTER_NODE">STARPU_MPI_MASTER_NODE=&lt;number&gt;</a> with <code>&lt;number&gt;</code> being the requested MPI rank node. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 22 2021 15:02:16 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
