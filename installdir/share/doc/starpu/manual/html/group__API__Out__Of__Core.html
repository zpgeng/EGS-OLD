<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StarPU Handbook: Out Of Core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__API__Out__Of__Core.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Out Of Core</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structstarpu__disk__ops"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a></td></tr>
<tr class="separator:structstarpu__disk__ops"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2df434587aeeaaf16a116163eb690a2d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ga2df434587aeeaaf16a116163eb690a2d">STARPU_DISK_SIZE_MIN</a></td></tr>
<tr class="separator:ga2df434587aeeaaf16a116163eb690a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8cd566efd70ad57cda18a6b9a7be4ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ga8cd566efd70ad57cda18a6b9a7be4ac7">starpu_disk_close</a> (unsigned node, void *obj, size_t size)</td></tr>
<tr class="separator:ga8cd566efd70ad57cda18a6b9a7be4ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e2a6bf23a5cf18a889b333238608e1b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ga6e2a6bf23a5cf18a889b333238608e1b">starpu_disk_open</a> (unsigned node, void *pos, size_t size)</td></tr>
<tr class="separator:ga6e2a6bf23a5cf18a889b333238608e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9ed48246cb2b326ca6a199b6183aa75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#gac9ed48246cb2b326ca6a199b6183aa75">starpu_disk_register</a> (struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a> *func, void *parameter, starpu_ssize_t size)</td></tr>
<tr class="separator:gac9ed48246cb2b326ca6a199b6183aa75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0a32ef9e11531938948f332ffc06feac"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ga0a32ef9e11531938948f332ffc06feac">starpu_disk_stdio_ops</a></td></tr>
<tr class="separator:ga0a32ef9e11531938948f332ffc06feac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada0fb9813aab8ff529ca1881f9b4943e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#gada0fb9813aab8ff529ca1881f9b4943e">starpu_disk_hdf5_ops</a></td></tr>
<tr class="separator:gada0fb9813aab8ff529ca1881f9b4943e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c2e0c65181779e0d4ca2231df3ac03e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ga9c2e0c65181779e0d4ca2231df3ac03e">starpu_disk_unistd_ops</a></td></tr>
<tr class="separator:ga9c2e0c65181779e0d4ca2231df3ac03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5088eabf3181fc0d2516ec617f04b449"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ga5088eabf3181fc0d2516ec617f04b449">starpu_disk_unistd_o_direct_ops</a></td></tr>
<tr class="separator:ga5088eabf3181fc0d2516ec617f04b449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad75ff93c36fc85e172a5f4057b07f091"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#gad75ff93c36fc85e172a5f4057b07f091">starpu_disk_leveldb_ops</a></td></tr>
<tr class="separator:gad75ff93c36fc85e172a5f4057b07f091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0234716edb5f73e6f46288f9017d605"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#gac0234716edb5f73e6f46288f9017d605">starpu_disk_swap_node</a></td></tr>
<tr class="separator:gac0234716edb5f73e6f46288f9017d605"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structstarpu__disk__ops" id="structstarpu__disk__ops"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structstarpu__disk__ops">&#9670;&nbsp;</a></span>starpu_disk_ops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct starpu_disk_ops</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Set of functions to manipulate datas on disk. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:af35b6528223d0f44eeae120dd020c710"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#af35b6528223d0f44eeae120dd020c710">plug</a> )(void *parameter, starpu_ssize_t size)</td></tr>
<tr class="separator:af35b6528223d0f44eeae120dd020c710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaff065edbd1ad085acc89352cafd253"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#aaaff065edbd1ad085acc89352cafd253">unplug</a> )(void *base)</td></tr>
<tr class="separator:aaaff065edbd1ad085acc89352cafd253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728c7a6e4c919a72300ac8f8a3bae0b2"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a728c7a6e4c919a72300ac8f8a3bae0b2">bandwidth</a> )(unsigned node, void *base)</td></tr>
<tr class="separator:a728c7a6e4c919a72300ac8f8a3bae0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b68767ae4037038eb72413aefd0420"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a26b68767ae4037038eb72413aefd0420">alloc</a> )(void *base, size_t size)</td></tr>
<tr class="separator:a26b68767ae4037038eb72413aefd0420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b47927d234281d157b9191c9f59d57"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a19b47927d234281d157b9191c9f59d57">free</a> )(void *base, void *obj, size_t size)</td></tr>
<tr class="separator:a19b47927d234281d157b9191c9f59d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833e647b4aabdb93d4d3588412212a13"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a833e647b4aabdb93d4d3588412212a13">open</a> )(void *base, void *pos, size_t size)</td></tr>
<tr class="separator:a833e647b4aabdb93d4d3588412212a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b4fbe01a33b0f2526bd70e8128dfbd"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a00b4fbe01a33b0f2526bd70e8128dfbd">close</a> )(void *base, void *obj, size_t size)</td></tr>
<tr class="separator:a00b4fbe01a33b0f2526bd70e8128dfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18216c9db1b888e568af638dbb22b16f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a18216c9db1b888e568af638dbb22b16f">read</a> )(void *base, void *obj, void *buf, off_t offset, size_t size)</td></tr>
<tr class="separator:a18216c9db1b888e568af638dbb22b16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8075b45d01d4b6a556644aed724a999"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#af8075b45d01d4b6a556644aed724a999">write</a> )(void *base, void *obj, const void *buf, off_t offset, size_t size)</td></tr>
<tr class="separator:af8075b45d01d4b6a556644aed724a999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c45355d7c609a9deccd366fab8ab5b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#aa9c45355d7c609a9deccd366fab8ab5b">full_read</a> )(void *base, void *obj, void **ptr, size_t *size, unsigned dst_node)</td></tr>
<tr class="separator:aa9c45355d7c609a9deccd366fab8ab5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4831b8088a13f038e267e9b141af4283"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a4831b8088a13f038e267e9b141af4283">full_write</a> )(void *base, void *obj, void *ptr, size_t size)</td></tr>
<tr class="separator:a4831b8088a13f038e267e9b141af4283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5ba5bb81c7f6350135640b14880de9"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a7a5ba5bb81c7f6350135640b14880de9">async_write</a> )(void *base, void *obj, void *buf, off_t offset, size_t size)</td></tr>
<tr class="separator:a7a5ba5bb81c7f6350135640b14880de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a70d305e32a3d944f5fefa8ca08183"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a34a70d305e32a3d944f5fefa8ca08183">async_read</a> )(void *base, void *obj, void *buf, off_t offset, size_t size)</td></tr>
<tr class="separator:a34a70d305e32a3d944f5fefa8ca08183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53a6785b2579883d976f756e2000a06"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#af53a6785b2579883d976f756e2000a06">async_full_read</a> )(void *base, void *obj, void **ptr, size_t *size, unsigned dst_node)</td></tr>
<tr class="separator:af53a6785b2579883d976f756e2000a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a04016101ab8a46f6b22feb82676b5"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#aa2a04016101ab8a46f6b22feb82676b5">async_full_write</a> )(void *base, void *obj, void *ptr, size_t size)</td></tr>
<tr class="separator:aa2a04016101ab8a46f6b22feb82676b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841756a748f25860e45e12e215249683"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a841756a748f25860e45e12e215249683">copy</a> )(void *base_src, void *obj_src, off_t offset_src, void *base_dst, void *obj_dst, off_t offset_dst, size_t size)</td></tr>
<tr class="separator:a841756a748f25860e45e12e215249683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c30bb72265e8d1e972bfb00cf6345e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ae1c30bb72265e8d1e972bfb00cf6345e">wait_request</a> )(void *async_channel)</td></tr>
<tr class="separator:ae1c30bb72265e8d1e972bfb00cf6345e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c89ac6cf13a6eec0eb36491d5b8ce8f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#a6c89ac6cf13a6eec0eb36491d5b8ce8f">test_request</a> )(void *async_channel)</td></tr>
<tr class="separator:a6c89ac6cf13a6eec0eb36491d5b8ce8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76930b8488dbedad92de1b5368dbdc8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Out__Of__Core.html#ad76930b8488dbedad92de1b5368dbdc8">free_request</a> )(void *async_channel)</td></tr>
<tr class="separator:ad76930b8488dbedad92de1b5368dbdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a id="af35b6528223d0f44eeae120dd020c710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35b6528223d0f44eeae120dd020c710">&#9670;&nbsp;</a></span>plug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* starpu_disk_ops::plug) (void *parameter, starpu_ssize_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect a disk memory at location <code>parameter</code> with size <code>size</code>, and return a base as void*, which will be passed by StarPU to all other methods. </p>

</div>
</div>
<a id="aaaff065edbd1ad085acc89352cafd253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaff065edbd1ad085acc89352cafd253">&#9670;&nbsp;</a></span>unplug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_disk_ops::unplug) (void *base)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnect a disk memory <code>base</code>. </p>

</div>
</div>
<a id="a728c7a6e4c919a72300ac8f8a3bae0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728c7a6e4c919a72300ac8f8a3bae0b2">&#9670;&nbsp;</a></span>bandwidth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* starpu_disk_ops::bandwidth) (unsigned node, void *base)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Measure the bandwidth and the latency for the disk <code>node</code> and save it. Returns 1 if it could measure it. </p>

</div>
</div>
<a id="a26b68767ae4037038eb72413aefd0420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b68767ae4037038eb72413aefd0420">&#9670;&nbsp;</a></span>alloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* starpu_disk_ops::alloc) (void *base, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new location for datas of size <code>size</code>. Return an opaque object pointer. </p>

</div>
</div>
<a id="a19b47927d234281d157b9191c9f59d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b47927d234281d157b9191c9f59d57">&#9670;&nbsp;</a></span>free</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_disk_ops::free) (void *base, void *obj, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a data <code>obj</code> previously allocated with <a class="el" href="group__API__Out__Of__Core.html#a26b68767ae4037038eb72413aefd0420">starpu_disk_ops::alloc</a>. </p>

</div>
</div>
<a id="a833e647b4aabdb93d4d3588412212a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833e647b4aabdb93d4d3588412212a13">&#9670;&nbsp;</a></span>open</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* starpu_disk_ops::open) (void *base, void *pos, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open an existing location of datas, at a specific position <code>pos</code> dependent on the backend. </p>

</div>
</div>
<a id="a00b4fbe01a33b0f2526bd70e8128dfbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b4fbe01a33b0f2526bd70e8128dfbd">&#9670;&nbsp;</a></span>close</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_disk_ops::close) (void *base, void *obj, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close, without deleting it, a location of datas <code>obj</code>. </p>

</div>
</div>
<a id="a18216c9db1b888e568af638dbb22b16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18216c9db1b888e568af638dbb22b16f">&#9670;&nbsp;</a></span>read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* starpu_disk_ops::read) (void *base, void *obj, void *buf, off_t offset, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read <code>size</code> bytes of data from <code>obj</code> in <code>base</code>, at offset <code>offset</code>, and put into <code>buf</code>. Return the actual number of read bytes. </p>

</div>
</div>
<a id="af8075b45d01d4b6a556644aed724a999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8075b45d01d4b6a556644aed724a999">&#9670;&nbsp;</a></span>write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* starpu_disk_ops::write) (void *base, void *obj, const void *buf, off_t offset, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write <code>size</code> bytes of data to <code>obj</code> in <code>base</code>, at offset <code>offset</code>, from <code>buf</code>. Return 0 on success. </p>

</div>
</div>
<a id="aa9c45355d7c609a9deccd366fab8ab5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c45355d7c609a9deccd366fab8ab5b">&#9670;&nbsp;</a></span>full_read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* starpu_disk_ops::full_read) (void *base, void *obj, void **ptr, size_t *size, unsigned dst_node)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read all data from <code>obj</code> of <code>base</code>, from offset 0. Returns it in an allocated buffer <code>ptr</code>, of size <code>size</code> </p>

</div>
</div>
<a id="a4831b8088a13f038e267e9b141af4283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4831b8088a13f038e267e9b141af4283">&#9670;&nbsp;</a></span>full_write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* starpu_disk_ops::full_write) (void *base, void *obj, void *ptr, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data in <code>ptr</code> to <code>obj</code> of <code>base</code>, from offset 0, and truncate <code>obj</code> to <code>size</code>, so that a <code>full_read</code> will get it. </p>

</div>
</div>
<a id="a7a5ba5bb81c7f6350135640b14880de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5ba5bb81c7f6350135640b14880de9">&#9670;&nbsp;</a></span>async_write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* starpu_disk_ops::async_write) (void *base, void *obj, void *buf, off_t offset, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asynchronously write <code>size</code> bytes of data to <code>obj</code> in <code>base</code>, at offset <code>offset</code>, from <code>buf</code>. Return a void* pointer that StarPU will pass to <code>xxx_request</code> methods for testing for the completion. </p>

</div>
</div>
<a id="a34a70d305e32a3d944f5fefa8ca08183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a70d305e32a3d944f5fefa8ca08183">&#9670;&nbsp;</a></span>async_read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* starpu_disk_ops::async_read) (void *base, void *obj, void *buf, off_t offset, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asynchronously read <code>size</code> bytes of data from <code>obj</code> in <code>base</code>, at offset <code>offset</code>, and put into <code>buf</code>. Return a void* pointer that StarPU will pass to <code>xxx_request</code> methods for testing for the completion. </p>

</div>
</div>
<a id="af53a6785b2579883d976f756e2000a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53a6785b2579883d976f756e2000a06">&#9670;&nbsp;</a></span>async_full_read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* starpu_disk_ops::async_full_read) (void *base, void *obj, void **ptr, size_t *size, unsigned dst_node)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read all data from <code>obj</code> of <code>base</code>, from offset 0. Return it in an allocated buffer <code>ptr</code>, of size <code>size</code> </p>

</div>
</div>
<a id="aa2a04016101ab8a46f6b22feb82676b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a04016101ab8a46f6b22feb82676b5">&#9670;&nbsp;</a></span>async_full_write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* starpu_disk_ops::async_full_write) (void *base, void *obj, void *ptr, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data in <code>ptr</code> to <code>obj</code> of <code>base</code>, from offset 0, and truncate <code>obj</code> to <code>size</code>, so that a <a class="el" href="group__API__Out__Of__Core.html#aa9c45355d7c609a9deccd366fab8ab5b">starpu_disk_ops::full_read</a> will get it. </p>

</div>
</div>
<a id="a841756a748f25860e45e12e215249683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841756a748f25860e45e12e215249683">&#9670;&nbsp;</a></span>copy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* starpu_disk_ops::copy) (void *base_src, void *obj_src, off_t offset_src, void *base_dst, void *obj_dst, off_t offset_dst, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy from offset <code>offset_src</code> of disk object <code>obj_src</code> in <code>base_src</code> to offset <code>offset_dst</code> of disk object <code>obj_dst</code> in <code>base_dst</code>. Return a void* pointer that StarPU will pass to <code>xxx_request</code> methods for testing for the completion. </p>

</div>
</div>
<a id="ae1c30bb72265e8d1e972bfb00cf6345e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c30bb72265e8d1e972bfb00cf6345e">&#9670;&nbsp;</a></span>wait_request</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_disk_ops::wait_request) (void *async_channel)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for completion of request <code>async_channel</code> returned by a previous asynchronous read, write or copy. </p>

</div>
</div>
<a id="a6c89ac6cf13a6eec0eb36491d5b8ce8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c89ac6cf13a6eec0eb36491d5b8ce8f">&#9670;&nbsp;</a></span>test_request</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* starpu_disk_ops::test_request) (void *async_channel)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for completion of request <code>async_channel</code> returned by a previous asynchronous read, write or copy. Return 1 on completion, 0 otherwise. </p>

</div>
</div>
<a id="ad76930b8488dbedad92de1b5368dbdc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76930b8488dbedad92de1b5368dbdc8">&#9670;&nbsp;</a></span>free_request</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_disk_ops::free_request) (void *async_channel)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the request allocated by a previous asynchronous read, write or copy. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga2df434587aeeaaf16a116163eb690a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2df434587aeeaaf16a116163eb690a2d">&#9670;&nbsp;</a></span>STARPU_DISK_SIZE_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STARPU_DISK_SIZE_MIN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minimum size of a registered disk. The size of a disk is the last parameter of the function <a class="el" href="group__API__Out__Of__Core.html#gac9ed48246cb2b326ca6a199b6183aa75">starpu_disk_register()</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8cd566efd70ad57cda18a6b9a7be4ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cd566efd70ad57cda18a6b9a7be4ac7">&#9670;&nbsp;</a></span>starpu_disk_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_disk_close </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close an existing data opened with <a class="el" href="group__API__Out__Of__Core.html#ga6e2a6bf23a5cf18a889b333238608e1b">starpu_disk_open()</a>. </p>

</div>
</div>
<a id="ga6e2a6bf23a5cf18a889b333238608e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e2a6bf23a5cf18a889b333238608e1b">&#9670;&nbsp;</a></span>starpu_disk_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* starpu_disk_open </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open an existing file memory in a disk node. <code>size</code> is the size of the file. <code>pos</code> is the specific position dependent on the backend, given to the <code>open</code> method of the disk operations. Return an opaque object pointer. </p>

</div>
</div>
<a id="gac9ed48246cb2b326ca6a199b6183aa75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9ed48246cb2b326ca6a199b6183aa75">&#9670;&nbsp;</a></span>starpu_disk_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_disk_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a> *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">starpu_ssize_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a disk memory node with a set of functions to manipulate datas. The <code>plug</code> member of <code>func</code> will be passed <code>parameter</code>, and return a <code>base</code> which will be passed to all <code>func</code> methods. <br />
 SUCCESS: return the disk node. <br />
 FAIL: return an error code. <br />
 <code>size</code> must be at least <a class="el" href="group__API__Out__Of__Core.html#ga2df434587aeeaaf16a116163eb690a2d">STARPU_DISK_SIZE_MIN</a> bytes ! <code>size</code> being negative means infinite size. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga0a32ef9e11531938948f332ffc06feac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a32ef9e11531938948f332ffc06feac">&#9670;&nbsp;</a></span>starpu_disk_stdio_ops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a> starpu_disk_stdio_ops</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the stdio library (fwrite, fread...) to read/write on disk.</p>
<p><b>Warning: It creates one file per allocation !</b></p>
<p>Do not support asynchronous transfers. </p>

</div>
</div>
<a id="gada0fb9813aab8ff529ca1881f9b4943e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada0fb9813aab8ff529ca1881f9b4943e">&#9670;&nbsp;</a></span>starpu_disk_hdf5_ops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a> starpu_disk_hdf5_ops</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the HDF5 library.</p>
<p><b>It doesn't support multiple opening from different processes. </b></p>
<p>You may only allow one process to write in the HDF5 file.</p>
<p><b>If HDF5 library is not compiled with &ndash;thread-safe you can't open more than one HDF5 file at the same time. </b> </p>

</div>
</div>
<a id="ga9c2e0c65181779e0d4ca2231df3ac03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c2e0c65181779e0d4ca2231df3ac03e">&#9670;&nbsp;</a></span>starpu_disk_unistd_ops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a> starpu_disk_unistd_ops</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the unistd library (write, read...) to read/write on disk.</p>
<p><b>Warning: It creates one file per allocation !</b> </p>

</div>
</div>
<a id="ga5088eabf3181fc0d2516ec617f04b449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5088eabf3181fc0d2516ec617f04b449">&#9670;&nbsp;</a></span>starpu_disk_unistd_o_direct_ops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a> starpu_disk_unistd_o_direct_ops</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the unistd library (write, read...) to read/write on disk with the O_DIRECT flag.</p>
<p><b>Warning: It creates one file per allocation !</b></p>
<p>Only available on Linux systems. </p>

</div>
</div>
<a id="gad75ff93c36fc85e172a5f4057b07f091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad75ff93c36fc85e172a5f4057b07f091">&#9670;&nbsp;</a></span>starpu_disk_leveldb_ops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__API__Out__Of__Core.html#structstarpu__disk__ops">starpu_disk_ops</a> starpu_disk_leveldb_ops</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the leveldb created by Google. More information at <a href="https://code.google.com/p/leveldb/">https://code.google.com/p/leveldb/</a> Do not support asynchronous transfers. </p>

</div>
</div>
<a id="gac0234716edb5f73e6f46288f9017d605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0234716edb5f73e6f46288f9017d605">&#9670;&nbsp;</a></span>starpu_disk_swap_node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_disk_swap_node</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contain the node number of the disk swap, if set up through the <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_DISK_SWAP">STARPU_DISK_SWAP</a> variable. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 22 2021 15:02:18 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
