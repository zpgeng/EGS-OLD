<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StarPU Handbook: Data Partition</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__API__Data__Partition.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Data Partition</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structstarpu__data__filter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a></td></tr>
<tr class="separator:structstarpu__data__filter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Basic API</h2></td></tr>
<tr class="memitem:ga1363109ba0e36c1b6c7f1a40c9608791"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga1363109ba0e36c1b6c7f1a40c9608791">starpu_data_partition</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> initial_handle, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f)</td></tr>
<tr class="separator:ga1363109ba0e36c1b6c7f1a40c9608791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae80794b9cad7855a3ee54a4361f656ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gae80794b9cad7855a3ee54a4361f656ed">starpu_data_unpartition</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> root_data, unsigned gathering_node)</td></tr>
<tr class="separator:gae80794b9cad7855a3ee54a4361f656ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e07c2c0604da63e7746a8018d8a62f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga29e07c2c0604da63e7746a8018d8a62f">starpu_data_get_child</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> handle, unsigned i)</td></tr>
<tr class="separator:ga29e07c2c0604da63e7746a8018d8a62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a3f729055f14384e7397d2815a2c9a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga6a3f729055f14384e7397d2815a2c9a5">starpu_data_get_nb_children</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> handle)</td></tr>
<tr class="separator:ga6a3f729055f14384e7397d2815a2c9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24101bbe28b1d7d4a0874d349ba8979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gac24101bbe28b1d7d4a0874d349ba8979">starpu_data_get_sub_data</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> root_data, unsigned depth,...)</td></tr>
<tr class="separator:gac24101bbe28b1d7d4a0874d349ba8979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7904efb86ab3f9d6d682a3a3be3646fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga7904efb86ab3f9d6d682a3a3be3646fe">starpu_data_vget_sub_data</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> root_data, unsigned depth, va_list pa)</td></tr>
<tr class="separator:ga7904efb86ab3f9d6d682a3a3be3646fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga551d6fa7fead5b9f7c8a85b1f9885e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga551d6fa7fead5b9f7c8a85b1f9885e91">starpu_data_map_filters</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> root_data, unsigned nfilters,...)</td></tr>
<tr class="separator:ga551d6fa7fead5b9f7c8a85b1f9885e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a28291a5045ef7ed3c93afc94ed248"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga15a28291a5045ef7ed3c93afc94ed248">starpu_data_vmap_filters</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> root_data, unsigned nfilters, va_list pa)</td></tr>
<tr class="separator:ga15a28291a5045ef7ed3c93afc94ed248"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Asynchronous API</h2></td></tr>
<tr class="memitem:gaa4407a8734e1fbdbb63b83351769476c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gaa4407a8734e1fbdbb63b83351769476c">starpu_data_partition_plan</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> initial_handle, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *children)</td></tr>
<tr class="separator:gaa4407a8734e1fbdbb63b83351769476c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga994cbae9c619b070f8d219f6bfffff06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga994cbae9c619b070f8d219f6bfffff06">starpu_data_partition_submit</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> initial_handle, unsigned nparts, <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *children)</td></tr>
<tr class="separator:ga994cbae9c619b070f8d219f6bfffff06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcf158f5196d62610c5017993442c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga7fcf158f5196d62610c5017993442c53">starpu_data_partition_readonly_submit</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> initial_handle, unsigned nparts, <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *children)</td></tr>
<tr class="separator:ga7fcf158f5196d62610c5017993442c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a26c673507a7de484071e0926cb5638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga8a26c673507a7de484071e0926cb5638">starpu_data_partition_readwrite_upgrade_submit</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> initial_handle, unsigned nparts, <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *children)</td></tr>
<tr class="separator:ga8a26c673507a7de484071e0926cb5638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d2b144a7de2e17d17b1383ef5f522d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga46d2b144a7de2e17d17b1383ef5f522d">starpu_data_unpartition_submit</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> initial_handle, unsigned nparts, <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *children, int gathering_node)</td></tr>
<tr class="separator:ga46d2b144a7de2e17d17b1383ef5f522d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0987e0480b5e053f34df437e468cdd"><td class="memItemLeft" align="right" valign="top"><a id="ga8c0987e0480b5e053f34df437e468cdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>starpu_data_unpartition_submit_r</b> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> initial_handle, int gathering_node)</td></tr>
<tr class="separator:ga8c0987e0480b5e053f34df437e468cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1e66049a48764a29d867a02bcc9d0ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gac1e66049a48764a29d867a02bcc9d0ce">starpu_data_unpartition_readonly_submit</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> initial_handle, unsigned nparts, <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *children, int gathering_node)</td></tr>
<tr class="separator:gac1e66049a48764a29d867a02bcc9d0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4f0b5ce7cdee16c1311595e9ca53e98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gac4f0b5ce7cdee16c1311595e9ca53e98">starpu_data_partition_clean</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> root_data, unsigned nparts, <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *children)</td></tr>
<tr class="separator:gac4f0b5ce7cdee16c1311595e9ca53e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea478569a1a283c4cf7ef3920334b82e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gaea478569a1a283c4cf7ef3920334b82e">starpu_data_unpartition_submit_sequential_consistency_cb</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> initial_handle, unsigned nparts, <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *children, int gather_node, int sequential_consistency, void(*callback_func)(void *), void *callback_arg)</td></tr>
<tr class="separator:gaea478569a1a283c4cf7ef3920334b82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab915b6daaa4323e433688e7888e921d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gab915b6daaa4323e433688e7888e921d6">starpu_data_partition_submit_sequential_consistency</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> initial_handle, unsigned nparts, <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *children, int sequential_consistency)</td></tr>
<tr class="separator:gab915b6daaa4323e433688e7888e921d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab931b6026c134fa98bb72fb2f7c0c67f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gab931b6026c134fa98bb72fb2f7c0c67f">starpu_data_unpartition_submit_sequential_consistency</a> (<a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> initial_handle, unsigned nparts, <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *children, int gathering_node, int sequential_consistency)</td></tr>
<tr class="separator:gab931b6026c134fa98bb72fb2f7c0c67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Predefined BCSR Filter Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd93eeddd2d8e1976c5a8afc351886d12"></a>Predefined partitioning functions for BCSR data. Examples on how to use them are shown in <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>. </p>
</td></tr>
<tr class="memitem:ga0e1bee4821237529d554605d333e9109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga0e1bee4821237529d554605d333e9109">starpu_bcsr_filter_canonical_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga0e1bee4821237529d554605d333e9109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa91c8e107f03a35f4574395fde1c63a4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gaa91c8e107f03a35f4574395fde1c63a4">starpu_bcsr_filter_canonical_block_get_nchildren</a> (struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> handle)</td></tr>
<tr class="separator:gaa91c8e107f03a35f4574395fde1c63a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47aeeae0c17c6ff3ef961ec267b28d61"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga47aeeae0c17c6ff3ef961ec267b28d61">starpu_bcsr_filter_canonical_block_child_ops</a> (struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned child)</td></tr>
<tr class="separator:ga47aeeae0c17c6ff3ef961ec267b28d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b910784c11bb46599fe9cb8928418f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga4b910784c11bb46599fe9cb8928418f2">starpu_bcsr_filter_vertical_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga4b910784c11bb46599fe9cb8928418f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Predefined CSR Filter Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpda4434d3b6053a3f51f8eabe006bb3fc"></a>Predefined partitioning functions for CSR data. Examples on how to use them are shown in <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>. </p>
</td></tr>
<tr class="memitem:ga554a2fb14fdee9353364c39f36ee3a6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga554a2fb14fdee9353364c39f36ee3a6f">starpu_csr_filter_vertical_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga554a2fb14fdee9353364c39f36ee3a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Predefined Matrix Filter Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp40f9ddfd6d94d60c150ad542d9542fcf"></a>Predefined partitioning functions for matrix data. Examples on how to use them are shown in <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>. Note: this is using the C element order which is row-major, i.e. elements with consecutive x coordinates are consecutive in memory. </p>
</td></tr>
<tr class="memitem:ga8c86b2af9e0806e631c1cbb5d506506b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga8c86b2af9e0806e631c1cbb5d506506b">starpu_matrix_filter_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga8c86b2af9e0806e631c1cbb5d506506b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88fbca61843b76314e39a2c0f8b93d6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga88fbca61843b76314e39a2c0f8b93d6c">starpu_matrix_filter_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga88fbca61843b76314e39a2c0f8b93d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2925be576ac7d597ecead381ff32a894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga2925be576ac7d597ecead381ff32a894">starpu_matrix_filter_vertical_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga2925be576ac7d597ecead381ff32a894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7132923bd901e0e4254cc0b20d49997a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga7132923bd901e0e4254cc0b20d49997a">starpu_matrix_filter_vertical_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga7132923bd901e0e4254cc0b20d49997a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Predefined Vector Filter Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7fb4f57874a68dd59273529618faf2cd"></a>Predefined partitioning functions for vector data. Examples on how to use them are shown in <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>. </p>
</td></tr>
<tr class="memitem:ga212189d3b83dfa4e225609b5f2bf8461"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga212189d3b83dfa4e225609b5f2bf8461">starpu_vector_filter_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga212189d3b83dfa4e225609b5f2bf8461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab49915dc0462c1b145bfb0a9ce4cf52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gaab49915dc0462c1b145bfb0a9ce4cf52">starpu_vector_filter_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:gaab49915dc0462c1b145bfb0a9ce4cf52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c3d612b5161b5f72282b4bf9390525a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga6c3d612b5161b5f72282b4bf9390525a">starpu_vector_filter_list_long</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga6c3d612b5161b5f72282b4bf9390525a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9fa487bfff5ccdd59210bdde65a11db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gab9fa487bfff5ccdd59210bdde65a11db">starpu_vector_filter_list</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:gab9fa487bfff5ccdd59210bdde65a11db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab639622ea4929c36df704a0bebfd3fac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gab639622ea4929c36df704a0bebfd3fac">starpu_vector_filter_divide_in_2</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:gab639622ea4929c36df704a0bebfd3fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Predefined Block Filter Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp37648ac3f0915927087c62fb10379c9c"></a>Predefined partitioning functions for block data. Examples on how to use them are shown in <a class="el" href="DataManagement.html#PartitioningData">Partitioning Data</a>. An example is available in <code>examples/filters/shadow3d.c</code> Note: this is using the C element order which is row-major, i.e. elements with consecutive x coordinates are consecutive in memory. </p>
</td></tr>
<tr class="memitem:ga1a265ffca51fae58701832a4daa53bd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga1a265ffca51fae58701832a4daa53bd9">starpu_block_filter_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga1a265ffca51fae58701832a4daa53bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc8832e25f2f4049ba5a0053b122dd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga7cc8832e25f2f4049ba5a0053b122dd9">starpu_block_filter_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga7cc8832e25f2f4049ba5a0053b122dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73a2c9af1200c68f0403e70e36c020d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ga73a2c9af1200c68f0403e70e36c020d0">starpu_block_filter_vertical_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:ga73a2c9af1200c68f0403e70e36c020d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa4818b571e98acd8696a1251b0d4e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gafa4818b571e98acd8696a1251b0d4e74">starpu_block_filter_vertical_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:gafa4818b571e98acd8696a1251b0d4e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae4f93ab3326ded72c3a80d337e6f4a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gaae4f93ab3326ded72c3a80d337e6f4a1">starpu_block_filter_depth_block</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:gaae4f93ab3326ded72c3a80d337e6f4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4b9ec529f67e5c300e7eed3e185fbaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gac4b9ec529f67e5c300e7eed3e185fbaf">starpu_block_filter_depth_block_shadow</a> (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *f, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:gac4b9ec529f67e5c300e7eed3e185fbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd670ea4e020b6ec14b3fe8bf8361582"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#gacd670ea4e020b6ec14b3fe8bf8361582">starpu_filter_nparts_compute_chunk_size_and_offset</a> (unsigned n, unsigned nparts, size_t elemsize, unsigned id, unsigned ld, unsigned *chunk_size, size_t *offset)</td></tr>
<tr class="separator:gacd670ea4e020b6ec14b3fe8bf8361582"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structstarpu__data__filter" id="structstarpu__data__filter"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structstarpu__data__filter">&#9670;&nbsp;</a></span>starpu_data_filter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct starpu_data_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Describe a data partitioning operation, to be given to <a class="el" href="group__API__Data__Partition.html#ga1363109ba0e36c1b6c7f1a40c9608791">starpu_data_partition()</a> </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a0794c07d3fbfab35b6889760699c7b91"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#a0794c07d3fbfab35b6889760699c7b91">filter_func</a> )(void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, unsigned id, unsigned nparts)</td></tr>
<tr class="separator:a0794c07d3fbfab35b6889760699c7b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec46586c98b5631201151b7582724e12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#aec46586c98b5631201151b7582724e12">nchildren</a></td></tr>
<tr class="separator:aec46586c98b5631201151b7582724e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2a185107bc8d8adc11557248cf454b"><td class="memItemLeft" align="right" valign="top">unsigned(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#aca2a185107bc8d8adc11557248cf454b">get_nchildren</a> )(struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> initial_handle)</td></tr>
<tr class="separator:aca2a185107bc8d8adc11557248cf454b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53586e4f8d91898a5d2317fe269e172"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#ac53586e4f8d91898a5d2317fe269e172">get_child_ops</a> )(struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, unsigned id)</td></tr>
<tr class="separator:ac53586e4f8d91898a5d2317fe269e172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb631e64e61f862647040852fdabe49"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#a6cb631e64e61f862647040852fdabe49">filter_arg</a></td></tr>
<tr class="separator:a6cb631e64e61f862647040852fdabe49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef5f824cca130aa51505b0551eca51c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__API__Data__Partition.html#a1ef5f824cca130aa51505b0551eca51c">filter_arg_ptr</a></td></tr>
<tr class="separator:a1ef5f824cca130aa51505b0551eca51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a id="a0794c07d3fbfab35b6889760699c7b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0794c07d3fbfab35b6889760699c7b91">&#9670;&nbsp;</a></span>filter_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* starpu_data_filter::filter_func) (void *father_interface, void *child_interface, struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, unsigned id, unsigned nparts)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill the <code>child_interface</code> structure with interface information for the <code>i</code> -th child of the parent <code>father_interface</code> (among <code>nparts</code>). The <code>filter</code> structure is provided, allowing to inspect the <a class="el" href="group__API__Data__Partition.html#a6cb631e64e61f862647040852fdabe49">starpu_data_filter::filter_arg</a> and <a class="el" href="group__API__Data__Partition.html#a1ef5f824cca130aa51505b0551eca51c">starpu_data_filter::filter_arg_ptr</a> parameters. The details of what needs to be filled in <code>child_interface</code> vary according to the data interface, but generally speaking: </p><ul>
<li>
<code>id</code> is usually just copied over from the father, when the sub data has the same structure as the father, e.g. a subvector is a vector, a submatrix is a matrix, etc. This is however not the case for instance when dividing a BCSR matrix into its dense blocks, which then are matrices.  </li>
<li>
<code>nx</code>, <code>ny</code> and alike are usually divided by the number of subdata, depending how the subdivision is done (e.g. nx division vs ny division for vertical matrix division vs horizontal matrix division).  </li>
<li>
<code>ld</code> for matrix interfaces are usually just copied over: the leading dimension (ld) usually does not change.  </li>
<li>
<code>elemsize</code> is usually just copied over.  </li>
<li>
<code>ptr</code>, the pointer to the data, has to be computed according to <code>i</code> and the father's <code>ptr</code>, so as to point to the start of the sub data. This should however be done only if the father has <code>ptr</code> different from NULL: in the OpenCL case notably, the <code>dev_handle</code> and <code>offset</code> fields are used instead.  </li>
<li>
<code>dev_handle</code> should be just copied over from the parent.  </li>
<li>
<code>offset</code> has to be computed according to <code>i</code> and the father's <code>offset</code>, so as to provide the offset of the start of the sub data. This is notably used for the OpenCL case. </li>
</ul>

</div>
</div>
<a id="aec46586c98b5631201151b7582724e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec46586c98b5631201151b7582724e12">&#9670;&nbsp;</a></span>nchildren</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned starpu_data_filter::nchildren</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of parts to partition the data into. </p>

</div>
</div>
<a id="aca2a185107bc8d8adc11557248cf454b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2a185107bc8d8adc11557248cf454b">&#9670;&nbsp;</a></span>get_nchildren</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned(* starpu_data_filter::get_nchildren) (struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, <a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> initial_handle)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of children. This can be used instead of <a class="el" href="group__API__Data__Partition.html#aec46586c98b5631201151b7582724e12">starpu_data_filter::nchildren</a> when the number of children depends on the actual data (e.g. the number of blocks in a sparse matrix). </p>

</div>
</div>
<a id="ac53586e4f8d91898a5d2317fe269e172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53586e4f8d91898a5d2317fe269e172">&#9670;&nbsp;</a></span>get_child_ops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a>*(* starpu_data_filter::get_child_ops) (struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *, unsigned id)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When children use different data interface, return which interface is used by child number <code>id</code>. </p>

</div>
</div>
<a id="a6cb631e64e61f862647040852fdabe49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb631e64e61f862647040852fdabe49">&#9670;&nbsp;</a></span>filter_arg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned starpu_data_filter::filter_arg</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Additional parameter for the filter function </p>

</div>
</div>
<a id="a1ef5f824cca130aa51505b0551eca51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef5f824cca130aa51505b0551eca51c">&#9670;&nbsp;</a></span>filter_arg_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* starpu_data_filter::filter_arg_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Additional pointer parameter for the filter function, such as the sizes of the different parts. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1363109ba0e36c1b6c7f1a40c9608791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1363109ba0e36c1b6c7f1a40c9608791">&#9670;&nbsp;</a></span>starpu_data_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request the partitioning of <code>initial_handle</code> into several subdata according to the filter <code>f</code>.</p>
<p>Here an example of how to use the function. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> f =</div><div class="line">{</div><div class="line">  .<a class="code" href="group__API__Data__Partition.html#a0794c07d3fbfab35b6889760699c7b91">filter_func</a> = <a class="code" href="group__API__Data__Partition.html#ga8c86b2af9e0806e631c1cbb5d506506b">starpu_matrix_filter_block</a>,</div><div class="line">  .nchildren = nslicesx</div><div class="line">};</div><div class="line"><a class="code" href="group__API__Data__Partition.html#ga1363109ba0e36c1b6c7f1a40c9608791">starpu_data_partition</a>(A_handle, &amp;f);</div></div><!-- fragment --> 
</div>
</div>
<a id="gae80794b9cad7855a3ee54a4361f656ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae80794b9cad7855a3ee54a4361f656ed">&#9670;&nbsp;</a></span>starpu_data_unpartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_unpartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>gathering_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unapply the filter which has been applied to <code>root_data</code>, thus unpartitioning the data. The pieces of data are collected back into one big piece in the <code>gathering_node</code> (usually <a class="el" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>). Tasks working on the partitioned data will be waited for by <a class="el" href="group__API__Data__Partition.html#gae80794b9cad7855a3ee54a4361f656ed">starpu_data_unpartition()</a>.</p>
<p>Here an example of how to use the function. </p><div class="fragment"><div class="line"><a class="code" href="group__API__Data__Partition.html#gae80794b9cad7855a3ee54a4361f656ed">starpu_data_unpartition</a>(A_handle, <a class="code" href="group__API__Codelet__And__Tasks.html#ga64855af2ea04f74a1a261724b3b79046">STARPU_MAIN_RAM</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga29e07c2c0604da63e7746a8018d8a62f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29e07c2c0604da63e7746a8018d8a62f">&#9670;&nbsp;</a></span>starpu_data_get_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> starpu_data_get_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <code>i</code> -th child of the given <code>handle</code>, which must have been partitionned beforehand. </p>

</div>
</div>
<a id="ga6a3f729055f14384e7397d2815a2c9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a3f729055f14384e7397d2815a2c9a5">&#9670;&nbsp;</a></span>starpu_data_get_nb_children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int starpu_data_get_nb_children </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of children <code>handle</code> has been partitioned into. </p>

</div>
</div>
<a id="gac24101bbe28b1d7d4a0874d349ba8979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac24101bbe28b1d7d4a0874d349ba8979">&#9670;&nbsp;</a></span>starpu_data_get_sub_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> starpu_data_get_sub_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After partitioning a StarPU data by applying a filter, <a class="el" href="group__API__Data__Partition.html#gac24101bbe28b1d7d4a0874d349ba8979">starpu_data_get_sub_data()</a> can be used to get handles for each of the data portions. <code>root_data</code> is the parent data that was partitioned. <code>depth</code> is the number of filters to traverse (in case several filters have been applied, to e.g. partition in row blocks, and then in column blocks), and the subsequent parameters are the indexes. The function returns a handle to the subdata.</p>
<p>Here an example of how to use the function. </p><div class="fragment"><div class="line">h = <a class="code" href="group__API__Data__Partition.html#gac24101bbe28b1d7d4a0874d349ba8979">starpu_data_get_sub_data</a>(A_handle, 1, taskx);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7904efb86ab3f9d6d682a3a3be3646fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7904efb86ab3f9d6d682a3a3be3646fe">&#9670;&nbsp;</a></span>starpu_data_vget_sub_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> starpu_data_vget_sub_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="group__API__Data__Partition.html#gac24101bbe28b1d7d4a0874d349ba8979">starpu_data_get_sub_data()</a> but use a <code>va_list</code> for the parameter list. </p>

</div>
</div>
<a id="ga551d6fa7fead5b9f7c8a85b1f9885e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga551d6fa7fead5b9f7c8a85b1f9885e91">&#9670;&nbsp;</a></span>starpu_data_map_filters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_map_filters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nfilters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply <code>nfilters</code> filters to the handle designated by <code>root_handle</code> recursively. <code>nfilters</code> pointers to variables of the type <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> should be given. </p>

</div>
</div>
<a id="ga15a28291a5045ef7ed3c93afc94ed248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15a28291a5045ef7ed3c93afc94ed248">&#9670;&nbsp;</a></span>starpu_data_vmap_filters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_vmap_filters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nfilters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply <code>nfilters</code> filters to the handle designated by <code>root_handle</code> recursively. Use a <code>va_list</code> of pointers to variables of the type <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a>. </p>

</div>
</div>
<a id="gaa4407a8734e1fbdbb63b83351769476c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4407a8734e1fbdbb63b83351769476c">&#9670;&nbsp;</a></span>starpu_data_partition_plan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition_plan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plan to partition <code>initial_handle</code> into several subdata according to the filter <code>f</code>. The handles are returned into the <code>children</code> array, which has to be the same size as the number of parts described in <code>f</code>. These handles are not immediately usable, <a class="el" href="group__API__Data__Partition.html#ga994cbae9c619b070f8d219f6bfffff06">starpu_data_partition_submit()</a> has to be called to submit the actual partitioning.</p>
<p>Here is an example of how to use the function: </p><div class="fragment"><div class="line"><a class="code" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> children[nslicesx];</div><div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> f =</div><div class="line">{</div><div class="line">  .<a class="code" href="group__API__Data__Partition.html#a0794c07d3fbfab35b6889760699c7b91">filter_func</a> = <a class="code" href="group__API__Data__Partition.html#ga8c86b2af9e0806e631c1cbb5d506506b">starpu_matrix_filter_block</a>,</div><div class="line">  .nchildren = nslicesx</div><div class="line">  };</div><div class="line">  <a class="code" href="group__API__Data__Partition.html#gaa4407a8734e1fbdbb63b83351769476c">starpu_data_partition_plan</a>(A_handle, &amp;f, children);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga994cbae9c619b070f8d219f6bfffff06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga994cbae9c619b070f8d219f6bfffff06">&#9670;&nbsp;</a></span>starpu_data_partition_submit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Submit the actual partitioning of <code>initial_handle</code> into the <code>nparts</code> <code>children</code> handles. This call is asynchronous, it only submits that the partitioning should be done, so that the <code>children</code> handles can now be used to submit tasks, and <code>initial_handle</code> can not be used to submit tasks any more (to guarantee coherency). For instance, </p><div class="fragment"><div class="line"><a class="code" href="group__API__Data__Partition.html#ga994cbae9c619b070f8d219f6bfffff06">starpu_data_partition_submit</a>(A_handle, nslicesx, children);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7fcf158f5196d62610c5017993442c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fcf158f5196d62610c5017993442c53">&#9670;&nbsp;</a></span>starpu_data_partition_readonly_submit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition_readonly_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="group__API__Data__Partition.html#ga994cbae9c619b070f8d219f6bfffff06">starpu_data_partition_submit()</a>, but do not invalidate <code>initial_handle</code>. This allows to continue using it, but the application has to be careful not to write to <code>initial_handle</code> or <code>children</code> handles, only read from them, since the coherency is otherwise not guaranteed. This thus allows to submit various tasks which concurrently read from various partitions of the data.</p>
<p>When the application wants to write to <code>initial_handle</code> again, it should call <a class="el" href="group__API__Data__Partition.html#ga46d2b144a7de2e17d17b1383ef5f522d">starpu_data_unpartition_submit()</a>, which will properly add dependencies between the reads on the <code>children</code> and the writes to be submitted.</p>
<p>If instead the application wants to write to <code>children</code> handles, it should call <a class="el" href="group__API__Data__Partition.html#ga8a26c673507a7de484071e0926cb5638">starpu_data_partition_readwrite_upgrade_submit()</a>, which will correctly add dependencies between the reads on the <code>initial_handle</code> and the writes to be submitted. </p>

</div>
</div>
<a id="ga8a26c673507a7de484071e0926cb5638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a26c673507a7de484071e0926cb5638">&#9670;&nbsp;</a></span>starpu_data_partition_readwrite_upgrade_submit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition_readwrite_upgrade_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assume that a partitioning of <code>initial_handle</code> has already been submited in readonly mode through <a class="el" href="group__API__Data__Partition.html#ga7fcf158f5196d62610c5017993442c53">starpu_data_partition_readonly_submit()</a>, and will upgrade that partitioning into read-write mode for the <code>children</code>, by invalidating <code>initial_handle</code>, and adding the necessary dependencies. </p>

</div>
</div>
<a id="ga46d2b144a7de2e17d17b1383ef5f522d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46d2b144a7de2e17d17b1383ef5f522d">&#9670;&nbsp;</a></span>starpu_data_unpartition_submit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_unpartition_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gathering_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assuming that <code>initial_handle</code> is partitioned into <code>children</code>, submit an unpartitionning of <code>initial_handle</code>, i.e. submit a gathering of the pieces on the requested <code>gathering_node</code> memory node, and submit an invalidation of the children. </p>

</div>
</div>
<a id="gac1e66049a48764a29d867a02bcc9d0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1e66049a48764a29d867a02bcc9d0ce">&#9670;&nbsp;</a></span>starpu_data_unpartition_readonly_submit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_unpartition_readonly_submit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gathering_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="group__API__Data__Partition.html#ga994cbae9c619b070f8d219f6bfffff06">starpu_data_partition_submit()</a>, but do not invalidate <code>initial_handle</code>. This allows to continue using it, but the application has to be careful not to write to <code>initial_handle</code> or <code>children</code> handles, only read from them, since the coherency is otherwise not guaranteed. This thus allows to submit various tasks which concurrently read from various partitions of the data. </p>

</div>
</div>
<a id="gac4f0b5ce7cdee16c1311595e9ca53e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4f0b5ce7cdee16c1311595e9ca53e98">&#9670;&nbsp;</a></span>starpu_data_partition_clean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition_clean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>root_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the partition planning established between <code>root_data</code> and <code>children</code> with <a class="el" href="group__API__Data__Partition.html#gaa4407a8734e1fbdbb63b83351769476c">starpu_data_partition_plan()</a>. This will notably submit an unregister all the <code>children</code>, which can thus not be used any more afterwards. </p>

</div>
</div>
<a id="gaea478569a1a283c4cf7ef3920334b82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea478569a1a283c4cf7ef3920334b82e">&#9670;&nbsp;</a></span>starpu_data_unpartition_submit_sequential_consistency_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_unpartition_submit_sequential_consistency_cb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gather_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sequential_consistency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>callback_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callback_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="group__API__Data__Partition.html#gab931b6026c134fa98bb72fb2f7c0c67f">starpu_data_unpartition_submit_sequential_consistency()</a> but allow to specify a callback function for the unpartitiong task </p>

</div>
</div>
<a id="gab915b6daaa4323e433688e7888e921d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab915b6daaa4323e433688e7888e921d6">&#9670;&nbsp;</a></span>starpu_data_partition_submit_sequential_consistency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_partition_submit_sequential_consistency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sequential_consistency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="group__API__Data__Partition.html#ga994cbae9c619b070f8d219f6bfffff06">starpu_data_partition_submit()</a> but also allow to specify the coherency to be used for the main data <code>initial_handle</code> through the parameter <code>sequential_consistency</code>. </p>

</div>
</div>
<a id="gab931b6026c134fa98bb72fb2f7c0c67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab931b6026c134fa98bb72fb2f7c0c67f">&#9670;&nbsp;</a></span>starpu_data_unpartition_submit_sequential_consistency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_data_unpartition_submit_sequential_consistency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>initial_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a> *&#160;</td>
          <td class="paramname"><em>children</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gathering_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sequential_consistency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="group__API__Data__Partition.html#ga46d2b144a7de2e17d17b1383ef5f522d">starpu_data_unpartition_submit()</a> but also allow to specify the coherency to be used for the main data <code>initial_handle</code> through the parameter <code>sequential_consistency</code>. </p>

</div>
</div>
<a id="ga0e1bee4821237529d554605d333e9109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e1bee4821237529d554605d333e9109">&#9670;&nbsp;</a></span>starpu_bcsr_filter_canonical_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_bcsr_filter_canonical_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a block-sparse matrix into dense matrices. <a class="el" href="group__API__Data__Partition.html#ac53586e4f8d91898a5d2317fe269e172">starpu_data_filter::get_child_ops</a> needs to be set to <a class="el" href="group__API__Data__Partition.html#ga47aeeae0c17c6ff3ef961ec267b28d61">starpu_bcsr_filter_canonical_block_child_ops()</a> and <a class="el" href="group__API__Data__Partition.html#aca2a185107bc8d8adc11557248cf454b">starpu_data_filter::get_nchildren</a> set to <a class="el" href="group__API__Data__Partition.html#gaa91c8e107f03a35f4574395fde1c63a4">starpu_bcsr_filter_canonical_block_get_nchildren()</a>. </p>

</div>
</div>
<a id="gaa91c8e107f03a35f4574395fde1c63a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa91c8e107f03a35f4574395fde1c63a4">&#9670;&nbsp;</a></span>starpu_bcsr_filter_canonical_block_get_nchildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned starpu_bcsr_filter_canonical_block_get_nchildren </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API__Data__Management.html#gad6bed33cdb76ef504efcdf05e5788076">starpu_data_handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of children obtained with <a class="el" href="group__API__Data__Partition.html#ga0e1bee4821237529d554605d333e9109">starpu_bcsr_filter_canonical_block()</a>. </p>

</div>
</div>
<a id="ga47aeeae0c17c6ff3ef961ec267b28d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47aeeae0c17c6ff3ef961ec267b28d61">&#9670;&nbsp;</a></span>starpu_bcsr_filter_canonical_block_child_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__API__Data__Interfaces.html#structstarpu__data__interface__ops">starpu_data_interface_ops</a>* starpu_bcsr_filter_canonical_block_child_ops </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the child_ops of the partition obtained with <a class="el" href="group__API__Data__Partition.html#ga0e1bee4821237529d554605d333e9109">starpu_bcsr_filter_canonical_block()</a>. </p>

</div>
</div>
<a id="ga4b910784c11bb46599fe9cb8928418f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b910784c11bb46599fe9cb8928418f2">&#9670;&nbsp;</a></span>starpu_bcsr_filter_vertical_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_bcsr_filter_vertical_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a block-sparse matrix into block-sparse matrices.</p>
<p>The split is done along the leading dimension, i.e. along adjacent nnz blocks. </p>

</div>
</div>
<a id="ga554a2fb14fdee9353364c39f36ee3a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga554a2fb14fdee9353364c39f36ee3a6f">&#9670;&nbsp;</a></span>starpu_csr_filter_vertical_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_csr_filter_vertical_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a block-sparse matrix into vertical block-sparse matrices. </p>

</div>
</div>
<a id="ga8c86b2af9e0806e631c1cbb5d506506b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c86b2af9e0806e631c1cbb5d506506b">&#9670;&nbsp;</a></span>starpu_matrix_filter_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_matrix_filter_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a dense Matrix along the x dimension, thus getting (x/<code>nparts</code> ,y) matrices. If <code>nparts</code> does not divide x, the last submatrix contains the remainder. </p>

</div>
</div>
<a id="ga88fbca61843b76314e39a2c0f8b93d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88fbca61843b76314e39a2c0f8b93d6c">&#9670;&nbsp;</a></span>starpu_matrix_filter_block_shadow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_matrix_filter_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a dense Matrix along the x dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting ((x-2*shadow)/<code>nparts</code> +2*shadow,y) matrices. If <code>nparts</code> does not divide x-2*shadow, the last submatrix contains the remainder.</p>
<p><b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. A usage example is available in examples/filters/shadow2d.c </p>

</div>
</div>
<a id="ga2925be576ac7d597ecead381ff32a894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2925be576ac7d597ecead381ff32a894">&#9670;&nbsp;</a></span>starpu_matrix_filter_vertical_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_matrix_filter_vertical_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a dense Matrix along the y dimension, thus getting (x,y/<code>nparts</code>) matrices. If <code>nparts</code> does not divide y, the last submatrix contains the remainder. </p>

</div>
</div>
<a id="ga7132923bd901e0e4254cc0b20d49997a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7132923bd901e0e4254cc0b20d49997a">&#9670;&nbsp;</a></span>starpu_matrix_filter_vertical_block_shadow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_matrix_filter_vertical_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a dense Matrix along the y dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting (x,(y-2*shadow)/<code>nparts</code> +2*shadow) matrices. If <code>nparts</code> does not divide y-2*shadow, the last submatrix contains the remainder.</p>
<p><b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. A usage example is available in examples/filters/shadow2d.c </p>

</div>
</div>
<a id="ga212189d3b83dfa4e225609b5f2bf8461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga212189d3b83dfa4e225609b5f2bf8461">&#9670;&nbsp;</a></span>starpu_vector_filter_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_vector_filter_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return in <code>child_interface</code> the <code>id</code> th element of the vector represented by <code>father_interface</code> once partitioned in <code>nparts</code> chunks of equal size. </p>

</div>
</div>
<a id="gaab49915dc0462c1b145bfb0a9ce4cf52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab49915dc0462c1b145bfb0a9ce4cf52">&#9670;&nbsp;</a></span>starpu_vector_filter_block_shadow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_vector_filter_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return in <code>child_interface</code> the <code>id</code> th element of the vector represented by <code>father_interface</code> once partitioned in <code>nparts</code> chunks of equal size with a shadow border <code>filter_arg_ptr</code>, thus getting a vector of size <code>(n-2*shadow)/nparts+2*shadow</code>. The <code>filter_arg_ptr</code> field of <code>f</code> must be the shadow size casted into <code>void*</code>.</p>
<p><b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. An usage example is available in examples/filters/shadow.c </p>

</div>
</div>
<a id="ga6c3d612b5161b5f72282b4bf9390525a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c3d612b5161b5f72282b4bf9390525a">&#9670;&nbsp;</a></span>starpu_vector_filter_list_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_vector_filter_list_long </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return in <code>child_interface</code> the <code>id</code> th element of the vector represented by <code>father_interface</code> once partitioned into <code>nparts</code> chunks according to the <code>filter_arg_ptr</code> field of <code>f</code>. The <code>filter_arg_ptr</code> field must point to an array of <code>nparts</code> long elements, each of which specifies the number of elements in each chunk of the partition. </p>

</div>
</div>
<a id="gab9fa487bfff5ccdd59210bdde65a11db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9fa487bfff5ccdd59210bdde65a11db">&#9670;&nbsp;</a></span>starpu_vector_filter_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_vector_filter_list </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return in <code>child_interface</code> the <code>id</code> th element of the vector represented by <code>father_interface</code> once partitioned into <code>nparts</code> chunks according to the <code>filter_arg_ptr</code> field of <code>f</code>. The <code>filter_arg_ptr</code> field must point to an array of <code>nparts</code> uint32_t elements, each of which specifies the number of elements in each chunk of the partition. </p>

</div>
</div>
<a id="gab639622ea4929c36df704a0bebfd3fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab639622ea4929c36df704a0bebfd3fac">&#9670;&nbsp;</a></span>starpu_vector_filter_divide_in_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_vector_filter_divide_in_2 </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return in <code>child_interface</code> the <code>id</code> th element of the vector represented by <code>father_interface</code> once partitioned in <code>2</code> chunks of equal size, ignoring nparts. Thus, <code>id</code> must be <code>0</code> or <code>1</code>. </p>

</div>
</div>
<a id="ga1a265ffca51fae58701832a4daa53bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a265ffca51fae58701832a4daa53bd9">&#9670;&nbsp;</a></span>starpu_block_filter_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a block along the X dimension, thus getting (x/<code>nparts</code> ,y,z) 3D matrices. If <code>nparts</code> does not divide x, the last submatrix contains the remainder. </p>

</div>
</div>
<a id="ga7cc8832e25f2f4049ba5a0053b122dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cc8832e25f2f4049ba5a0053b122dd9">&#9670;&nbsp;</a></span>starpu_block_filter_block_shadow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a block along the X dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting ((x-2*shadow)/<code>nparts</code> +2*shadow,y,z) blocks. If <code>nparts</code> does not divide x, the last submatrix contains the remainder.</p>
<p><b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. </p>

</div>
</div>
<a id="ga73a2c9af1200c68f0403e70e36c020d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73a2c9af1200c68f0403e70e36c020d0">&#9670;&nbsp;</a></span>starpu_block_filter_vertical_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_vertical_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a block along the Y dimension, thus getting (x,y/<code>nparts</code> ,z) blocks. If <code>nparts</code> does not divide y, the last submatrix contains the remainder. </p>

</div>
</div>
<a id="gafa4818b571e98acd8696a1251b0d4e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa4818b571e98acd8696a1251b0d4e74">&#9670;&nbsp;</a></span>starpu_block_filter_vertical_block_shadow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_vertical_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a block along the Y dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting (x,(y-2*shadow)/<code>nparts</code> +2*shadow,z) 3D matrices. If <code>nparts</code> does not divide y, the last submatrix contains the remainder.</p>
<p><b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. </p>

</div>
</div>
<a id="gaae4f93ab3326ded72c3a80d337e6f4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae4f93ab3326ded72c3a80d337e6f4a1">&#9670;&nbsp;</a></span>starpu_block_filter_depth_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_depth_block </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a block along the Z dimension, thus getting (x,y,z/<code>nparts</code>) blocks. If <code>nparts</code> does not divide z, the last submatrix contains the remainder. </p>

</div>
</div>
<a id="gac4b9ec529f67e5c300e7eed3e185fbaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4b9ec529f67e5c300e7eed3e185fbaf">&#9670;&nbsp;</a></span>starpu_block_filter_depth_block_shadow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_block_filter_depth_block_shadow </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>father_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>child_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__API__Data__Partition.html#structstarpu__data__filter">starpu_data_filter</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a block along the Z dimension, with a shadow border <code>filter_arg_ptr</code>, thus getting (x,y,(z-2*shadow)/<code>nparts</code> +2*shadow) blocks. If <code>nparts</code> does not divide z, the last submatrix contains the remainder.</p>
<p><b>IMPORTANT</b>: This can only be used for read-only access, as no coherency is enforced for the shadowed parts. </p>

</div>
</div>
<a id="gacd670ea4e020b6ec14b3fe8bf8361582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd670ea4e020b6ec14b3fe8bf8361582">&#9670;&nbsp;</a></span>starpu_filter_nparts_compute_chunk_size_and_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void starpu_filter_nparts_compute_chunk_size_and_offset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elemsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>chunk_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an integer <code>n</code>, <code>n</code> the number of parts it must be divided in, <code>id</code> the part currently considered, determines the <code>chunk_size</code> and the <code>offset</code>, taking into account the size of the elements stored in the data structure <code>elemsize</code> and <code>ld</code>, the leading dimension, which is most often 1. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 22 2021 15:02:18 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
