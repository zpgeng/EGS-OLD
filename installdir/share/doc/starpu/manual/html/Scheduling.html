<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StarPU Handbook: Scheduling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('Scheduling.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Scheduling </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="TaskSchedulingPolicy"></a>
Task Scheduling Policies</h1>
<p>The basics of the scheduling policy are the following:</p>
<ul>
<li>
The scheduler gets to schedule tasks (<code>push</code> operation) when they become ready to be executed, i.e. they are not waiting for some tags, data dependencies or task dependencies. </li>
<li>
Workers pull tasks (<code>pop</code> operation) one by one from the scheduler. </li>
</ul>
<p>This means scheduling policies usually contain at least one queue of tasks to store them between the time when they become available, and the time when a worker gets to grab them.</p>
<p>By default, StarPU uses the work-stealing scheduler <code>lws</code>. This is because it provides correct load balance and locality even if the application codelets do not have performance models. Other non-modelling scheduling policies can be selected among the list below, thanks to the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SCHED">STARPU_SCHED</a>. For instance <code>export STARPU_SCHED=dmda</code> . Use <code>help</code> to get the list of available schedulers.</p>
<h2><a class="anchor" id="NonPerformanceModelingPolicies"></a>
Non Performance Modelling Policies</h2>
<ul>
<li>The <b>eager</b> scheduler uses a central task queue, from which all workers draw tasks to work on concurrently. This however does not permit to prefetch data since the scheduling decision is taken late. If a task has a non-0 priority, it is put at the front of the queue.</li>
<li>The <b>random</b> scheduler uses a queue per worker, and distributes tasks randomly according to assumed worker overall performance.</li>
<li>The <b>ws</b> (work stealing) scheduler uses a queue per worker, and schedules a task on the worker which released it by default. When a worker becomes idle, it steals a task from the most loaded worker.</li>
<li>The <b>lws</b> (locality work stealing) scheduler uses a queue per worker, and schedules a task on the worker which released it by default. When a worker becomes idle, it steals a task from neighbour workers. It also takes into account priorities.</li>
<li>The <b>prio</b> scheduler also uses a central task queue, but sorts tasks by priority specified by the programmer.</li>
<li>The <b>heteroprio</b> scheduler uses different priorities for the different processing units. This scheduler must be configured to work correclty and to expect high-performance as described in the corresponding section.</li>
</ul>
<h2><a class="anchor" id="DMTaskSchedulingPolicy"></a>
Performance Model-Based Task Scheduling Policies</h2>
<p>If (<b>and only if</b>) your application <b>codelets have performance models</b> (<a class="el" href="OnlinePerformanceTools.html#PerformanceModelExample">Performance Model Example</a>), you should change the scheduler thanks to the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SCHED">STARPU_SCHED</a>, to select one of the policies below, in order to take advantage of StarPU's performance modelling. For instance <code>export STARPU_SCHED=dmda</code> . Use <code>help</code> to get the list of available schedulers.</p>
<p><b>Note:</b> Depending on the performance model type chosen, some preliminary calibration runs may be needed for the model to converge. If the calibration has not been done, or is insufficient yet, or if no performance model is specified for a codelet, every task built from this codelet will be scheduled using an <b>eager</b> fallback policy.</p>
<p><b>Troubleshooting:</b> Configuring and recompiling StarPU using the <a class="el" href="CompilationConfiguration.html#enable-verbose">--enable-verbose</a> <code>configure</code> option displays some statistics at the end of execution about the percentage of tasks which have been scheduled by a DM* family policy using performance model hints. A low or zero percentage may be the sign that performance models are not converging or that codelets do not have performance models enabled.</p>
<ul>
<li>The <b>dm</b> (deque model) scheduler takes task execution performance models into account to perform a HEFT-similar scheduling strategy: it schedules tasks where their termination time will be minimal. The difference with HEFT is that <b>dm</b> schedules tasks as soon as they become available, and thus in the order they become available, without taking priorities into account.</li>
<li>The <b>dmda</b> (deque model data aware) scheduler is similar to dm, but it also takes into account data transfer time.</li>
<li>The <b>dmdap</b> (deque model data aware prio) scheduler is similar to dmda, except that it sorts tasks by priority order, which allows to become even closer to HEFT by respecting priorities after having made the scheduling decision (but it still schedules tasks in the order they become available).</li>
<li>The <b>dmdar</b> (deque model data aware ready) scheduler is similar to dmda, but it also privileges tasks whose data buffers are already available on the target device.</li>
<li>The <b>dmdas</b> combines dmdap and dmdas: it sorts tasks by priority order, but for a given priority it will privilege tasks whose data buffers are already available on the target device.</li>
<li>The <b>dmdasd</b> (deque model data aware sorted decision) scheduler is similar to dmdas, except that when scheduling a task, it takes into account its priority when computing the minimum completion time, since this task may get executed before others, and thus the latter should be ignored.</li>
<li>The <b>heft</b> (heterogeneous earliest finish time) scheduler is a deprecated alias for <b>dmda</b>.</li>
<li>The <b>pheft</b> (parallel HEFT) scheduler is similar to dmda, it also supports parallel tasks (still experimental). Should not be used when several contexts using it are being executed simultaneously.</li>
<li>The <b>peager</b> (parallel eager) scheduler is similar to eager, it also supports parallel tasks (still experimental). Should not be used when several contexts using it are being executed simultaneously.</li>
</ul>
<h2><a class="anchor" id="ExistingModularizedSchedulers"></a>
Modularized Schedulers</h2>
<p>StarPU provides a powerful way to implement schedulers, as documented in <a class="el" href="HowToDefineANewSchedulingPolicy.html#DefiningANewModularSchedulingPolicy">Defining A New Modular Scheduling Policy</a> . It is currently shipped with the following pre-defined Modularized Schedulers :</p>
<ul>
<li><b>modular-eager</b> , <b>modular-eager-prefetching</b> are eager-based Schedulers (without and with prefetching)), they are <br />
naive schedulers, which try to map a task on the first available resource they find. The prefetching variant queues several tasks in advance to be able to do data prefetching. This may however degrade load balancing a bit.</li>
<li><b>modular-prio</b>, <b>modular-prio-prefetching</b>, <b>modular-eager-prio</b> are prio-based Schedulers (without / with prefetching):, similar to Eager-Based Schedulers. Can handle tasks which have a defined priority and schedule them accordingly. The <b>modular-eager-prio</b> variant integrates the eager and priority queue in a single component. This allows it to do a better job at pushing tasks.</li>
<li><b>modular-random</b>, <b>modular-random-prio</b>, <b>modular-random-prefetching</b>, <b>modular-random-prio-prefetching</b> are random-based Schedulers (without/with prefetching) : <br />
Select randomly a resource to be mapped on for each task.</li>
<li><b>modular-ws</b>) implements Work Stealing: Maps tasks to workers in round robin, but allows workers to steal work from other workers.</li>
<li><b>modular-heft</b>, <b>modular-heft2</b>, and <b>modular-heft-prio</b> are HEFT Schedulers : <br />
Maps tasks to workers using a heuristic very close to Heterogeneous Earliest Finish Time. It needs that every task submitted to StarPU have a defined performance model (<a class="el" href="CheckListWhenPerformanceAreNotThere.html#PerformanceModelCalibration">Performance Model Calibration</a>) to work efficiently, but can handle tasks without a performance model. <b>modular-heft</b> just takes tasks by order. <b>modular-heft2</b> takes at most 5 tasks of the same priority and checks which one fits best. <b>modular-heft-prio</b> is similar to <b>modular-heft</b>, but only decides the memory node, not the exact worker, just pushing tasks to one central queue per memory node. By default, they sort tasks by priorities and privilege running first a task which has most of its data already available on the target. These can however be changed with <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SCHED_SORTED_ABOVE">STARPU_SCHED_SORTED_ABOVE</a>, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SCHED_SORTED_BELOW">STARPU_SCHED_SORTED_BELOW</a>, and <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SCHED_READY">STARPU_SCHED_READY</a> .</li>
<li><b>modular-heteroprio</b> is a Heteroprio Scheduler: <br />
Maps tasks to worker similarly to HEFT, but first attribute accelerated tasks to GPUs, then not-so-accelerated tasks to CPUs.</li>
</ul>
<h1><a class="anchor" id="TaskDistributionVsDataTransfer"></a>
Task Distribution Vs Data Transfer</h1>
<p>Distributing tasks to balance the load induces data transfer penalty. StarPU thus needs to find a balance between both. The target function that the scheduler <code>dmda</code> of StarPU tries to minimize is <code>alpha * T_execution + beta * T_data_transfer</code>, where <code>T_execution</code> is the estimated execution time of the codelet (usually accurate), and <code>T_data_transfer</code> is the estimated data transfer time. The latter is estimated based on bus calibration before execution start, i.e. with an idle machine, thus without contention. You can force bus re-calibration by running the tool <code>starpu_calibrate_bus</code>. The beta parameter defaults to <code>1</code>, but it can be worth trying to tweak it by using <code>export STARPU_SCHED_BETA=2</code> (<a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SCHED_BETA">STARPU_SCHED_BETA</a>) for instance, since during real application execution, contention makes transfer times bigger. This is of course imprecise, but in practice, a rough estimation already gives the good results that a precise estimation would give.</p>
<h1><a class="anchor" id="Energy-basedScheduling"></a>
Energy-based Scheduling</h1>
<p>Note: by default StarPU does not let CPU workers sleep, to let them react to task release as quickly as possible. For idle time to really let CPU cores save energy, one needs to use the <a class="el" href="CompilationConfiguration.html#enable-blocking-drivers">--enable-blocking-drivers</a> configuration option.</p>
<p>If the application can provide some energy consumption performance model (through the field <a class="el" href="group__API__Codelet__And__Tasks.html#af8fa998af7fac8cea705533162dcbf35">starpu_codelet::energy_model</a>), StarPU will take it into account when distributing tasks. The target function that the scheduler <code>dmda</code> minimizes becomes <code>alpha * T_execution + beta * T_data_transfer + gamma * Consumption</code> , where <code>Consumption</code> is the estimated task consumption in Joules. To tune this parameter, use <code>export STARPU_SCHED_GAMMA=3000</code> (<a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SCHED_GAMMA">STARPU_SCHED_GAMMA</a>) for instance, to express that each Joule (i.e kW during 1000us) is worth 3000us execution time penalty. Setting <code>alpha</code> and <code>beta</code> to zero permits to only take into account energy consumption.</p>
<p>This is however not sufficient to correctly optimize energy: the scheduler would simply tend to run all computations on the most energy-conservative processing unit. To account for the consumption of the whole machine (including idle processing units), the idle power of the machine should be given by setting <code>export STARPU_IDLE_POWER=200</code> (<a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_IDLE_POWER">STARPU_IDLE_POWER</a>) for 200W, for instance. This value can often be obtained from the machine power supplier, e.g. by running</p>
<p><code>ipmitool -I lanplus -H mymachine-ipmi -U myuser -P mypasswd sdr type Current</code></p>
<p>The energy actually consumed by the total execution can be displayed by setting <code>export STARPU_PROFILING=1 STARPU_WORKER_STATS=1</code> (<a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_PROFILING">STARPU_PROFILING</a> and <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_WORKER_STATS">STARPU_WORKER_STATS</a>).</p>
<p>For OpenCL devices, on-line task consumption measurement is currently supported through the <code>CL_PROFILING_POWER_CONSUMED</code> OpenCL extension, implemented in the MoviSim simulator.</p>
<p>For CUDA devices, on-line task consumption measurement is supported on V100 cards and beyond. This however only works for quite long tasks, since the measurement granularity is about 10ms.</p>
<p>Applications can however provide explicit measurements by using the function <a class="el" href="group__API__Performance__Model.html#gaecb9341bff471557abbb63a966449481">starpu_perfmodel_update_history()</a> (examplified in <a class="el" href="OnlinePerformanceTools.html#PerformanceModelExample">Performance Model Example</a> with the <code>energy_model</code> performance model). Fine-grain measurement is often not feasible with the feedback provided by the hardware, so the user can for instance run a given task a thousand times, measure the global consumption for that series of tasks, divide it by a thousand, repeat for varying kinds of tasks and task sizes, and eventually feed StarPU with these manual measurements through <a class="el" href="group__API__Performance__Model.html#gaecb9341bff471557abbb63a966449481">starpu_perfmodel_update_history()</a>. For instance, for CUDA devices, <code>nvidia-smi -q -d POWER</code> can be used to get the current consumption in Watt. Multiplying this value by the average duration of a single task gives the consumption of the task in Joules, which can be given to <a class="el" href="group__API__Performance__Model.html#gaecb9341bff471557abbb63a966449481">starpu_perfmodel_update_history()</a>.</p>
<p>Another way to provide the energy performance is to define a perfmodel with <a class="el" href="group__API__Performance__Model.html#afe2d561aaba7bf1ad1cf03974ee8c53c">starpu_perfmodel::type</a> <a class="el" href="group__API__Performance__Model.html#ggae161a7cae376f3fc831a2b764e8144e6a98a0f2cda640f231009f262e676f4851">STARPU_PER_ARCH</a>, and set the <a class="el" href="group__API__Performance__Model.html#a4efccf0f3badb8eb35a07704b0e3ef01">starpu_perfmodel::arch_cost_function</a> field to a function which shall return the estimated consumption of the task in Joules. Such a function can for instance use <a class="el" href="group__API__Scheduling__Policy.html#ga2dc83adec9e479e967a1d1c2ae40f916">starpu_task_expected_length()</a> on the task (in Âµs), multiplied by the typical power consumption of the device, e.g. in W, and divided by 1000000. to get Joules.</p>
<h1><a class="anchor" id="StaticScheduling"></a>
Static Scheduling</h1>
<p>In some cases, one may want to force some scheduling, for instance force a given set of tasks to GPU0, another set to GPU1, etc. while letting some other tasks be scheduled on any other device. This can indeed be useful to guide StarPU into some work distribution, while still letting some degree of dynamism. For instance, to force execution of a task on CUDA0:</p>
<div class="fragment"><div class="line">task-&gt;execute_on_a_specific_worker = 1;</div><div class="line">task-&gt;workerid = <a class="code" href="group__API__Workers__Properties.html#gab0ffe5622c5980444226f1ed8d6fee71">starpu_worker_get_by_type</a>(<a class="code" href="group__API__Workers__Properties.html#gga173d616aefe98c33a47a847fd2fca37da26ced4e9dfc43343f0b442bb465218a9">STARPU_CUDA_WORKER</a>, 0);</div></div><!-- fragment --><p>or equivalently</p>
<div class="fragment"><div class="line"><a class="code" href="group__API__Insert__Task.html#gad79a50a21fe717126659b2998209c1c6">starpu_task_insert</a>(&amp;cl, ..., <a class="code" href="group__API__Insert__Task.html#ga71d2b5f941b3c05d67a7d002e834a753">STARPU_EXECUTE_ON_WORKER</a>, <a class="code" href="group__API__Workers__Properties.html#gab0ffe5622c5980444226f1ed8d6fee71">starpu_worker_get_by_type</a>(<a class="code" href="group__API__Workers__Properties.html#gga173d616aefe98c33a47a847fd2fca37da26ced4e9dfc43343f0b442bb465218a9">STARPU_CUDA_WORKER</a>, 0), ...);</div></div><!-- fragment --><p>One can also specify a set worker(s) which are allowed to take the task, as an array of bit, for instance to allow workers 2 and 42:</p>
<div class="fragment"><div class="line">task-&gt;workerids = calloc(2,<span class="keyword">sizeof</span>(uint32_t));</div><div class="line">task-&gt;workerids[2/32] |= (1 &lt;&lt; (2%32));</div><div class="line">task-&gt;workerids[42/32] |= (1 &lt;&lt; (42%32));</div><div class="line">task-&gt;workerids_len = 2;</div></div><!-- fragment --><p>One can also specify the order in which tasks must be executed by setting the <a class="el" href="group__API__Codelet__And__Tasks.html#a704b64ae35fc117b93a88ade0e1d6910">starpu_task::workerorder</a> field. If this field is set to a non-zero value, it provides the per-worker consecutive order in which tasks will be executed, starting from 1. For a given of such task, the worker will thus not execute it before all the tasks with smaller order value have been executed, notably in case those tasks are not available yet due to some dependencies. This eventually gives total control of task scheduling, and StarPU will only serve as a "self-timed" task runtime. Of course, the provided order has to be runnable, i.e. a task should should not depend on another task bound to the same worker with a bigger order.</p>
<p>Note however that using scheduling contexts while statically scheduling tasks on workers could be tricky. Be careful to schedule the tasks exactly on the workers of the corresponding contexts, otherwise the workers' corresponding scheduling structures may not be allocated or the execution of the application may deadlock. Moreover, the hypervisor should not be used when statically scheduling tasks.</p>
<h1><a class="anchor" id="Configuring"></a>
Heteroprio</h1>
<p>Within Heteroprio, one priority per processing unit type is assigned to each task, such that a task has several priorities. Each worker pops the task that has the highest priority for the hardware type it uses, which could be CPU or CUDA for example. Therefore, the priorities has to be used to manage the critical path, but also to promote the consumption of tasks by the more appropriate workers.</p>
<p>The tasks are stored inside buckets, where each bucket corresponds to a priority set. Then each worker uses an indirect access array to know the order in which it should access the buckets. Moreover, all the tasks inside a bucket must be compatible with all the processing units that may access it (at least).</p>
<p>As an example, see the following code where we have 5 types of tasks. CPU workers can compute all of them, but CUDA workers can only execute tasks of types 0 and 1, and is expected to go 20 and 30 time faster than the CPU, respectively. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="starpu__heteroprio_8h.html">starpu_heteroprio.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct </span><a class="code" href="group__API__Initialization__and__Termination.html#structstarpu__conf">starpu_conf</a> conf;</div><div class="line"><a class="code" href="group__API__Initialization__and__Termination.html#ga7f7f154a1bf9600b8ccd10436412660e">starpu_conf_init</a>(&amp;conf);</div><div class="line"></div><div class="line">conf.sched_policy_name = <span class="stringliteral">&quot;heteroprio&quot;</span>;</div><div class="line"></div><div class="line"></div><div class="line">conf.sched_policy_init = &amp;init_heteroprio;</div><div class="line"></div><div class="line"><a class="code" href="group__API__Initialization__and__Termination.html#ga9ce171bcbbee2edd169ba2649e6e75e3">starpu_init</a>(&amp;conf);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> init_heteroprio(<span class="keywordtype">unsigned</span> sched_ctx) {</div><div class="line">  <span class="comment">// CPU uses 5 buckets and visits them in the natural order</span></div><div class="line">  <a class="code" href="starpu__heteroprio_8h.html#abc1c378d03b3b3355a009b5935c0a864">starpu_heteroprio_set_nb_prios</a>(ctx, STARPU_CPU_IDX, 5);</div><div class="line">  <span class="comment">// It uses direct mapping idx =&gt; idx</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> idx = 0; idx &lt; 5; ++idx){</div><div class="line">    <a class="code" href="starpu__heteroprio_8h.html#a2b943f9b94d407ffff84f262637e4fd7">starpu_heteroprio_set_mapping</a>(ctx, STARPU_CPU_IDX, idx, idx);</div><div class="line">    <span class="comment">// If there is no CUDA worker we must tell that CPU is faster</span></div><div class="line">    <a class="code" href="starpu__heteroprio_8h.html#a8e210d19e4ebb4cb599b87524a7e485b">starpu_heteroprio_set_faster_arch</a>(ctx, STARPU_CPU_IDX, idx);</div><div class="line">  }</div><div class="line">  </div><div class="line">  <span class="keywordflow">if</span>(<a class="code" href="group__API__Workers__Properties.html#gacb9d262c066c047ae55f691adc876db3">starpu_cuda_worker_get_count</a>()){</div><div class="line">    <span class="comment">// CUDA is enabled and uses 2 buckets</span></div><div class="line">    <a class="code" href="starpu__heteroprio_8h.html#abc1c378d03b3b3355a009b5935c0a864">starpu_heteroprio_set_nb_prios</a>(ctx, STARPU_CUDA_IDX, 2);</div><div class="line">    <span class="comment">// CUDA will first look at bucket 1</span></div><div class="line">    <a class="code" href="starpu__heteroprio_8h.html#a2b943f9b94d407ffff84f262637e4fd7">starpu_heteroprio_set_mapping</a>(ctx, STARPU_CUDA_IDX, 0, 1);</div><div class="line">    <span class="comment">// CUDA will then look at bucket 2</span></div><div class="line">    <a class="code" href="starpu__heteroprio_8h.html#a2b943f9b94d407ffff84f262637e4fd7">starpu_heteroprio_set_mapping</a>(ctx, STARPU_CUDA_IDX, 1, 2);</div><div class="line"></div><div class="line">    <span class="comment">// For bucket 1 CUDA is the fastest</span></div><div class="line">    <a class="code" href="starpu__heteroprio_8h.html#a8e210d19e4ebb4cb599b87524a7e485b">starpu_heteroprio_set_faster_arch</a>(ctx, STARPU_CUDA_IDX, 1);</div><div class="line">    <span class="comment">// And CPU is 30 times slower</span></div><div class="line">    <a class="code" href="starpu__heteroprio_8h.html#ae84fbd17719dcb47ca3c534851f8890e">starpu_heteroprio_set_arch_slow_factor</a>(ctx, STARPU_CPU_IDX, 1, 30.0f);</div><div class="line">    </div><div class="line">    <span class="comment">// For bucket 0 CUDA is the fastest</span></div><div class="line">    <a class="code" href="starpu__heteroprio_8h.html#a8e210d19e4ebb4cb599b87524a7e485b">starpu_heteroprio_set_faster_arch</a>(ctx, STARPU_CUDA_IDX, 0);</div><div class="line">    <span class="comment">// And CPU is 20 times slower</span></div><div class="line">    <a class="code" href="starpu__heteroprio_8h.html#ae84fbd17719dcb47ca3c534851f8890e">starpu_heteroprio_set_arch_slow_factor</a>(ctx, STARPU_CPU_IDX, 0, 20.0f);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Then, when a task is inserted <b>the priority of the task will be used to select in which bucket is has to be stored</b>. So, in the given example, the priority of a task will be between 0 and 4 included. However, tasks of priorities 0-1 must provide CPU and CUDA kernels, and tasks of priorities 2-4 must provide CPU kernels (at least). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 22 2021 15:02:13 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
