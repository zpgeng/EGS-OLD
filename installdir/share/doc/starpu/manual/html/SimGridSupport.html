<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StarPU Handbook: SimGrid Support</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('SimGridSupport.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SimGrid Support </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>StarPU can use Simgrid in order to simulate execution on an arbitrary platform. This was tested with SimGrid from 3.11 to 3.16, and 3.18 to 3.29. SimGrid version 3.25 needs to be configured with -Denable_msg=ON . Other versions may have compatibility issues. 3.17 notably does not build at all. MPI simulation does not work with version 3.22.</p>
<h1><a class="anchor" id="Preparing"></a>
Preparing Your Application For Simulation</h1>
<p>There are a few technical details which need to be handled for an application to be simulated through SimGrid.</p>
<p>If the application uses <code>gettimeofday</code> to make its performance measurements, the real time will be used, which will be bogus. To get the simulated time, it has to use <a class="el" href="group__API__Miscellaneous__Helpers.html#ga34953348991f74a1cbd694fffb27f8b7">starpu_timing_now()</a> which returns the virtual timestamp in us.</p>
<p>For some technical reason, the application's .c file which contains <code>main()</code> has to be recompiled with <code><a class="el" href="starpu__simgrid__wrap_8h.html">starpu_simgrid_wrap.h</a></code>, which in the SimGrid case will <code># define main()</code> into <code>starpu_main()</code>, and it is <code>libstarpu</code> which will provide the real <code>main()</code> and will call the application's <code>main()</code>.</p>
<p>To be able to test with crazy data sizes, one may want to only allocate application data if the macro <code>STARPU_SIMGRID</code> is not defined. Passing a <code>NULL</code> pointer to <code>starpu_data_register</code> functions is fine, data will never be read/written to by StarPU in SimGrid mode anyway.</p>
<p>To be able to run the application with e.g. CUDA simulation on a system which does not have CUDA installed, one can fill the <a class="el" href="group__API__Codelet__And__Tasks.html#aa6a8436117176270c5372d4dfb006a1f">starpu_codelet::cuda_funcs</a> with <code></code>(void*)1, to express that there is a CUDA implementation, even if one does not actually provide it. StarPU will not actually run it in SimGrid mode anyway by default (unless the <a class="el" href="group__API__Codelet__And__Tasks.html#ga84a0cbbc97e89b4104b4ce3047608b94">STARPU_CODELET_SIMGRID_EXECUTE</a> or <a class="el" href="group__API__Codelet__And__Tasks.html#ga59e1f4653a39359c060b4d10bc0a39bf">STARPU_CODELET_SIMGRID_EXECUTE_AND_INJECT</a> flags are set in the codelet)</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="group__API__Codelet__And__Tasks.html#structstarpu__codelet">starpu_codelet</a> cl11 =</div><div class="line">{</div><div class="line">        .<a class="code" href="group__API__Codelet__And__Tasks.html#a593418a8961318e4085177abeeaa43ad">cpu_funcs</a> = {chol_cpu_codelet_update_u11},</div><div class="line">        .cpu_funcs_name = {<span class="stringliteral">&quot;chol_cpu_codelet_update_u11&quot;</span>},</div><div class="line"><span class="preprocessor">#ifdef STARPU_USE_CUDA</span></div><div class="line">        .cuda_funcs = {chol_cublas_codelet_update_u11},</div><div class="line"><span class="preprocessor">#elif defined(STARPU_SIMGRID)</span></div><div class="line">        .cuda_funcs = {(<span class="keywordtype">void</span>*)1},</div><div class="line">#endif</div><div class="line">        .<a class="code" href="group__API__Codelet__And__Tasks.html#a1bb02f890f2e10c348499dbd92b56496">nbuffers</a> = 1,</div><div class="line">        .modes = {STARPU_RW},</div><div class="line">        .model = &amp;chol_model_11</div><div class="line">};</div></div><!-- fragment --> <h1><a class="anchor" id="Calibration"></a>
Calibration</h1>
<p>The idea is to first compile StarPU normally, and run the application, so as to automatically benchmark the bus and the codelets.</p>
<pre class="fragment">$ ./configure &amp;&amp; make
$ STARPU_SCHED=dmda ./examples/matvecmult/matvecmult
[starpu][_starpu_load_history_based_model] Warning: model matvecmult
   is not calibrated, forcing calibration for this run. Use the
   STARPU_CALIBRATE environment variable to control this.
$ ...
$ STARPU_SCHED=dmda ./examples/matvecmult/matvecmult
TEST PASSED
</pre><p>Note that we force to use the scheduler <code>dmda</code> to generate performance models for the application. The application may need to be run several times before the model is calibrated.</p>
<h1><a class="anchor" id="Simulation"></a>
Simulation</h1>
<p>Then, recompile StarPU, passing <a class="el" href="CompilationConfiguration.html#enable-simgrid">--enable-simgrid</a> to <code>configure</code>. Make sure to keep all other <code>configure</code> options the same, and notably options such as <code>&ndash;enable-maxcudadev</code>.</p>
<pre class="fragment">$ ./configure --enable-simgrid
</pre><p>To specify the location of SimGrid, you can either set the environment variables <code>SIMGRID_CFLAGS</code> and <code>SIMGRID_LIBS</code>, or use the <code>configure</code> options <a class="el" href="CompilationConfiguration.html#with-simgrid-dir">--with-simgrid-dir</a>, <a class="el" href="CompilationConfiguration.html#with-simgrid-include-dir">--with-simgrid-include-dir</a> and <a class="el" href="CompilationConfiguration.html#with-simgrid-lib-dir">--with-simgrid-lib-dir</a>, for example</p>
<pre class="fragment">$ ./configure --with-simgrid-dir=/opt/local/simgrid
</pre><p>You can then re-run the application.</p>
<pre class="fragment">$ make
$ STARPU_SCHED=dmda ./examples/matvecmult/matvecmult
TEST FAILED !!!
</pre><p>It is normal that the test fails: since the computation are not actually done (that is the whole point of SimGrid), the result is wrong, of course.</p>
<p>If the performance model is not calibrated enough, the following error message will be displayed</p>
<pre class="fragment">$ STARPU_SCHED=dmda ./examples/matvecmult/matvecmult
[starpu][_starpu_load_history_based_model] Warning: model matvecmult
    is not calibrated, forcing calibration for this run. Use the
    STARPU_CALIBRATE environment variable to control this.
[starpu][_starpu_simgrid_execute_job][assert failure] Codelet
    matvecmult does not have a perfmodel, or is not calibrated enough
</pre><p>The number of devices can be chosen as usual with <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_NCPU">STARPU_NCPU</a>, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_NCUDA">STARPU_NCUDA</a>, and <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_NOPENCL">STARPU_NOPENCL</a>, and the amount of GPU memory with <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_CUDA_MEM">STARPU_LIMIT_CUDA_MEM</a>, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_CUDA_devid_MEM">STARPU_LIMIT_CUDA_devid_MEM</a>, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_OPENCL_MEM">STARPU_LIMIT_OPENCL_MEM</a>, and <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_LIMIT_OPENCL_devid_MEM">STARPU_LIMIT_OPENCL_devid_MEM</a>.</p>
<h1><a class="anchor" id="SimulationOnAnotherMachine"></a>
Simulation On Another Machine</h1>
<p>The SimGrid support even permits to perform simulations on another machine, your desktop, typically. To achieve this, one still needs to perform the Calibration step on the actual machine to be simulated, then copy them to your desktop machine (the <code>$STARPU_HOME/.starpu</code> directory). One can then perform the Simulation step on the desktop machine, by setting the environment variable <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_HOSTNAME">STARPU_HOSTNAME</a> to the name of the actual machine, to make StarPU use the performance models of the simulated machine even on the desktop machine.</p>
<p>If the desktop machine does not have CUDA or OpenCL, StarPU is still able to use SimGrid to simulate execution with CUDA/OpenCL devices, but the application source code will probably disable the CUDA and OpenCL codelets in that case. Since during SimGrid execution, the functions of the codelet are actually not called by default, one can use dummy functions such as the following to still permit CUDA or OpenCL execution.</p>
<h1><a class="anchor" id="SimulationExamples"></a>
Simulation Examples</h1>
<p>StarPU ships a few performance models for a couple of systems: <code>attila</code>, <code>mirage</code>, <code>idgraf</code>, and <code>sirocco</code>. See Section <a class="el" href="BuildingAndInstallingStarPU.html#SimulatedBenchmarks">Simulated Benchmarks</a> for the details.</p>
<h1><a class="anchor" id="FakeSimulations"></a>
Simulations On Fake Machines</h1>
<p>It is possible to build fake machines which do not exist, by modifying the platform file in <code>$STARPU_HOME/.starpu/sampling/bus/machine.platform.xml</code> by hand: one can add more CPUs, add GPUs (but the performance model file has to be extended as well), change the available GPU memory size, PCI memory bandwidth, etc.</p>
<h1><a class="anchor" id="TweakingSimulation"></a>
Tweaking Simulation</h1>
<p>The simulation can be tweaked, to be able to tune it between a very accurate simulation and a very simple simulation (which is thus close to scheduling theory results), see the <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SIMGRID_TRANSFER_COST">STARPU_SIMGRID_TRANSFER_COST</a>, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SIMGRID_CUDA_MALLOC_COST">STARPU_SIMGRID_CUDA_MALLOC_COST</a>, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SIMGRID_CUDA_QUEUE_COST">STARPU_SIMGRID_CUDA_QUEUE_COST</a>, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SIMGRID_TASK_SUBMIT_COST">STARPU_SIMGRID_TASK_SUBMIT_COST</a>, <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SIMGRID_FETCHING_INPUT_COST">STARPU_SIMGRID_FETCHING_INPUT_COST</a> and <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_SIMGRID_SCHED_COST">STARPU_SIMGRID_SCHED_COST</a> environment variables.</p>
<h1><a class="anchor" id="SimulationMPIApplications"></a>
MPI Applications</h1>
<p>StarPU-MPI applications can also be run in SimGrid mode. smpi currently requires that StarPU be build statically only, so <code>&ndash;disable-shared</code> needs to be passed to <code>./configure</code>.</p>
<p>The application needs to be compiled with <code>smpicc</code>, and run using the <code>starpu_smpirun</code> script, for instance:</p>
<pre class="fragment">$ STARPU_SCHED=dmda starpu_smpirun -platform cluster.xml -hostfile hostfile ./mpi/tests/pingpong
</pre><p>Where <code>cluster.xml</code> is a SimGrid-MPI platform description, and <code>hostfile</code> the list of MPI nodes to be used. StarPU currently only supports homogeneous MPI clusters: for each MPI node it will just replicate the architecture referred by <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_HOSTNAME">STARPU_HOSTNAME</a>.</p>
<p>So as to use FxT traces, libfxt also needs to be built statically, <b>and</b> with dynamic linking flags, i.e. with</p>
<pre class="fragment">CFLAGS=-fPIC ./configure --enable-static
</pre><h1><a class="anchor" id="SimulationDebuggingApplications"></a>
Debugging Applications</h1>
<p>By default, SimGrid uses its own implementation of threads, which prevents <code>gdb</code> from being able to inspect stacks of all threads. To be able to fully debug an application running with SimGrid, pass the <code>&ndash;cfg=contexts/factory:thread</code> option to the application, to make SimGrid use system threads, which <code>gdb</code> will be able to manipulate as usual.</p>
<p>It is also worth noting SimGrid 3.21's new parameter <code>&ndash;cfg=simix/breakpoint</code> which allows to put a breakpoint at a precise (deterministic!) timing of the execution. If for instance in an execution trace we see that something odd is happening at time 19000ms, we can use <code>&ndash;cfg=simix/breakpoint:19.000</code> and <code>SIGTRAP</code> will be raised at that point, which will thus interrupt execution within <code>gdb</code>, allowing to inspect e.g. scheduler state, etc.</p>
<h1><a class="anchor" id="SimulationMemoryUsage"></a>
Memory Usage</h1>
<p>Since kernels are not actually run and data transfers are not actually performed, the data memory does not actually need to be allocated. This allows for instance to simulate the execution of applications processing very big data on a small laptop.</p>
<p>The application can for instance pass <code>1</code> (or whatever bogus pointer) to starpu data registration functions, instead of allocating data. This will however require the application to take care of not trying to access the data, and will not work in MPI mode, which performs transfers.</p>
<p>Another way is to pass the <a class="el" href="group__API__Standard__Memory__Library.html#ga67c2ba763b260bea998b16881c788ae6">STARPU_MALLOC_SIMULATION_FOLDED</a> flag to the <a class="el" href="group__API__Standard__Memory__Library.html#gaebaa5a1503be11ba7da92f72a8e601b2">starpu_malloc_flags()</a> function. This will make it allocate a memory area which one can read/write, but optimized so that this does not actually consume memory. Of course, the values read from such area will be bogus, but this allows the application to keep e.g. data load, store, initialization as it is, and also work in MPI mode.</p>
<p>Note however that notably Linux kernels refuse obvious memory overcommitting by default, so a single allocation can typically not be bigger than the amount of physical memory, see <a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting">https://www.kernel.org/doc/Documentation/vm/overcommit-accounting</a> This prevents for instance from allocating a single huge matrix. Allocating a huge matrix in several tiles is not a problem, however. <code>sysctl vm.overcommit_memory=1</code> can also be used to allow such overcommit.</p>
<p>Note however that this folding is done by remapping the same file several times, and Linux kernels will also refuse to create too many memory areas. <code>sysctl vm.max_map_count</code> can be used to check and change the default (65535). By default, StarPU uses a 1MiB file, so it hopefully fits in the CPU cache. This however limits the amount of such folded memory to a bit below 64GiB. The <a class="el" href="ExecutionConfigurationThroughEnvironmentVariables.html#STARPU_MALLOC_SIMULATION_FOLD">STARPU_MALLOC_SIMULATION_FOLD</a> environment variable can be used to increase the size of the file. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 22 2021 15:02:16 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
