<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StarPU Handbook: Clustering A Machine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StarPU Handbook
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ClusteringAMachine.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Clustering A Machine </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="ClusteringGeneralIdeas"></a>
General Ideas</h1>
<p>Clusters are a concept introduced in this <a href="https://hal.inria.fr/view/index/docid/1181135">paper</a>.</p>
<p>The granularity problem is tackled by using resource aggregation: instead of dynamically splitting tasks, resources are aggregated to process coarse grain tasks in a parallel fashion. This is built on top of scheduling contexts to be able to handle any type of parallel tasks.</p>
<p>This comes from a basic idea, making use of two levels of parallelism in a DAG. We keep the DAG parallelism but consider on top of it that a task can contain internal parallelism. A good example is if each task in the DAG is OpenMP enabled.</p>
<p>The particularity of such tasks is that we will combine the power of two runtime systems: StarPU will manage the DAG parallelism and another runtime (e.g. OpenMP) will manage the internal parallelism. The challenge is in creating an interface between the two runtime systems so that StarPU can regroup cores inside a machine (creating what we call a <b>cluster</b>) on top of which the parallel tasks (e.g. OpenMP tasks) will be run in a contained fashion.</p>
<p>The aim of the cluster API is to facilitate this process in an automatic fashion. For this purpose, we depend on the <code>hwloc</code> tool to detect the machine configuration and then partition it into usable clusters.</p>
<p><br />
</p>
<p>An example of code running on clusters is available in <code>examples/sched_ctx/parallel_tasks_with_cluster_api.c</code>.</p>
<p><br />
</p>
<p>Let's first look at how to create a cluster.</p>
<p>To enable clusters in StarPU, one needs to set the configure option <a class="el" href="CompilationConfiguration.html#enable-cluster">--enable-cluster</a>.</p>
<h1><a class="anchor" id="CreatingClusters"></a>
Creating Clusters</h1>
<p>Partitioning a machine into clusters with the cluster API is fairly straightforward. The simplest way is to state under which machine topology level we wish to regroup all resources. This level is an <code>hwloc</code> object, of the type <code>hwloc_obj_type_t</code>. More information can be found in the <a href="https://www.open-mpi.org/projects/hwloc/doc/v2.0.3/">hwloc documentation</a>.</p>
<p>Once a cluster is created, the full machine is represented with an opaque structure starpu_cluster_machine. This can be printed to show the current machine state.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>starpu_cluster_machine *clusters;</div><div class="line">clusters = starpu_cluster_machine(HWLOC_OBJ_SOCKET, 0);</div><div class="line">starpu_cluster_print(clusters);</div><div class="line"></div><div class="line"><span class="comment">/* submit some tasks with OpenMP computations */</span></div><div class="line"></div><div class="line">starpu_uncluster_machine(clusters);</div><div class="line"><span class="comment">/* we are back in the default StarPU state */</span></div></div><!-- fragment --><p>The following graphic is an example of what a particular machine can look like once clusterized. The main difference is that we have less worker queues and tasks which will be executed on several resources at once. The execution of these tasks will be left to the internal runtime system, represented with a dashed box around the resources.</p>
 <div class="image">
<img src="runtime-par.png" alt="runtime-par.png"/>
<div class="caption">
StarPU using parallel tasks</div></div>
<p> Creating clusters as shown in the example above will create workers able to execute OpenMP code by default. The cluster creation function starpu_cluster_machine() takes optional parameters after the <code>hwloc</code> object (always terminated by the value <code>0</code>) which allow to parametrize the cluster creation. These parameters can help creating clusters of a type different from OpenMP, or create a more precise partition of the machine.</p>
<p>This is explained in Section <a class="el" href="ClusteringAMachine.html#CreatingCustomClusters">Creating Custom Clusters</a>.</p>
<h1><a class="anchor" id="ExampleOfConstrainingOpenMP"></a>
Example Of Constraining OpenMP</h1>
<p>Clusters require being able to constrain the runtime managing the internal task parallelism (internal runtime) to the resources set by StarPU. The purpose of this is to express how StarPU must communicate with the internal runtime to achieve the required cooperation. In the case of OpenMP, StarPU will provide an awake thread from the cluster to execute this liaison. It will then provide on demand the process ids of the other resources supposed to be in the region. Finally, thanks to an OpenMP region we can create the required number of threads and bind each of them on the correct region. These will then be reused each time we encounter a <code>#pragma omp parallel</code> in the following computations of our program.</p>
<p>The following graphic is an example of what an OpenMP-type cluster looks like and how it represented in StarPU. We can see that one StarPU (black) thread is awake, and we need to create on the other resources the OpenMP threads (in pink).</p>
 <div class="image">
<img src="parallel_worker2.png" alt="parallel_worker2.png"/>
<div class="caption">
StarPU with an OpenMP cluster</div></div>
<p> Finally, the following code shows how to force OpenMP to cooperate with StarPU and create the aforementioned OpenMP threads constrained in the cluster's resources set: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__API__Clustering__Machine.html#ga4e4b38133227e47f44b7f999b06e9e9a">starpu_openmp_prologue</a>(<span class="keywordtype">void</span> * sched_ctx_id)</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> sched_ctx = *(<span class="keywordtype">int</span>*)sched_ctx_id;</div><div class="line">  <span class="keywordtype">int</span> *cpuids = NULL;</div><div class="line">  <span class="keywordtype">int</span> ncpuids = 0;</div><div class="line">  <span class="keywordtype">int</span> workerid = <a class="code" href="group__API__Workers__Properties.html#gac6d06f4e22b63bf50bc8e836cf16f81f">starpu_worker_get_id</a>();</div><div class="line"></div><div class="line">  <span class="comment">//we can target only CPU workers</span></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="group__API__Workers__Properties.html#ga4998e4e1dfa0d121059c60f790496a03">starpu_worker_get_type</a>(workerid) == <a class="code" href="group__API__Workers__Properties.html#gga173d616aefe98c33a47a847fd2fca37da7fa269b896814504abcf227388233d1f">STARPU_CPU_WORKER</a>)</div><div class="line">  {</div><div class="line">    <span class="comment">//grab all the ids inside the cluster</span></div><div class="line">    starpu_sched_ctx_get_available_cpuids(sched_ctx, &amp;cpuids, &amp;ncpuids);</div><div class="line">    <span class="comment">//set the number of threads</span></div><div class="line">    omp_set_num_threads(ncpuids);</div><div class="line"><span class="preprocessor">#pragma omp parallel</span></div><div class="line">    {</div><div class="line">      <span class="comment">//bind each threads to its respective resource</span></div><div class="line">      starpu_sched_ctx_bind_current_thread_to_cpuid(cpuids[omp_get_thread_num()]);</div><div class="line">    }</div><div class="line">    free(cpuids);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span>;</div><div class="line">}</div></div><!-- fragment --><p>This function is the default function used when calling starpu_cluster_machine() without extra parameter.</p>
<p>Cluster are based on several tools and models already available within StarPU contexts, and merely extend contexts. More on contexts can be read in Section <a class="el" href="SchedulingContexts.html">Scheduling Contexts</a>.</p>
<h1><a class="anchor" id="CreatingCustomClusters"></a>
Creating Custom Clusters</h1>
<p>Clusters can be created either with the predefined types provided within StarPU, or with user-defined functions to bind another runtime inside StarPU.</p>
<p>The predefined cluster types provided by StarPU are <a class="el" href="group__API__Clustering__Machine.html#gga63c001ace567446514f1616e34af1bf6a0afa9b0aa7b4d006cc67a99548671e8f">STARPU_CLUSTER_OPENMP</a>, <a class="el" href="group__API__Clustering__Machine.html#gga63c001ace567446514f1616e34af1bf6a0e9ba9f1b08de5b272d5b9b12cbd4705">STARPU_CLUSTER_INTEL_OPENMP_MKL</a> and <a class="el" href="group__API__Clustering__Machine.html#gga63c001ace567446514f1616e34af1bf6a6e708593a63aa51226ec371e40c9836e">STARPU_CLUSTER_GNU_OPENMP_MKL</a>. The last one is only provided if StarPU is compiled with the <code>MKL</code> library. It uses MKL functions to set the number of threads which is more reliable when using an OpenMP implementation different from the Intel one.</p>
<p>The cluster type is set when calling the function starpu_cluster_machine() with the parameter <a class="el" href="group__API__Clustering__Machine.html#ga2e53785730d1c02357c5fbc5e4a4ce56">STARPU_CLUSTER_TYPE</a> as in the example below, which is creating a <code>MKL</code> cluster.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>starpu_cluster_machine *clusters;</div><div class="line">clusters = starpu_cluster_machine(HWLOC_OBJ_SOCKET,</div><div class="line">                                 <a class="code" href="group__API__Clustering__Machine.html#ga2e53785730d1c02357c5fbc5e4a4ce56">STARPU_CLUSTER_TYPE</a>, <a class="code" href="group__API__Clustering__Machine.html#gga63c001ace567446514f1616e34af1bf6a6e708593a63aa51226ec371e40c9836e">STARPU_CLUSTER_GNU_OPENMP_MKL</a>,</div><div class="line">                                 0);</div></div><!-- fragment --><p>Using the default type <a class="el" href="group__API__Clustering__Machine.html#gga63c001ace567446514f1616e34af1bf6a0afa9b0aa7b4d006cc67a99548671e8f">STARPU_CLUSTER_OPENMP</a> is similar to calling starpu_cluster_machine() without any extra parameter.</p>
<p><br />
</p>
<p>Users can also define their own function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo_func(<span class="keywordtype">void</span>* foo_arg);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> foo_arg = 0;</div><div class="line"><span class="keyword">struct </span>starpu_cluster_machine *clusters;</div><div class="line">clusters = starpu_cluster_machine(HWLOC_OBJ_SOCKET,</div><div class="line">                                  <a class="code" href="group__API__Clustering__Machine.html#ga6dc4b6d66ef90b7927559c9e2728a84b">STARPU_CLUSTER_CREATE_FUNC</a>, &amp;foo_func,</div><div class="line">                                  <a class="code" href="group__API__Clustering__Machine.html#ga6cd34b24aaea1b26df96b7aff9238759">STARPU_CLUSTER_CREATE_FUNC_ARG</a>, &amp;foo_arg,</div><div class="line">                                  0);</div></div><!-- fragment --><p>Parameters that can be given to starpu_cluster_machine() are <a class="el" href="group__API__Clustering__Machine.html#ga3f0e66f06b1692257c085f2340e219a6">STARPU_CLUSTER_MIN_NB</a>, <a class="el" href="group__API__Clustering__Machine.html#gae3e9c312827d1aed06ba10928df08760">STARPU_CLUSTER_MAX_NB</a>, <a class="el" href="group__API__Clustering__Machine.html#gad448a91528b4cd29b0426b4cf753387b">STARPU_CLUSTER_NB</a>, <a class="el" href="group__API__Clustering__Machine.html#ga3364354b5ce437fb90744581504dc672">STARPU_CLUSTER_POLICY_NAME</a>, <a class="el" href="group__API__Clustering__Machine.html#ga0b8011473a2abad180217861366c5a19">STARPU_CLUSTER_POLICY_STRUCT</a>, <a class="el" href="group__API__Clustering__Machine.html#gae6b207e422827171dc53b1ae2a842d46">STARPU_CLUSTER_KEEP_HOMOGENEOUS</a>, <a class="el" href="group__API__Clustering__Machine.html#ga97cd9955370e77c3b251dfc5e94c2080">STARPU_CLUSTER_PREFERE_MIN</a>, <a class="el" href="group__API__Clustering__Machine.html#ga6dc4b6d66ef90b7927559c9e2728a84b">STARPU_CLUSTER_CREATE_FUNC</a>, <a class="el" href="group__API__Clustering__Machine.html#ga6cd34b24aaea1b26df96b7aff9238759">STARPU_CLUSTER_CREATE_FUNC_ARG</a>, <a class="el" href="group__API__Clustering__Machine.html#ga2e53785730d1c02357c5fbc5e4a4ce56">STARPU_CLUSTER_TYPE</a>, <a class="el" href="group__API__Clustering__Machine.html#ga6418a1fed34b32217d66860cbf8fc200">STARPU_CLUSTER_AWAKE_WORKERS</a>, <a class="el" href="group__API__Clustering__Machine.html#ga9b42af113646bf23c74e890fd766af31">STARPU_CLUSTER_PARTITION_ONE</a>, <a class="el" href="group__API__Clustering__Machine.html#ga718ac3b3060472256eceb68147a112b9">STARPU_CLUSTER_NEW</a> and <a class="el" href="group__API__Clustering__Machine.html#gab630219c3f24cfa1b3c096bdd19d5868">STARPU_CLUSTER_NCORES</a>.</p>
<h1><a class="anchor" id="ClustersWithSchedulingContextsAPI"></a>
Clusters With Scheduling</h1>
<p>As previously mentioned, the cluster API is implemented on top of <a class="el" href="SchedulingContexts.html">Scheduling Contexts</a>. Its main addition is to ease the creation of a machine CPU partition with no overlapping by using <code>hwloc</code>, whereas scheduling contexts can use any number of any type of resources.</p>
<p>It is therefore possible, but not recommended, to create clusters using the scheduling contexts API. This can be useful mostly in the most complex machine configurations where users have to dimension precisely clusters by hand using their own algorithm.</p>
<div class="fragment"><div class="line"><span class="comment">/* the list of resources the context will manage */</span></div><div class="line"><span class="keywordtype">int</span> workerids[3] = {1, 3, 10};</div><div class="line"></div><div class="line"><span class="comment">/* indicate the list of workers assigned to it, the number of workers,</span></div><div class="line"><span class="comment">the name of the context and the scheduling policy to be used within</span></div><div class="line"><span class="comment">the context */</span></div><div class="line"><span class="keywordtype">int</span> id_ctx = <a class="code" href="group__API__Scheduling__Contexts.html#ga517b7cf4bfac60f2faf484584f19d9d3">starpu_sched_ctx_create</a>(workerids, 3, <span class="stringliteral">&quot;my_ctx&quot;</span>, 0);</div><div class="line"></div><div class="line"><span class="comment">/* let StarPU know that the following tasks will be submitted to this context */</span></div><div class="line">starpu_sched_ctx_set_task_context(<span class="keywordtype">id</span>);</div><div class="line"></div><div class="line">task-&gt;<a class="code" href="group__API__Codelet__And__Tasks.html#ad4b215b1fc4ae0fc29c98cf8a26029c7">prologue_callback_pop_func</a>=&amp;runtime_interface_function_here;</div><div class="line"></div><div class="line"><span class="comment">/* submit the task to StarPU */</span></div><div class="line"><a class="code" href="group__API__Codelet__And__Tasks.html#gaa32228bf7f452f7d664986668ea46590">starpu_task_submit</a>(task);</div></div><!-- fragment --><p>As this example illustrates, creating a context without scheduling policy will create a cluster. The interface function between StarPU and the other runtime must be specified through the field <a class="el" href="group__API__Codelet__And__Tasks.html#ad4b215b1fc4ae0fc29c98cf8a26029c7">starpu_task::prologue_callback_pop_func</a>. Such a function can be similar to the OpenMP thread team creation one (see above).</p>
<p><br />
</p>
<p>Note that the OpenMP mode is the default mode both for clusters and contexts. The result of a cluster creation is a woken-up master worker and sleeping "slaves" which allow the master to run tasks on their resources.</p>
<p>To create a cluster with woken-up workers, the flag <a class="el" href="group__API__Scheduling__Contexts.html#gad96f61bfad5945d03f32dfec0032f7ca">STARPU_SCHED_CTX_AWAKE_WORKERS</a> must be set when using the scheduling context API function <a class="el" href="group__API__Scheduling__Contexts.html#ga517b7cf4bfac60f2faf484584f19d9d3">starpu_sched_ctx_create()</a>, or the flag <a class="el" href="group__API__Clustering__Machine.html#ga6418a1fed34b32217d66860cbf8fc200">STARPU_CLUSTER_AWAKE_WORKERS</a> must be set when using the cluster API function starpu_cluster_machine(). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 22 2021 15:02:17 for StarPU Handbook by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
